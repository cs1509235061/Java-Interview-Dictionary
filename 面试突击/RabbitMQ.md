\# Quartz 定时任务

\### 1.什么是 Quartz 框架

Quartz是一个开源的作业调度框架，它完全由 Java 写成，并设计用于 J2SE 和 J2EE 应用中。它提供了巨大的灵活性而不牺牲简单性 。你能够用它来为执行一个作业而创建简单的或复杂的调度。

\### 2.配置文件 applicationContext_job.xml 各个属性作用

（1 ）、 Job ：表示一个任务（工作），要执行的具体内容。
（2 ）、 JobDetail ：表示一个具体的可执行的调度程序 Job 是这个可执行程调度程序所要执行的内容，另外JobDetail 还包含了这个任务调度的方案和策略。
（3 ）、 Trigger ：代表一个调度参数的配置，什么时候去调。
（4 ）、 Scheduler ：代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger 。当 Trigger 与JobDetail 组合，就可以被 Scheduler 容器调度了。

\### 3.Cron表达式详解

Cron表达式是一个字符串，字符串以 5 或 6 个空格隔开，分为 6 或 7 个域，每一个域代表一个含义。
域：
Seconds（秒）：可出现 ", - * /"四个字符，有效范围为 0 -59 的整数。
Minutes（分钟）：可出现 ", - * /" 四个字符，有效范围为 0- 59 的 整数 。
Hours（小时）： 可出现 ", - * /"  四个字符，有效范围为 0- 23 的整数 。
DayofMonth（日 of 月）：可出现 ", - * / ? L W C"八个字符，有效范围为 0 -31 的整数。
Month（月）： 可出现 ", - * /"四个字符，有效范围为 1- 12 的整数。
DayofWeek（日 of 星期） 可出现 ", - * / ? L C # “ 八个字符，有效范围为 1- 7 的整数， 1 表示星期天， 2 表示星期一， 依次类推。
Year（年）：可出现 ", - * /"四个字符，有效范围为 1970 -2099 年。

\### 4.如何监控 Quartz 的 job 执行状态：运行中，暂停中，等待中？

通过往表（新建一个操作日志表）里插入日志的形式：
1）运行中：通过 JobListener 监听器来实现运行时更改表信息。
2）暂停中：调用 scheduler.pauseTrigger() 方法时，更改表中 job 信息。
3）等待中：新添加的 job 默认给其等待中的状态，也是更改表中的 job 信息 但是上面这种形式的麻烦之处是得频繁的往表里插入数据。



# RabbitMQ

## 1.概念

RabbitMQ 是一个由Erlang 语言开发的AMQP 的开源实现。

AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。

RabbitMQ 最初起源于金融系统，用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。具体特点包括：

1.可靠性（Reliability）：RabbitMQ 使用一些机制来保证可靠性，如持久化、传输确认、发布确认。

2.灵活的路由（Flexible Routing）：在消息进入队列之前，通过Exchange 来路由消息的。对于典型的路由功能，RabbitMQ 已经提供了一些内置的Exchange 来实现。针对更复杂的路由功能，可以将多个Exchange 绑定在一起，也通过插件机制实现自己的Exchange 。

3.消息集群（Clustering）：多个RabbitMQ 服务器可以组成一个集群，形成一个逻辑Broker 。

4.高可用（Highly Available Queues）：队列可以在集群中的机器上进行镜像，使得在部分节点出问题的情况下队列仍然可用。

5.多种协议（Multi-protocol）：RabbitMQ 支持多种消息队列协议，比如STOMP、MQTT 等等。

6.多语言客户端（Many Clients）：RabbitMQ 几乎支持所有常用语言，比如Java、.NET、Ruby 等等。

7.管理界面（Management UI）:RabbitMQ 提供了一个易用的用户界面，使得用户可以监控和管理消息Broker 的许多方面。

8.跟踪机制（Tracing）:如果消息异常，RabbitMQ 提供了消息跟踪机制，使用者可以找出发生了什么。

9.插件机制（Plugin System）:RabbitMQ 提供了许多插件，来从多方面进行扩展，也可以编写自己的插件。

## 2.RabbitMQ架构

### Message

消息，消息是不具名的，它由消息头和消息体组成。消息体是不透明的，而消息头则由一系列的可选属性组成，这些属性包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等。

### Publisher

1.消息的生产者，也是一个向交换器发布消息的客户端应用程序。

### Exchange（将消息路由给队列）

2.交换器，用来接收生产者发送的消息并将这些消息路由给服务器中的队列。

### Binding（消息队列和交换器之间的关联）

3.绑定，用于消息队列和交换器之间的关联。一个绑定就是基于路由键将交换器和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表。

### Queue

4.消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走。

### Connection

5.网络连接，比如一个TCP连接。

### Channel

6.信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟连接，AMQP 命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说建立和销毁TCP 都是非常昂贵的开销，所以引入了信道的概念，以复用一条TCP 连接。

### Consumer

7.消息的消费者，表示一个从消息队列中取得消息的客户端应用程序。

### Virtual Host

8.虚拟主机，表示一批交换器、消息队列和相关对象。虚拟主机是共享相同的身份认证和加密环境的独立服务器域。

### Broker

9.表示消息队列服务器实体。

## 3.Exchange 类型

Exchange分发消息时根据类型的不同分发策略有区别，目前共四种类型：direct、fanout、topic、headers 。headers 匹配AMQP 消息的header 而不是路由键，此外headers 交换器和direct 交换器完全一致，但性能差很多，目前几乎用不到了，所以直接看另外三种类型：

### Direct键（routing key）分布：

1.Direct：消息中的路由键（routing key）如果和Binding 中的binding key 一致，交换器就将消息发到对应的队列中。它是完全匹配、单播的模式。

### Fanout（广播分发）

2.Fanout：每个发到fanout 类型交换器的消息都会分到所有绑定的队列上去。很像子网广播，每台子网内的主机都获得了一份复制的消息。fanout 类型转发消息是最快的。

### topic 交换器（模式匹配）

3.topic 交换器：topic 交换器通过模式匹配分配消息的路由键属性，将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。它同样也会识别两个通配符：符号“#”和符号“”。#匹配0个或多个单词，匹配不多不少一个单词。

## 4.RabbitMQ 的高可用性

**基于主从**（非分布式）做高可用性的

RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。

### 单机模式

基本都在本地玩,生产没人用.

### 普通集群模式

普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你**创建的 queue，只会放在一个 RabbitMQ 实例上**，但是每个实例都同步 queue 的元数据（元数据可以认为是 queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么那个实例会从 queue 所在实例上拉取数据过来。

导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个 queue 所在实例消费数据，前者有**数据拉取的开销**，后者导致**单实例性能瓶颈**。

而且如果那个放 queue 的实例宕机了，会导致接下来其他实例就无法从那个实例拉取，如果你**开启了消息持久化**，让 RabbitMQ 落地存储消息的话，**消息不一定会丢**，得等这个实例恢复了，然后才可以继续从这个 queue 拉取数据。

这就**没有什么所谓的高可用性**，**这方案主要是提高吞吐量的**，就是说让集群中多个节点来服务某个 queue 的读写操作。

### 镜像集群模式（高可用性）

你创建的 queue，无论元数据还是 queue 里的消息都会**存在于多个实例上**，就是说，每个 RabbitMQ 节点都有这个 queue 的一个**完整镜像**，包含 queue 的全部数据的意思。然后每次你写消息到 queue 的时候，都会自动把**消息同步**到多个实例的 queue 上。

那么**如何开启这个镜像集群模式**呢？其实很简单，RabbitMQ 有很好的管理控制台，就是在后台新增一个策略，这个策略是**镜像集群模式的策略**，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。

这样的话，好处在于，你任何一个机器宕机了，没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！第二，这么玩儿，不是分布式的，就**没有扩展性可言**了，如果某个 queue 负载很重，你加机器，新增的机器也包含了这个 queue 的所有数据，并**没有办法线性扩展**你的 queue。你想，如果这个 queue 的数据量很大，大到这个机器上的容量无法容纳了，此时该怎么办呢？

## 5.如何保证消息的可靠性传输？

### 生产者弄丢了数据

生产者将数据发送到 RabbitMQ 的时候，可能数据就在半路给搞丢了，因为网络问题啥的，都有可能。

此时可以选择用 RabbitMQ 提供的事务功能，就是生产者**发送数据之前**开启 RabbitMQ 事务 `channel.txSelect` ，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务 `channel.txRollback` ，然后重试发送消息；如果收到了消息，那么可以提交事务 `channel.txCommit` 。

但是问题是，RabbitMQ 事务机制（同步）一搞，基本上**吞吐量会下来，因为太耗性能**。

所以一般来说，如果你要确保说写 RabbitMQ 的消息别丢，可以开启 `confirm` 模式，在生产者那里设置开启 `confirm` 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 `ack` 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 `nack` 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。

事务机制和 `confirm` 机制最大的不同在于，**事务机制是同步的**，你提交一个事务之后会**阻塞**在那儿，但是 `confirm` 机制是**异步**的，你发送个消息之后就可以发送下一个消息，然后那个消息 RabbitMQ 接收了之后会异步回调你的一个接口通知你这个消息接收到了。

所以一般在生产者这块**避免数据丢失**，都是用 `confirm` 机制的。

### RabbitMQ 弄丢了数据

就是 RabbitMQ 自己弄丢了数据，这个你必须**开启 RabbitMQ 的持久化**，就是消息写入之后会持久化到磁盘，哪怕是 RabbitMQ 自己挂了，**恢复之后会自动读取之前存储的数据**，一般数据不会丢。除非极其罕见的是，RabbitMQ 还没持久化，自己就挂了，**可能导致少量数据丢失**，但是这个概率较小。

设置持久化有**两个步骤**：

- 创建 queue 的时候将其设置为持久化

这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的。

- 第二个是发送消息的时候将消息的 `deliveryMode` 设置为 2

就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。

必须要同时设置这两个持久化才行，RabbitMQ 哪怕是挂了，再次重启，也会从磁盘上重启恢复 queue，恢复这个 queue 里的数据。

注意，哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。

所以，持久化可以跟生产者那边的 `confirm` 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 `ack` 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 `ack` ，你也是可以自己重发的。

### 消费端弄丢了数据

RabbitMQ 如果丢失了数据，主要是因为你消费的时候，**刚消费到，还没处理，结果进程挂了**，比如重启了，那么就尴尬了，RabbitMQ 认为你都消费了，这数据就丢了。

这个时候得用 RabbitMQ 提供的 `ack` 机制，简单来说，就是你必须关闭 RabbitMQ 的自动 `ack` ，可以通过一个 api 来调用就行，然后每次你自己代码里确保处理完的时候，再在程序里 `ack` 一把。这样的话，如果你还没处理完，不就没有 `ack` 了？那 RabbitMQ 就认为你还没处理完，这个时候 RabbitMQ 会把这个消费分配给别的 consumer 去处理，消息是不会丢的。

## 6.如何保证消息的顺序性？

一个 queue，多个 consumer。比如，生产者向 RabbitMQ 里发送了三条数据，顺序依次是 data1/data2/data3，压入的是 RabbitMQ 的一个内存队列。有三个消费者分别从 MQ 中消费这三条数据中的一条，结果消费者 2 先执行完操作，把 data2 存入数据库，然后是 data1/data3。这不明显乱了。

### 解决方案

拆分多个 queue，每个 queue 一个 consumer，就是多一些 queue 而已，确实是麻烦点；或者就一个 queue 但是对应一个 consumer，然后这个 consumer 内部用内存队列做排队，然后分发给底层不同的 worker 来处理。

## 7.RabbitMQ 中 vhost 的作用是什么？

vhost：每个 RabbitMQ 都能创建很多 vhost，我们称之为虚拟主机，每个虚拟主机其实都是 mini 版的RabbitMQ，它拥有自己的队列，交换器和绑定，拥有自己的权限机制。

## 8.RabbitMQ 的消息是怎么发送的？

首先客户端必须连接到 RabbitMQ 服务器才能发布和消费消息，客户端和 rabbit server 之间会创建一个 tcp 连接，一旦 tcp 打开并通过了认证（认证就是你发送给 rabbit 服务器的用户名和密码），你的客户端和 RabbitMQ 就创建了一条 amqp 信道（channel），信道是创建在“真实” tcp 上的虚拟连接，amqp 命令都是通过信道发送出去的，每个信道都会有一个唯一的 id，不论是发布消息，订阅队列都是通过这个信道完成的。

## 9.RabbitMQ 怎么保证消息的稳定性？

提供了事务的功能。 通过将 channel 设置为 confirm（确认）模式。

## 10.RabbitMQ 怎么避免消息丢失？

把消息持久化磁盘，保证服务器重启消息不丢失。 每个集群中至少有一个物理磁盘，保证消息落入磁盘。

## 11.要保证消息持久化成功的条件有哪些？

声明队列必须设置持久化 durable 设置为 true. 消息推送投递模式必须设置持久化，deliveryMode 设置为 2（持久）。 消息已经到达持久化交换器。 消息已经到达持久化队列。 以上四个条件都满足才能保证消息持久化成功。

## 12.RabbitMQ 有几种广播类型？

direct（默认方式）：最基础最简单的模式，发送方把消息发送给订阅方，如果有多个订阅者，默认采取轮询的方式进行消息发送。 headers：与 direct 类似，只是性能很差，此类型几乎用不到。 fanout：分发模式，把消费分发给所有订阅者。 topic：匹配订阅模式，使用正则匹配到消息队列，能匹配到的都能接收到。

## 13.RabbitMQ 怎么实现延迟消息队列？

延迟队列的实现有两种方式： 通过消息过期后进入死信交换器，再由交换器转发到延迟消费队列，实现延迟功能； 使用 RabbitMQ-delayed-message-exchange 插件实现延迟功能。

## 14.RabbitMQ 节点的类型有哪些？

磁盘节点：消息会存储到磁盘。 内存节点：消息都存储在内存中，重启服务器消息丢失，性能高于磁盘类型。

## 15.RabbitMQ 集群搭建需要注意哪些问题？

各节点之间使用“--link”连接，此属性不能忽略。 各节点使用的 erlang cookie 值必须相同，此值相当于“秘钥”的功能，用于各节点的认证。 整个集群中必须包含一个磁盘节点。

## 16.RabbitMQ 集群中唯一一个磁盘节点崩溃了会发生什么情况？

如果唯一磁盘的磁盘节点崩溃了，不能进行以下操作： 不能创建队列 不能创建交换器 不能创建绑定 不能添加用户 不能更改权限 不能添加和删除集群节点 唯一磁盘节点崩溃了，集群是可以保持运行的，但你不能更改任何东西。

## 17.RabbitMQ 对集群节点停止顺序有要求吗？

RabbitMQ 对集群的停止的顺序是有要求的，应该先关闭内存节点，最后再关闭磁盘节点。如果顺序恰好相反的话，可能会造成消息的丢失。

## 18.如何确保消息正确地发送至 RabbitMQ？ 如何确保消息接收方消费了消息？

发送方确认模式 将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID。 一旦消息被投递到目的队列后，或者消息被写入磁盘后（可持久化的消息），信道会发送一个确认给生产者（包含消息唯一 ID）。 如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 nack（notacknowledged，未确认）消息。发送方确认模式是异步的，生产 者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消 息。 接收方确认机制 接收方消息确认机制 消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息 从队列中删除。这里并没有用到超时机制，RabbitMQ 仅通过 Consumer 的连接中断来确认是否需要重新发送消息。也就是说，只要连接 不中断，RabbitMQ 给了 Consumer 足够长的时间来处理消息。保证数据的最终一致性； 下面罗列几种特殊情况 如果消费者接收到消息，在确认之前断开了连接或取消订阅，RabbitMQ 会认为消息没有被分发，然后重新分发给下一个订阅的消费者。 （可能存在消息重复消费的隐患，需要去重）如果消费者接收到消息却没有确认消息，连接也未断开，则 RabbitMQ 认为该消费者繁忙，将 不会给该消费者分发更多的消息。

## 19.如何避免消息重复投递或重复消费？

在消息生产时，MQ 内部针对每条生产者发送的消息生成一个 inner-msg-id，作为去重的依据（消息投递失败并重传），避免重复的消息进 入队列； 在消息消费时，要求消息体中必须要有一个 bizId（对于同一业务全局唯一，如支付 ID、订单 ID、帖子 ID 等）作为去重的依据，避免同一 条消息被重复消费。

## 20.消息基于什么传输？

由于 TCP 连接的创建和销毁开销较大，且并发数受系统资源限制，会造成性能瓶颈。RabbitMQ 使用信道的方式来传输数据。信道是建立在 真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制

## 21.消息如何分发？

若该队列至少有一个消费者订阅，消息将以循环（round-robin）的方式发送给消费者。每条消息只会分发给一个订阅的消费者（前提是消 费者能够正常处理消息并进行确认）。 通过路由可实现多消费的功能

## 22.消息怎么路由？

消息提供方->路由->一至多个队列 消息发布到交换器时，消息将拥有一个路由键（routing key），在消息创建时设定。 通过队列路由键，可以把队列绑定到交换器上。 消息到达交换器后，RabbitMQ 会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）； 常用的交换器主要分为一下三种 fanout：如果交换器收到消息，将会广播到所有绑定的队列上 direct：如果路由键完全匹配，消息就被投递到相应的队列 topic：可以使来自不同源头的消息能够到达同一个队列。 使用 topic 交换器时，可以使用通配符

## 23.如何确保消息不丢失？

消息持久化，当然前提是队列必须持久化 RabbitMQ 确保持久性消息能从服务器重启中恢复的方式是，将它们写入磁盘上的一个持久化日志文件，当发布一条持久性消息到持久交换 器上时，Rabbit 会在消息提交到日志文件后才发送响应。 一旦消费者从持久队列中消费了一条持久化消息，RabbitMQ 会在持久化日志中把这条消息标记为等待垃圾收集。如果持久化消息在被消费 之前 RabbitMQ 重启，那么 Rabbit 会自动重建交换器和队列（以及绑定），并重新发布持久化日志文件中的消息到合适的队列。

## 24.如何保证高可用的？

RabbitMQ 是比较有代表性的，因为是基于主从（非分布式）做高可用性的，我们就以 RabbitMQ 为例子讲解第一种 MQ 的高可用性怎么 实现。RabbitMQ 有三种模式：单机模式、普通集群模式、镜像集群模式。 单机模式，就是 Demo 级别的，一般就是你本地启动了玩玩儿的?，没人生产用单机模式普通集群模式，意思就是在多台机器上启动多个 RabbitMQ 实例，每个机器启动一个。你创建的queue，只会放在一个 RabbitMQ 实例上，但是每个实例都同步 queue 的元数据（元数据 可以认为是queue 的一些配置信息，通过元数据，可以找到 queue 所在实例）。你消费的时候，实际上如果连接到了另外一个实例，那么 那个实例会从 queue 所在实例上拉取数据过来。这方案主要是提高吞吐量的，就是说让集群中多个节点来服务某个 queue 的读写操作。 镜像集群模式：这种模式，才是所谓的 RabbitMQ 的高可用模式。跟普通集群模式不一样的是，在镜像集群模式下，你创建的 queue，无 论元数据还是 queue 里的消息都会存在于多个实例上，就是说，每个 RabbitMQ 节点都有这个 queue 的一个完整镜像，包含 queue 的全 部数据的意思。然后每次你写消息到 queue 的时候，都会自动把消息同步到多个实例的 queue 上。RabbitMQ 有很好的管理控制台，就是 在后台新增一个策略，这个策略是镜像集群模式的策略，指定的时候是可以要求数据同步到所有节点的，也可以要求同步到指定数量的节 点，再次创建 queue 的时候，应用这个策略，就会自动将数据同步到其他的节点上去了。这样的话，好处在于，你任何一个机器宕机了， 没事儿，其它机器（节点）还包含了这个 queue 的完整数据，别的 consumer 都可以到其它节点上去消费数据。坏处在于，第一，这个性 能开销也太大了吧，消息需要同步到所有机器上，导致网络带宽压力和消耗很重！RabbitMQ 一个 queue 的数据都是放在一个节点里的， 镜像集群下，也是每个节点都放这个 queue 的完整数据

## 25.**如何保证RabbitMQ不被重复消费？**

正常情况下，消费者在消费消息的时候，消费完毕后，会发送一个确认消息给消息队列，消息队列就知道该消息被消费了，就会将该消息从消息队列中删除；

但是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将消息分发给其他的消费者。

**解决思路：** 保证消息的唯一性，就算是多次传输，不要让消息的多次消费带来影响；保证消息等幂性； 比如：在写入消息队列的数据做唯一标识，消费消息时，根据唯一标识判断是否消费过；

## 26.**RabbitMQ 概念里的 channel、exchange 和 queue 是逻辑概念，还是对应着进程实体？分别起什么作用？**

**queue** 具有自己的 `erlang` 进程； **exchange** 内部实现为保存 `binding` 关系的查找表； **channel** 是实际进行路由工作的实体，即负责按照 routing_key 将 message 投递给 queue 。

由 AMQP 协议描述可知，`channel` 是真实 TCP 连接之上的`虚拟连接`，所有 AMQP 命令都是通过 channel 发送的，且每一个 channel 有`唯一的 ID`。一个 channel 只能被单独一个操作系统线程使用，故投递到特定 channel 上的 message 是有顺序的。但一个操作系统线程上允许使用多个 channel 。

## 27.**RabbitMQ消息是如何路由的？**

从概念上来说，消息路由必须有三部分：**交换器**、**路由**、**绑定**。

生产者把消息发布到交换器上；绑定决定了消息如何从路由器路由到特定的队列；消息最终到达队列，并被消费者接收。 消息发布到交换器时，消息将拥有一个`路由键（routing key）`，在消息创建时设定。 通过队列路由键，可以把队列绑定到交换器上。 消息到达交换器后，RabbitMQ会将消息的路由键与队列的路由键进行匹配（针对不同的交换器有不同的路由规则）。如果能够匹配到队列，则消息会投递到相应队列中；如果不能匹配到任何队列，消息将进入 “黑洞”。

常用的交换器主要分为一下三种：

- `direct`：如果路由键完全匹配，消息就被投递到相应的队列
- `fanout`：如果交换器收到消息，将会广播到所有绑定的队列上
- `topic`：可以使来自不同源头的消息能够到达同一个队列。使用topic交换器时，可以使用通配符，比如：`“*”` 匹配特定位置的任意文本， `“.”` 把路由键分为了几部分，`“#”` 匹配所有规则等。

> 特别注意：发往topic交换器的消息不能随意的设置选择键（routing_key），必须是由"."隔开的一系列的标识符组成。

## 28.**如何保证RabbitMQ消息的可靠传输？**

消息不可靠的情况可能是消息丢失，劫持等原因 丢失又分为：

- 生产者丢失消息
- 消息列表丢失消息
- 消费者丢失消息

**生产者丢失消息：** 从生产者弄丢数据这个角度来看，RabbitMQ提供`transaction机制`和`confirm模式`来确保生产者不丢消息；

- transaction机制：发送消息前，开启事务（channel.txSelect()），然后发送消息，如果发送过程中出现什么异常，事务就会回滚（channel.txRollback()），如果发送成功则提交事务（channel.txCommit()）。
- confirm模式（用的居多）：一旦channel进入confirm模式，所有在该信道上发布的消息都将会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后；RabbitMQ就会发送一个ACK给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了；

如果RabbitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作。

**消息队列丢数据：** 消息持久化，处理消息队列丢数据的情况，一般是开启持久化磁盘的配置： 将队列的持久化标识`durable`设置为`true`，则代表是一个持久的队列 发送消息的时候将 `deliveryMode=2` 这样设置以后，即使RabbitMQ挂了，重启后也能恢复数据

**消费者丢失消息：** 消费者丢数据一般是因为采用了自动确认消息模式，改为手动确认消息 消费者在收到消息之后，处理消息之前，会自动回复RabbitMQ已收到消息；如果这时处理消息失败，就会丢失该消息； 解决方案：处理消息成功后，手动回复确认消息。

## 29.**如何保证RabbitMQ消息的顺序性？**

1、`单线程`消费保证消息的顺序性； 2、对消息进行`编号`，消费者处理消息是根据编号处理消息；

## 30.**死信队列和延迟队如何使用?**

**死信队列：** 死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer将消息投递到broker或者直接到queue里了，consumer从queue取出消息进行消费，但某些时候由于特定的原因导致queue中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信，自然就有了死信队列；

**死信消息：** 1、消息被拒绝（`Basic.Reject`或`Basic.Nack`）并且设置 requeue 参数的值为 false 2、消息过期了 3、队列达到最大的长度

**过期消息：** 在 rabbitmq 中存在2种方可设置消息的过期时间，

- 第一种通过对队列进行设置，这种设置后，该队列中所有的消息都存在相同的过期时间，
- 第二种通过对消息本身进行设置，那么每条消息的过期时间都不一样。

如果同时使用这2种方法，那么以过期时间小的那个数值为准。当消息达到过期时间还没有被消费，那么那个消息就成为了一个 死信 消息。

队列设置：在队列申明的时候使用 `x-message-ttl` 参数，单位为 毫秒 单个消息设置：是设置消息属性的 `expiration` 参数的值，单位为 毫秒

**延时队列**：在rabbitmq中不存在延时队列，但是我们可以通过设置消息的过期时间和死信队列来模拟出延时队列。消费者监听死信交换器绑定的队列，而不要监听消息发送的队列。