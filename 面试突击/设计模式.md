# 设计模式

## 1.设计模式简介

设计模式是人们经过长期编程经验总结出来的一种编程思想。随着软件工程的不断演进，针对不同的需求，新的设计模式不断被提出（比如大数据领域中这些年不断被大家认可的数据分片思想），但设计模式的原则不会变。基于设计模式的原则，我们可以使用已有的设计模式，也可以根据产品或项目的开发需求在现有的设计模式基础上组合、改造或重新设计自身的设计模式。

设计模式有7个原则：单一职责原则、开闭原则、里氏代换原则、依赖倒转原则、接口隔离原则、合成/聚合复用原则、迪米特法则，接下来对这些原则一一进行讲解。

### 单一职责原则

单一职责原则又称单一功能原则，它规定一个类只有一个职责。如果有多个职责（功能）被设计在一个类中，这个类就违反了单一职责原则。

### 开闭原则

开闭原则规定软件中的对象（类、模块、函数等）对扩展开放，对修改封闭，这意味着一个实体允许在不改变其源代码的前提下改变其行为，该特性在产品化的环境下是特别有价值的，在这种环境下，改变源代码需要经过代码审查、单元测试等过程，以确保产品的使用质量。遵循这个原则的代码在扩展时并不发生改变，因此不需要经历上述过程。

### 里氏代换原则

里氏代换原则是对开闭原则的补充，规定了在任意父类可以出现的地方，子类都一定可以出现。实现开闭原则的关键就是抽象化，父类与子类的继承关系就是抽象化的具体表现，所以里氏代换原则是对实现抽象化的具体步骤的规范。

### 依赖倒转原则

依赖倒转原则指程序要依赖于抽象（Java中的抽象类和接口），而不依赖于具体的实现（Java中的实现类）。简单地说，就是要求对抽象进行编程，不要求对实现进行编程，这就降低了用户与实现模块之间的耦合度。

### 接口隔离原则

接口隔离原则指通过将不同的功能定义在不同的接口中来实现接口的隔离，这样就避免了其他类在依赖该接口（接口上定义的功能）时依赖其不需要的接口，可减少接口之间依赖的冗余性和复杂性。

### 合成/聚合复用原则

合成/聚合复用原则指通过在一个新的对象中引入（注入）已有的对象以达到类的功能复用和扩展的目的。它的设计原则是要尽量使用合成或聚合而不要使用继承来扩展类的功能。

### 迪米特法则

迪米特法则指一个对象尽可能少地与其他对象发生相互作用，即一个对象对其他对象应该有尽可能少的了解或依赖。其核心思想在于降低模块之间的耦合度，提高模块的内聚性。迪米特法则规定每个模块对其他模块都要有尽可能少的了解和依赖，因此很容易使系统模块之间功能独立，这使得各个模块的独立运行变得更简单，同时使得各个模块之间的组合变得更容易。

## 2.设计模式分类

设计模式按照其功能和使用场景可以分为三大类：创建型模式（Creational Pattern）、结构型模式（Structural Pattern）和行为型模式（Behavioral Pattern）。

- 创建型模式：提供了多种优雅创建对象的方法
  - 工作模式
  - 抽象工厂模式
  - 单例模式
  - 建造者模式
  - 原型模式
- 结构型模式：通过类和接口之间的继承和引用实现创建复杂结构对象的功能
  - 
- 行为型模式：通过类之间不同的通信方式实现不同的行为方式

## 3.工作模式

工厂模式（Factory Pattern）是最常见的设计模式，该模式设属于创建型模式，它提供了一种简单、快速、高效而安全地创建对象的方式。工厂模式在接口中定义了创建对象的方法，而将具体的创建对象的过程在子类中实现，用户只需通过接口创建需要的对象即可，不用关注对象的具体创建过程。同时，不同的子类可根据需求灵活实现创建对象的不同方法。

通俗地讲，工厂模式的本质就是用工厂方法代替new操作创建一种实例化对象的方式，以提供一种方便地创建有同种类型接口的产品的复杂对象。

如下代码通过new关键字实例化类Class的一个实例class，但如果Class类在实例化时需要一些初始化参数，而这些参数需要其他类的信息，则直接通过new关键字实例化对象会增加代码的耦合度，不利于维护，因此需要通过工厂模式将创建实例和使用实例分开。将创建实例化对象的过程封装到工厂方法中，我们在使用时直接通过调用工厂来获取，不需要关心具体的负载实现过程：

```html
Class class=new Class();
```

以创建手机为例，假设手机的品牌有华为和苹果两种类型，我们要实现的是根据不同的传入参数实例化不同的手机，其具体实现如下。

（1）定义接口：

```html
public interface Phone{
    String brand();
}
```

以上代码定义了一个Phone接口，并在接口中定义了brand()，用来返回手机的品牌。

（2）定义实现类：

```html
public class Iphone implements Phone{
    @Override
    public String brand(){
        return "this is a Apple phone";
    }
}
public class HuaWei implements Phone{
    @Override
    public String brand(){
        return "this is a huawei phone";
    }
}
```

以上代码定义了两个Phone的实现类Iphone和HuaWei来表示两个品牌的手机，两个品牌的手机通过实现brand()打印自己的商标。

（3）定义工厂类：

```html
public class Factory{
    public Phone createPhone(String phoneName){
        if("Huawei".equals(phoneName)){
            return new HuaWei();
        }else if("Apple".equals(phoneName)){
            return new Iphone();
        }else{
            return null;
        }
    }
}
```

以上代码定义了名为Factory的工厂类，工厂类有一个方法createPhone()，用来根据不同的参数实例化不同品牌的手机类并返回。在createPhone()的参数为“HuaWei”时，工厂类为我们实例化一个HuaWei类的实例并返回；在createPhone()的参数为“Apple”时，工厂类为我们实例化一个Iphone类的实例并返回。这样便实现了工厂类根据不同的参数创建不同的实例，对调用者来说屏蔽了实例化的细节。

（4）使用工厂模式：

```html
public satic void main(String[] args){
    Factory factory=new Factory();
    Phone huawei=factory.createPhone("HuaWei");
    Phone iphone=factory.createPhone("Apple");
}
```

以上代码定义了一个Factory的实例，并调用createPhone()根据不同的参数创建了名为huawei的实例和名为iphone的实例，并分别调用其brand()打印不同的品牌信息。

## 4.抽象工厂模式

抽象工厂模式（Abstract Factory Pattern）在工厂模式上添加了一个创建不同工厂的抽象接口（抽象类或接口实现），该接口可叫作超级工厂。在使用过程中，我们首先通过抽象接口创建出不同的工厂对象，然后根据不同的工厂对象创建不同的对象。

我们可以将工厂模式理解为针对一个产品维度进行分类，比如上述工厂模式下的苹果手机和华为手机；而抽象工厂模式针对的是多个产品维度分类，比如苹果公司既制造苹果手机也制造苹果笔记本电脑，同样，华为公司既制造华为手机也制造华为笔记本电脑。

在同一个厂商有多个维度的产品时，如果使用工厂模式，则势必会存在多个独立的工厂，这样的话，设计和物理世界是不对应的。正确的做法是通过抽象工厂模式来实现，我们可以将抽象工厂类比成厂商（苹果、华为），将通过抽象工厂创建出来的工厂类比成不同产品的生产线（手机生成线、笔记本电脑生产线），在需要生产产品时根据抽象工厂生产。

工厂模式定义了工厂方法来实现不同厂商手机的制造。可是问题来了，我们知道苹果公司和华为公司不仅制造手机，还制造电脑。如果使用工厂模式，就需要实现两个工厂类，并且这两个工厂类没有多大关系，这样的设计显然不够优雅，那么如何实现呢？使用抽象工厂就能很好地解决上述问题。我们定义一个抽象工厂，在抽象工厂中定义好要生产的产品（手机或者电脑），然后在抽象工厂的实现类中根据不同类型的产品和产品规格生产不同的产品返回给用户。

（1）第1类产品的手机接口及实现类的定义如下：

```html
public interface Phone{
    String call();
}
public class PhoneApple implements Phone{
    @Override
    public String call(){
        return "call somebody by apple phone";
    }
}
public class PhoneHuaWei implements Phone{
    @Override
    public String call(){
        return "call somebody by huawei phone";
    }
}
```

以上代码定义了Phone的接口及其实现类PhoneApple和PhoneHwaiWei。在该接口中定义了一个打电话的方法call()，实现类根据其品牌打印相关信息。

（2）第1类产品的手机工厂类的定义如下：

```html
public class PhoneFactory extends AbstractFactory{
    @override
    public Phone createPhone(String brand){
        if("Huawei".equals(brand)){
            return new PhoneHuaWei();
        }else if("Apple".equals(brand)){
            return new PhoneApple();
        }else{
            return null;
        }
    }
    @override
    public Computer createComputer(String brand){
        return null;
    }
}
```

以上代码定义了PhoneFactory的手机工厂类，该类继承了AbstractFactory并实现了方法createPhone()，createPhone()根据不同的参数实例化不同品牌的手机类并返回。在createPhone()的参数为“HuaWei”时，工厂类为我们实例化一个PhoneHwaiWei类的实例并返回；在createPhone()的参数为“Apple”时，工厂类为我们实例化一个PhoneApple类的实例并返回，这样便满足了工厂根据不同参数生产不同产品的需求。

（3）第2类产品的电脑接口及实现类的定义如下：

```html
public interface Computer{
    String internet();
}
public class ComputerApple implements Computer{
    @Override
    public String internet(){
        return "surf the internet by apple computer";
    }
}
public class ComputerHuaWei implements Computer{
    @Override
    public String internet(){
        return "surf the internet by huawei computer";
    }
}
```

以上代码定义了Computer的电脑接口及其实现类ComputerApple和ComputerHwaiWei。在该接口中定义了一个上网的方法internet()，实现类根据其品牌打印相关信息。

（4）第2类产品的电脑工厂类的定义如下：

```html
public class ComputerFactory extends AbstractFactory{
    @Override
    public Phone createPhone(String brand){
        return null;
    }
    @Override
    public Computer createComputer(String brand){
        if("Huawei".equals(brand)){
            return new ComputerHuaWei();
        }else if("Apple".equals(brand)){
            return new ComputerApple();
        }else{
            return null;
        }
    }
    
}
```

以上代码定义了ComputerFactory的电脑工厂类，该类继承了AbstractFactory并实现了方法createComputer()，createComputer()根据不同的参数实例化不同品牌的电脑类并返回。在createComputer()的参数为“HuaWei”时，工厂类为我们实例化一个ComputerHwaiWei类的实例并返回；在createComputer()的参数为“Apple”时，工厂类为我们实例化一个ComputerApple类的实例并返回，这样便实现了工厂根据不同参数生产不同产品的需求。

（5）抽象工厂的定义如下：

```html
public abstract class AbstractFactory{
    public abstract Phone createPhone(String brand);
    public abstract Computer createComputer(String brand);
}
```

以上代码定义了抽象类AbstractFactory，这个类便是抽象工厂的核心类，它定义了两个方法createPhone()和createComputer()，用户在需要手机时调用其createPhone()构造一个手机（华为或者苹果品牌）即可，用户在需要电脑时调用其createComputer()构造一个电脑（华为或者苹果品牌）即可。

（6）使用抽象工厂：

```html
AbstractFactory phoneFactory=new AbstractFactory();
Phone phoneHuawei=phoneFactory.createPhone("HuaWei");
Phone phoneApple=phoneFactory.createPhone("Apple");
AbstractFactory computerFactory=new ComputerFactory();
Computer computerHuawei=computerFactory.createComputer("HuaWei");
Computer computerApple=computerFactory.createComputer("Apple");
```

以上代码使用了我们定义好的抽象工厂，在需要生产产品时，首先需要定义一个抽象的工厂类AbstractFactory，然后使用抽象的工厂类生产不同的工厂类，最终根据不同的工厂生产不同的产品。

## 5.单例模式

单例模式是保证系统实例唯一性的重要手段。单例模式首先通过将类的实例化方法私有化来防止程序通过其他方式创建该类的实例，然后通过提供一个全局唯一获取该类实例的方法帮助用户获取类的实例，用户只需也只能通过调用该方法获取类的实例。

单例模式的设计保证了一个类在整个系统中同一时刻只有一个实例存在，主要被用于一个全局类的对象在多个地方被使用并且对象的状态是全局变化的场景下。同时，单例模式为系统资源的优化提供了很好的思路，频繁创建和销毁对象都会增加系统的资源消耗，而单例模式保障了整个系统只有一个对象能被使用，很好地节约了资源。

单例模式的实现很简单，每次在获取对象前都先判断系统是否已经有这个单例对象，有则返回，没有则创建。需要注意的是，单例模型的类构造函数是私有的，只能由自身创建和销毁对象，不允许除了该类的其他程序使用new关键字创建对象及破坏单例模式。

单例模式的常见写法有懒汉模式（线程安全）、饿汉模式、静态内部类、双重校验锁.

### 1.懒汉模式（线程不安全）

```html
public class LazySingleton{
    private static LazySingleton instance;
    private LazySingleton(){}
    public static LazySingleton getInstance(){
        if(instance==null){
            instance=new LazySingleton();
        }
        return instance;
    }
}
```

### 2.懒汉模式（线程安全，同步方法）

懒汉模式很简单：定义一个私有的静态对象instance，之所以定义instance为静态，是因为静态属性或方法是属于类的，能够很好地保障单例对象的唯一性；然后定义一个加锁的静态方法获取该对象，如果该对象为null，则定义一个对象实例并将其赋值给instance，这样下次再获取该对象时便能够直接获取了。

懒汉模式在获取对象实例时做了加锁操作，因此是线程安全的，代码如下：

```html
public class LazySingleton{
    private static LazySingleton instance;
    private LazySingleton(){}
    public static synchronized LazySingleton getInstance(){
        if(instance==null){
            instance=new LazySingleton();
        }
        return instance;
    }
}
```

### 3.懒汉模式（线程安全，同步代码块）

```html
public class LazySingleton{
    private static LazySingleton instance;
    private LazySingleton(){}
    public static LazySingleton getInstance(){
        if(instance==null){
            synchronized(LazySingleton.class){
                instance=new LazySingleton();
            }
        }
        return instance;
    }
}
```

### 4.饿汉模式（静态常量）

饿汉模式指在类中直接定义全局的静态对象的实例并初始化，然后提供一个方法获取该实例对象。懒汉模式和饿汉模式的最大不同在于，懒汉模式在类中定义了单例但是并未实例化，实例化的过程是在获取单例对象的方法中实现的，也就是说，在第一次调用懒汉模式时，该对象一定为空，然后去实例化对象并赋值，这样下次就能直接获取对象了；而饿汉模式是在定义单例对象的同时将其实例化的，直接使用便可。也就是说，在饿汉模式下，在Class Loader完成后该类的实例便已经存在于JVM中了，代码如下：

```html
public class HungrySingleton{
    private static HungrySingleton instance=new HungrySingleton();
    private HungrySingleton(){}
    public static HungrySingleton getInstance(){
        return instance;
    }
}
```

### 5.饿汉模式（静态代码块）

```html
public class HungrySingleton{
    private static HungrySingleton instance;
    private HungrySingleton(){}
    static{
        instance=new HungrySingleton();
    }
    public static HungrySingleton getInstance(){
        return instance;
    }
}
```

### 6.静态内部类

静态内部类通过在类中定义一个静态内部类，将对象实例的定义和初始化放在内部类中完成，我们在获取对象时要通过静态内部类调用其单例对象。之所以这样设计，是因为类的静态内部类在JVM中是唯一的，这很好地保障了单例对象的唯一性，代码如下：

```html
public class Singleton{
    private static class SingletonHolder{
        private static final Singleton INSTANCE=new Singleton();
    }
    private Singleton(){
    }
    private static final Singleton getInstance(){
        return SingletonHolder.INSTANCE;
    }   
}
```

### 7.双重校验锁

双锁模式指在懒汉模式的基础上做进一步优化，给静态对象的定义加上volatile锁来保障初始化时对象的唯一性，在获取对象时通过synchronized (Singleton.class)给单例类加锁来保障操作的唯一性。代码如下：

```html
public class Lock2Singleton{
    private volatile static Lock2Singleton singleton;//对象锁
    private Lock2Singleton(){}
    public static Lock2Singleton getSingleton(){
        if(singleton==null){
            synchronized(Singleton.class){//synchronized方法锁
                if(singleton==null){
                    singleton=new Lock2Singleton();
                }
            }
        }
        return singleton;
    }
}
```

### 8.枚举

```html
enum Singleton{
    INSTANCE;
    public void sayOK(){
        System.out.println("ok");
    }
}
```



## 6.建造者模式

建造者模式（Builder Pattern）使用多个简单的对象创建一个复杂的对象，用于将一个复杂的构建与其表示分离，使得同样的构建过程可以创建不同的表示，然后通过一个Builder类（该Builder类是独立于其他对象的）创建最终的对象。

建造者模式主要用于解决软件系统中复杂对象的创建问题，比如有些复杂对象的创建需要通过各部分的子对象用一定的算法构成，在需求变化时这些复杂对象将面临很大的改变，这十分不利于系统的稳定。但是，使用建造者模式能将它们各部分的算法包装起来，在需求变化后只需调整各个算法的组合方式和顺序，能极大提高系统的稳定性。建造者模式常被用于一些基本部件不会变而其组合经常变化的应用场景下。

注意，建造者模式与工厂模式的最大区别是，建造者模式更关注产品的组合方式和装配顺序，而工厂模式关注产品的生产本身。

建造者模式在设计时有以下几种角色。

- Builder：创建一个复杂产品对象的抽象接口。
- ConcreteBuilder：Builder接口的实现类，用于定义复杂产品各个部件的装配流程。
- Director：构造一个使用Builder接口的对象。
- Product：表示被构造的复杂对象。ConcreteBuilder定义了该复杂对象的装配流程，而Product定义了该复杂对象的结构和内部表示。

以生产一个电脑为例，电脑的生产包括CPU、Memory、Disk等生产过程，这些生产过程对顺序不敏感，这里的Product角色就是电脑。我们还需要定义生产电脑的Builder、ConcreteBuilder和Director。

具体实现如下。

（1）定义需要生产的产品Computer：

```html
public class Computer{
    private String cpu;
    private String memory;
    private String disk;
}
```

以上代码定义了一个Computer类来描述我们要生产的产品，具体的一个Computer包括CPU、内存（memory）和磁盘（disk），当然，还包括显示器、键鼠等.

（2）定义抽象接口ComputerBuilder来描述产品构造和装配的过程：

```html
public interface ComputerBuilder{
    void buildCpu();
    void buildMemory();
    void buildDisk();
    Computer buildComputer();
}
```

以上代码定义了ComputerBuilder接口来描述电脑的组装过程，具体包括组装CPU的方法buildcpu()、组装内存的方法buildemory()和组装磁盘的方法buildDisk()，等这些都生产和组装完成后，就可以调用buildComputer()组装一台完整的电脑了。

（3）定义ComputerBuilder接口实现类ComputerConcreteBuilder以实现构造和装配该产品的各个组件：

```html
public class ComputerConcreteBuilder implements ComputerBuilder{
    Computer computer;
    public ComputerConcreteBuilder(){
        computer=new Computer();
    }
    @Override
    public void buildCpu(){
        computer.setCpu("8core");
    }
    @Override
    public void buildMemory(){
        computer.setMemory("16G");
    }
    @Override
    public void buildDisk(){
        computer.setDisk("1TG");
    }
    @Override
    public Computer buildComputer(){
        return computer;
    }
}
```

以上代码定义了ComputerConcreteBuilder来完成具体电脑的组装，其中Computer的实例在构造函数中进行了定义。

（4）定义ComputerDirector使用Builder接口实现产品的装配：

```html
public class ComputerDirector{
    public Computer constructComputer(ComputerBuilder computerBuilder){
        computerBuilder.buildCpu();
        computerBuilder.buildMemory();
        computerBuilder.buildDisk();
        return computerBuilder.buildComputer();
    }
}
```

以上代码定义了ComputerDirector来调用ComputerBuilder接口实现电脑的组装，具体组装顺序为buildemory、buildpu、buildDisk和buildComputer。该类是建造者模式对产品生产过程的封装，在需求发生变化且需要先装配完磁盘再装配CPU时，只需调整Director的执行顺序即可，每个组件的装配都稳定不变。

（5）构建Computer：

```html
public static void main(String[] args){
    ComputerDirector computerDirector=new ComputerDirector();
    ComputerBuilder computerConcreteBuilder=new ComputerConcreteBuilder();
    Computer computer=computerDirector.constructComputer(computerConcreteBuilder);
}
```

以上代码首先定义了一个ComputerDirector和ComputerBuilder，为构建Computer做好准备，然后通过调用ComputerDirector的constructComputer()实现产品Computer的构建。

## 7.原型模式

原型模式指通过调用原型实例的Clone方法或其他手段来创建对象。

原型模式属于创建型设计模式，它以当前对象为原型（蓝本）来创建另一个新的对象，而无须知道创建的细节。原型模式在Java中通常使用Clone技术实现，在JavaScript中通常使用对象的原型属性实现。

原型模式的Java实现很简单，只需原型类实现Cloneable接口并覆写clone方法即可。Java中的复制分为浅复制和深复制。

- 浅复制：Java中的浅复制是通过实现Cloneable接口并覆写其Clone方法实现的。在浅复制的过程中，对象的基本数据类型的变量值会重新被复制和创建，而引用数据类型仍指向原对象的引用。也就是说，浅复制不复制对象的引用类型数据。
- 深复制：在深复制的过程中，不论是基本数据类型还是引用数据类型，都会被重新复制和创建。简而言之，深复制彻底复制了对象的数据（包括基本数据类型和引用数据类型），浅复制的复制却并不彻底（忽略了引用数据类型）。

（1）浅复制的代码实现如下：

```html
public class Computer implements Cloneable{
    private String cpu;
    private String memory;
    private String disk;
    public Computer(String cpu,String memory,String disk){
        this.cpu=cpu;
        this.memory=memory;
        this.disk=disk;
    }
    public Object clone(){//浅复制
        try{
            return (Computer)super.clone();
        }catch(Exception e){
            e.printStackTrace();
            return null;
        }
    }
}
```

以上代码定义了Computer类，要使该类支持浅复制，只需实现Cloneable接口并覆写clone()即可。

（2）深复制的代码实现如下：

```html
public class ComputerDetail implements Cloneable{
    private String cpu;
    private String memory;
    private Disk disk;
    public ComputerDetail(String cpu,String memory,Disk disk){
        this.cpu=cpu;
        this.memory=memory;
        this.disk=disk;
    }
    public Object clone(){//深复制
        try{
            ComputerDetail computerDetail=(ComputerDetail)super.clone();
            computerDetail.disk=(Disk)this.disk.clone();
            return computerDetail;
        }catch(Exception e){
            e.printStackTrace();
            return null;
        }
    }
}
//应用对象深复制
public class Disk implements Cloneable{
    private String ssd;
    private String hhd;
    public Disk(String ssd,String hhd){
        this.ssd=ssd;
        this.hhd=hhd;
    }
    public Object clone(){
        try{
            return (Disk)super.clone();
        }catch(Exception e){
            e.printStackTrace();
            return null;
        }
    }
}
```

以上代码定义了ComputerDetail和Disk两个类，其中ComputerDetail的disk属性是一个引用对象，要实现这种对象的复制，就要使用深复制技术，具体操作是引用对象类需要实现Cloneable接口并覆写clone()，然后在复杂对象中声明式地将引用对象复制出来赋值给引用对象的属性，具体代码如下：

```html
computerDetail.disk=(Disk)this.disk.clone();
```

（3）使用原型模型：

```html
public static void main(String[] args){
    //浅复制
    Computer computer=new Computer("8core","16G","1TB");
    Computer computerClone=(Computer)computer.clone();
    //深复制
    Disk disk=new Disk("208G","2TB");
    ComputerDetail computerDetail=new ComputerDetail("12core","64G",disk);
    ComputerDetail computerDetailClone=(ComputerDetail)computerDetail.clone();
}
```

以上代码先定义了一个简单对象computer，并利用浅复制技术复制出一个新的对象computerClone，然后定义了复制对象computerDetail，并使用深复制技术复制出一个新的对象computerDetailClone，最后分别打印出复制前和复制后的对象。

## 8.适配器模式

我们常常在开发中遇到各个系统之间的对接问题，然而每个系统的数据模型或多或少均存在差别，因此可能存在修改现有对象模型的情况，这将影响到系统的稳定。若想在不修改原有代码结构（类的结构）的情况下完成友好对接，就需要用到适配器模式。

适配器模式（Adapter Pattern）通过定义一个适配器类作为两个不兼容的接口之间的桥梁，将一个类的接口转换成用户期望的另一个接口，使得两个或多个原本不兼容的接口可以基于适配器类一起工作。

适配器模式主要通过适配器类实现各个接口之间的兼容，该类通过依赖注入或者继承实现各个接口的功能并对外统一提供服务。

在适配器模式的实现中有三种角色：Source、Targetable、Adapter。Source是待适配的类，Targetable是目标接口，Adapter是适配器。我们在具体应用中通过Adapter将Source的功能扩展到Targetable，以实现接口的兼容。适配器的实现主要分为三类：类适配器模式、对象适配器模式、接口适配器模式。

### 类适配器模式

在需要不改变（或者由于项目原因无法改变）原有接口或类结构的情况下扩展类的功能以适配不同的接口时，可以使用类的适配器模式。适配器模式通过创建一个继承原有类（需要扩展的类）并实现新接口的适配器类来实现。

具体实现如下。

（1）定义Source类：

```html
public class Source{
    private final static Log logger=LogFactory.getLog(Source.class);
    public void editTextFile(){//text文件编辑
    }
}
```

以上代码定义了待适配的Source类，在该类中实现了一个编辑文本文件的方法editTextFile()。

（2）定义Targetable接口：

```html
public interface Targetable{
    void editTextFile();
    void editWordFile();
}
```

以上代码定义了一个Targetable接口，在该接口中定义了两个方法，editTextFile和editWordFile，其中editTextFile是Source中待适配的方法。（3）定义Adapter继承Source类并实现Targetable接口：

```html
public class Adapter extends Source implements Targetable{
    @Override
    public void editWordFile(){
    }
}
```

以上代码定义了一个Adapter类并继承了Source类实现Targetable接口，以完成对Source类的适配。适配后的类既可以编辑文本文件，也可以编辑Word文件。

（4）使用类的适配器：

```html
public static void main(String[] args){
    Targetable target=new Adapter();
    target.editTextFile();
    target.editWordFile();
}
```

在使用适配器时只需定义一个实现了Targetable接口的Adapter类并调用target中适配好的方法即可。从运行结果可以看出，我们的适配器不但实现了编辑Wo r d文件的功能，还实现了编辑文本文件的功能。

### 对象适配器模式

对象适配器模式的思路和类适配器模式基本相同，只是修改了Adapter类。Adapter不再继承Source类，而是持有Source类的实例，以解决兼容性问题。

具体实现如下。

（1）适配器类的定义如下：

```html
public class ObjectAdapter implements Targetable{
    private Source source;
    public ObjectAdapter(Source source){
        super();
        this.source=source;
    }
    @Override
    public void editTextFile(){
        this.source.editTextFile();
    }
    @Override
    public void editWordFile(){
    }
}
```

以上代码定义了一个名为ObjectAdapter的适配器，该适配器实现了Targetable接口并持有Source实例，在适配editTextFile()的方法时调用Source实例提供的方法即可。

（2）使用对象适配器模式：

```html
Source source=new Source();
Targetable target=new ObjectAdapter(source);
target.editTextFile();
target.editWordFile();
```

在使用对象适配器时首先需要定义一个Source实例，然后在初始化ObjectAdapter时将Source实例作为构造函数的参数传递进去，这样就实现了对象的适配。

### 接口适配器模式

在不希望实现一个接口中所有的方法时，可以创建一个抽象类AbstractAdapter实现所有方法，在使用时继承该抽象类按需实现方法即可。

具体实现如下。

（1）定义公共接口Sourceable：

```html
public interface Sourceable{
    void editTextFile();
    void editWordFile();
}
```

以上代码定义了Sourceable接口，并在接口中定义了两个方法，editTextFile()和editWordFile()。

（2）定义抽象类AbstractAdapter并实现公共接口的方法：

```html
public abstract class AbstractAdapter implements Sourceable{
    @Override
    public void editTextFile(){
    }
    @Override
    public void editWordFile(){
    }
}
```

以上代码定义了Sourceable的抽象实现类AbstractAdapter，该类对Sourceable进行了重写，但是不做具体实现。

（3）定义SourceSub1类按照需求实现editTextFile()：

```html
public class SourceSub1 extends AbstractAdapter{
    @Override
    public void editTextFile(){
    }
}
```

以上代码定义了SourceSub1类并继承了AbstractAdapter，由于继承父类的子类可以按需实现自己关心的方法，因此适配起来更加灵活，这里SourceSub1类实现了editTextFile()。

（4）定义SourceSub2类按照需求实现editWordFile()：

```html
public class SourceSub2 extends AbstractAdapter{
    @Override
    public void editWordFile(){
    }
}
```

以上代码定义了SourceSub2类，继承了AbstractAdapter并实现了editWordFile()。

（5）使用接口适配器：

```html
public static void main(String[] args){
    Sourceable source1=new SourceSub1();
    Sourceable source2=new SourceSub2();
    source1.editTextFile();
    source2.editWordFile();
}
```

使用接口适配器时按照需求实例化不同的子类并调用实现好的方法即可。

## 9.装饰者模式

装饰者模式（Decorator Pattern）指在无须改变原有类及类的继承关系的情况下，动态扩展一个类的功能。它通过装饰者来包裹真实的对象，并动态地向对象添加或者撤销功能。

态地向对象添加或者撤销功能。装饰者模式包括Source和Decorator两种角色，Source是被装饰者，Decorator是装饰者。装饰者模式通过装饰者可以为被装饰者Source动态添加一些功能。

具体实现如下。

（1）定义Sourceable接口：

```html
public interface Sourceable{
    public void createComputer();
}
```

以上代码定义了一个Sourceable接口，该接口定义了一个生产电脑的方法createComputer()。

（2）定义Sourceable接口的实现类Source：

```html
public class Source implements Sourceable{
    @Override
    public void createComputer(){
    }
}
```

以上代码定义了Sourceable接口的实现类Source并实现了其createComputer()。

（3）定义装饰者类Decorator：

```html
public class Decorator implements Sourceable{
    private Sourceable source;
    public Decorator(Sourceable source){
        super();
        this.source=source;
    }
    @Override
    public void createComputer(){
        source.createComputer();
        this.source=source;
    }
}
```

以上代码定义了装饰者类Decorator，装饰者类通过构造函数将Sourceable实例初始化到内部，并在其方法createComputer()中调用原方法后加上了装饰者逻辑，这里的装饰指在电脑创建完成后给电脑装上相应的系统。注意，之前的Sourceable没有给电脑安装系统的步骤，我们引入装饰者为Sourceable扩展了安装系统的功能。

（4）使用装饰者模式：

```html
public static void main(String[] args){
    Sourceable source=new Source();
    Sourceable obj=new Decorator(source);
    obj.createComputer();
}
```

在使用装饰者模式时，需要先定义一个待装饰的Source类的source对象，然后初始化构造器Decorator并在构造函数中传入source对象，最后调用createComputer()，程序在创建完电脑后还为电脑安装了系统。

## 10.代理模式

代理模式指为对象提供一种通过代理的方式来访问并控制该对象行为的方法。在客户端不适合或者不能够直接引用一个对象时，可以通过该对象的代理对象来实现对该对象的访问，可以将该代理对象理解为客户端和目标对象之间的中介者。

在现实生活也能看到代理模式的身影，比如企业会把五险一金业务交给第三方人力资源公司去做，因为人力资源公司对这方面的业务更加熟悉，等等。

在代理模式下有两种角色，一种是被代理者，一种是代理（Proxy），在被代理者需要做一项工作时，不用自己做，而是交给代理做。比如企业在招人时，不用自己去市场上找，可以通过代理（猎头公司）去找，代理有候选人池，可根据企业的需求筛选出合适的候选人返回给企业。

具体实现如下。

（1）定义Company接口及其实现类HR：

```html
public interface Company{
    void findWorker(String title);
}
public class HR implements Company{
    @Override 
    public void findWorker(String title){
    }
}
```

以上代码定义了一个名为Company的接口，在该接口中定义了方法findWorker()，然后定义了其实现类HR，实现findWorker()以负责公司的具体招聘工作。

（2）定义Proxy：

```html
public class Proxy implements Company{
    private Hr hr;
    public Proxy(){
        super();
        this.hr=new HR();
    }
    @Override
    public void findWorker(String title){//需要代理的方法
        hr.findWorker(title);
        //通过猎头找候选人
        String worker=getWorker(title);
    }
    private String getWorker(String title){
        Map<String,String> workerList=new HashMap<String,String>(){
            {put("java","张三");put("php","王五"};
        };
        return workerList.get(title);
    }
}
```

以上代码定义了一个代理类Proxy，用来帮助企业寻找合适的候选人。其中Proxy继承了Company并持有HR对象，在其HR发出招人指令（findWorker）后，由代理完成具体的寻找候选人工作并将找到的候选人提供给公司。

（3）使用代理模式：

```html
public static void main(String[] args){
    Company company=new Proxy();
    company.findWorker("java");
}
```

在使用代理模式时直接定义一个代理对象并调用其代理的方法即可。

## 11.外观模式

外观模式（Facade Pattern）也叫作门面模式，通过一个门面（Facade）向客户端提供一个访问系统的统一接口，客户端无须关心和知晓系统内部各子模块（系统）之间的复杂关系，其主要目的是降低访问拥有多个子系统的复杂系统的难度，简化客户端与其之间的接口。外观模式将子系统中的功能抽象成一个统一的接口，客户端通过这个接口访问系统，使得系统使用起来更加容易。

简单来说，外观模式就是将多个子系统及其之间的复杂关系和调用流程封装到一个统一的接口或类中以对外提供服务。这种模式涉及3种角色。

- 子系统角色：实现了子系统的功能。
- 门面角色：外观模式的核心，熟悉各子系统的功能和调用关系并根据客户端的需求封装统一的方法来对外提供服务。
- 客户角色：通过调用Facade来完成业务功能。

以汽车的启动为例，用户只需按下启动按钮，后台就会自动完成引擎启动、仪表盘启动、车辆自检等过程。我们通过外观模式将汽车启动这一系列流程封装到启动按钮上，对于用户来说只需按下启动按钮即可，不用太关心具体的细节。

具体实现如下。

（1）定义Dashboard类：

```html
public class Dashboard{
    public void startup(){
    }
    public void shutdown(){
    }
}
```

以上代码定义了Dashboard类来代表仪表盘，并定义了startup()和shutdown()来控制仪表盘的启动和关闭。

（2）定义Engine类：

```html
public class Engine{
    public void startup(){
    }
    public void shutdown(){
    }
}
```

以上代码定义了Engine类来代表发动机，并定义了startup()和shutdown()来控制发动机的启动和关闭。

（3）定义SelfCheck类：

```html
public class SelfCheck{
    public void startupCheck(){
    }
    public void shutdownCheck(){
    }
}
```

以上代码定义了SelfCheck类来代表汽车自检器，并定义了startupCheck()和shutdowncheck()来控制汽车启动后的自检和关闭前的自检。

（4）定义门面类Starter：

```html
public class Starter{
    private Dashbooard dashboard;
    private Engine engine;
    private SelfCheck selfCheck;
    public Starter(){
        this.dashboard=new Dashbooard();
        this.engine=new Engine();
        this.selfCheck=new SelfCheck();
    }
    public void startup(){
        engine.startup();
        dashboard.startup();
        selfCheck.startup();
    }
    public void shutdown(){
        selfCheck.shutdownCheck();
        engine.shutdown();
        dashboard.shutdown();
    }
}
```

以上代码定义了门面类Starter，在Starter中定义了startup方法，该方法先调用engine的启动方法启动引擎，再调用dashboard的启动方法启动仪表盘，最后调用selfCheck的启动自检方法完成启动自检。

（5）使用外观模式：

```html
public static void main(String[] args){
    Starter starter=new Starter();
    starter.startup();
    starter.shutdown();
}
```

在使用外观模式时，用户只需定义门面类的实例并调用封装好的方法或接口即可。这里调用starter的startup()完成启动。

## 12.桥接模式

桥接模式（Bridge Pattern）通过将抽象及其实现解耦，使二者可以根据需求独立变化。这种类型的设计模式属于结构型模式，通过定义一个抽象和实现之间的桥接者来达到解耦的目的。

桥接模型主要用于解决在需求多变的情况下使用继承造成类爆炸的问题，扩展起来不够灵活。可以通过桥接模式将抽象部分与实现部分分离，使其能够独立变化而相互之间的功能不受影响。具体做法是通过定义一个桥接接口，使得实体类的功能独立于接口实现类，降低它们之间的耦合度。

我们常用的JDBC和DriverManager就使用了桥接模式，JDBC在连接数据库时，在各个数据库之间进行切换而不需要修改代码，因为JDBC提供了统一的接口，每个数据库都提供了各自的实现，通过一个叫作数据库驱动的程序来桥接即可。

具体实现如下。

（1）定义Driver接口：

```html
public interface Driver{
    void executeSQL();
}
```

以上代码定义了Driver接口，在该接口中定义了一个执行SQL语句的方法，用于处理不同数据库的SQL语句。

（2）定义Driver接口的MySQL实现类MysqlDriver：

```html
public class MysqlDriver implements Driver{
    @Override
    public void executeSQL{
    }
}
```

以上代码定义了Driver的实现类MysqlDriver，并基于MySQL实现了其执行SQL语句的方法。

（3）定义Driver接口的Oracle实现类OracleDriver：

```html
public class OracleDriver implements Driver{
    @Override
    public void executeSQL{
    }
}
```

以上代码定义了Driver的实现类OracleDriver，并基于Oracle实现了其执行SQL语句的方法。

（4）定义DriverManagerBridge：

```html
public abstract class DriverManagerBridge{
    private Driver driver;
    public void execute(){
        this.driver.executeSQL();
    }
    public Driver getDriver(){
        return driver;
    }
    public void setDriver()(Driver driver){
        this.driver=driver;
    }
}
```

以上代码定义了抽象类DriverManagerBridge，用于实现桥接模式，该类定义了Driver的注入，用户注入不同的驱动器便能实现不同类型的数据库的切换。（5）定义MyDriverBridge：

```html
public class MyDriverBridge extends DriverManagerBridge{
    public void execute(){
        getDriver().executeSQL();
    }
}
```

在以上代码中，MyDriverBridge用于实现用户自定义的功能，也可以直接使用DriverManagerBridge提供的功能。

（6）使用桥接模式：

```html
public static void main(String[] args){
    DriverManagerBridge driverManagerBridge=new MyDriverBridge();
    //设置mysql驱动
    driverManagerBridge.setDriver(new MysqlDriver());
    driverManagerBridge.execute();
    //设置Oracle驱动
    driverManagerBridge.setDriver(new OracleDriver());
    driverManagerBridge.execute();
}
```

## 13.组合模式

组合模式（Composite Pattern）又叫作部分整体模式，主要用于实现部分和整体操作的一致性。组合模式常根据树形结构来表示部分及整体之间的关系，使得用户对单个对象和组合对象的操作具有一致性。

组合模式通过特定的数据结构简化了部分和整体之间的关系，使得客户端可以像处理单个元素一样来处理整体的数据集，而无须关心单个元素和整体数据集之间的内部复杂结构。

组合模式以类似树形结构的方式实现整体和部分之间关系的组合。下面以实现一个简单的树为例介绍组合模式。

具体实现如下。

（1）定义TreeNode：

```html
public class TreeNode{
    private String name;
    private TreeNode parent;
    private Vector<TreeNode> childrer=new Vector<TreeNode>();
    public TreeNode(String name){
        this.name=name;
    }
    //添加子节点
    public void add(TreeNode node){
        childrer.add(node);
    }
    //删除子节点
    public void remove(TreeNode node){
        childrer.remove(node);
    }
    //获取子节点
    public Enumeration<TreeNode> getChildren(){
        return childrer.elements();
    }
}
```

以上代码定义了TreeNode类来表示一个树形结构，并定义了children来存储子类，定义了方法add()和remove()来向树中添加数据和从树中删除数据。（2）使用TreeNode：

```html
public static void main(String[] args){
    TreeNode nodeA=new TreeNode("A");
    TreeNode nodeB=new TreeNode("B");
    nodeA.add(nodeB);
}
```

以上代码演示了TreeNode的使用过程，定义了nodeA和nodeB，并将nodeB作为nodeA的子类。

从以上代码中可以看到一棵包含了nodeA和nodeB的树，其中nodeB为nodeA的子节点。

## 14.享元模式

享元模式（Flyweight Pattern）主要通过对象的复用来减少对象创建的次数和数量，以减少系统内存的使用和降低系统的负载。享元模式属于结构型模式，在系统需要一个对象时享元模式首先在系统中查找并尝试重用现有的对象，如果未找到匹配的对象，则创建新对象并将其缓存在系统中以便下次使用。

享元模式主要用于避免在有大量对象时频繁创建和销毁对象造成系统资源的浪费，把其中共同的部分抽象出来，如果有相同的业务请求，则直接返回内存中已有的对象，避免重新创建。

下面以内存的申请和使用为例介绍享元模式的使用方法，创建一个MemoryFactory作为内存管理的工厂，用户通过工厂获取内存，在系统内存池有可用内存时直接获取该内存，如果没有则创建一个内存对象放入内存池，等下次有相同的内存请求过来时直接将该内存分配给用户即可。

具体实现如下。

（1）定义Memory：

```html
public class Memory{
    private int size;//内存单位，单位为MB
    private boolean isused;//内存是否被使用
    private String id;//内存id
}
```

（2）定义MemoryFactory工厂：

```html
public class MemoryFactory{
    //内存对象列表
    private static List<Memory> memoryList=new ArrayList<Memory>();
    public static Memory getMemory(int size){
        Memory memory=null;
        for(int i=0;i<memoryList.size();i++){
            memory=memoryList.get(i);
            //如果存在和需求size一样大小并且未使用的内存块，则直接返回
            if(memory.getSize()==size&&memory.isIsused()==false){
                memory.setIsused(true);
                memoryList.set(i,memory);
                break;
            }
        }
        //如果内存不存在，则从系统中申请新的内存返回，并将该内存加入内存对象列表中
        if(memory==null){
            memory=new Memory(32,false,UUID.randomUUID().toString());
            memoryList.add(memory);
        }
        return memory;  
    }
    public static void releaseMemory(String id){
        for(int i=0;i<memoryList.size();i++){
            Memory memory=memoryList.get(i);
            //如果存在和需求size一样大小并且未使用的内存块，则直接返回
            if(memory.getId().equals(id)){
                memory.setIsused(false);
                memoryList.set(i,memory);
                break;
            }
        }
    }
}
```

以上代码定义了工厂类MemoryFactory，在该类中定义了memoryList用于存储从系统中申请到的内存，该类定义了getMemory，用于从memoryList列表中获取内存，如果在内存中有空闲的内存，则直接取出来返回，并将该内存的使用状态设置为已使用，如果没有，则创建内存并放入内存列表；还定义了releaseMemory来释放内存，具体做法是将内存的使用状态设置为false。（3）使用享元模式：

```html
public static void main(String[] args){
    //首次获取内存，将创建一个内存
    Memory memory=MemoryFactory.getMemory(32);
    //在使用后是否内存
    MemoryFactory.releaseMemory(memory.getId());
    //重新获取内存
    MemoryFactory.getMemory(32);
}
```

在使用享元模式时，直接从工厂类MemoryFactory中获取需要的数据Memory，在使用完成后释放即可。

## 15.策略模式

策略模式（Strategy Pattern）为同一个行为定义了不同的策略，并为每种策略都实现了不同的方法。在用户使用的时候，系统根据不同的策略自动切换不同的方法来实现策略的改变。同一个策略下的不同方法是对同一功能的不同实现，因此在使用时可以相互替换而不影响用户的使用。

策略模式的实现是在接口中定义不同的策略，在实现类中完成了对不同策略下具体行为的实现，并将用户的策略状态存储在上下文（Context）中来完成策略的存储和状态的改变。

我们在现实生活中常常碰到实现目标有多种可选策略的情况，比如下班后可以通过开车、坐公交、坐地铁、骑自行回家，在旅行时可以选择火车、飞机、汽车等交通工具，在淘宝上购买指定商品时可以选择直接减免部分钱、送赠品、送积分等方式。

对于上述情况，使用多重if ...else条件转移语句也可实现，但属于硬编码方式，这样做不但会使代码复杂、难懂，而且在增加、删除、更换算法时都需要修改源代码，不易维护，违背了开闭原则。通过策略模式就能优雅地解决这些问题。

具体实现如下。

（1）定义TravelStrategy：

```html
public interface TravelStrategy{
    void travelMode();
}
```

以上代码定义了策略模式接口TravelStrategy，并在该接口中定义了方法travelMode()来表示出行方式。

（2）定义TravelStrategy的两种实现方式TravelByAirStrategy和TravelByCarStrategy：

```html
public class TravelByAirStrategy implements TravelStrategy{
    @Override
    public void travelMode(){}
}
public class TravelByCarStrategy implements TravelStrategy{
    @Override
    public void travelMode(){}
}
```

以上代码定义了TravelStrategy的两个实现类TravelByAirStrategy和TravelByCarStrategy，分别表示基于飞机的出行方式和基于开车自驾的出行方式，并实现了方法travelMode()。

（3）定义Context实现策略模式：

```html
public class Context{
    private TravelStrategy travelStrategy;
    public TravelStrategy getTravelStrategy(){
        return travelStrategy;
    }
    public void setTravelStrategy(TravelStrategy travelStrategy){
        this.travelStrategy=travelStrategy;
    }
    public void travelMode(){
        this.travelStrategy.travelMode();
    }
}
```

以上代码定义了策略模式实现的核心类Context，在该类中持有TravelStrategy实例并通过setTravelStrategy()实现了不同策略的切换。

（4）使用策略模式：

```html
public static void main(String[] args){
    Context context=new Context();
    TravelStrategy travelByAirStrategy=new TravelByAirStrategy();
    //设置出现策略为飞机
    context.setTravelStrategy(travelByAirStrategy);
    context.travelMode();
    //设置出现策略为汽车
    TravelStrategy travelByCarStrategy=new TravelByCarStrategy();
    context.setTravelStrategy(travelByCarStrategy);
    context.travelMode();
}
```

在使用策略模式时，首先需要定义一个Context，然后定义不同的策略实现并将其注入Context中实现不同策略的切换。

## 16.模板模式

模板方法（Template Method）模式定义了一个算法框架，并通过继承的方式将算法的实现延迟到子类中，使得子类可以在不改变算法框架及其流程的前提下重新定义该算法在某些特定环节的实现，是一种类行为型模式。

该模式在抽象类中定义了算法的结构并实现了公共部分算法，在子类中实现可变的部分并根据不同的业务需求实现不同的扩展。模板方法模式的优点在于其在父类（抽象类）中定义了算法的框架以保障算法的稳定性，同时在父类中实现了算法公共部分的方法来保障代码的复用；将部分算法部分延迟到子类中实现，因此子类可以通过继承的方式来扩展或重新定义算法的功能而不影响算法的稳定性，符合开闭原则。

模板方法模式需要注意抽象类与具体子类之间的协作，在具体使用时包含以下主要角色。

- 抽象类（Abstract Class）：定义了算法的框架，由基本方法和模板方法组成。基本方法定义了算法有哪些环节，模板方法定义了算法各个环节执行的流程。
- 具体子类（Concrete Class）：对在抽象类中定义的算法根据需求进行不同的实现。

下面以银行办理业务为例实现一个模板方法模式，我们去银行办理业务都要经过抽号、排队、办理业务和评价，其中的业务流程是固定的，但办理的具体业务比较多，比如取钱、存钱、开卡等。其中，办理业务的固定流程就是模板算法中的框架，它常常是不变的，由抽象类定义和实现，而具体办理的业务是可变的部分，通常交给子类去做具体的实现。

具体实现如下。

（1）定义AbstractTemplate模板类：

```html
public abstract class AbstractTemplate{
    public void templateMethod(){
        checkNumber();
        queueUp();
        handleBusiness();
        serviceEvaluation();
    }
    public void checkNumber(){//抽号
    }
    public void queueUp(){//排队
    }
    public abstrart void handleBusiness(){//业务办理
    }
    public void serviceEvaluation(){//服务评价
    }
}
```

以上代码定义了抽象类AbstractTemplate，用于实现模板方法模式，其中定义了checkNumber()表示抽号过程，queueUp()表示排队过程，handleBusiness()表示需要办理的具体业务，serviceEvaluation()表示在业务办理完成后对服务的评价，templateMethod()定义了银行办理业务的核心流程，即取号、排队、办理业务和评价。抽象类实现了取号、排队、办理业务这些公共方法，而将办理业务的具体方法交给具体的业务类实现。

（2）定义SaveMoney的业务实现：

```html
public class SaveMoney extends AbstractTemplate{
    @Override
    public void handleBusiness(){
    }
}
```

以上代码定义了SaveMoney并实现了handleBusiness()，以完成存钱的业务逻辑。

（3）定义TakeMoney的业务实现：

```html
public class TakeMoney extends AbstractTemplate{
    @Override
    public void handleBusiness(){
    }
}
```

以上代码定义了TakeMoney并实现了handleBusiness()，以完成取钱的业务逻辑。

（4）使用模板模式：

```html
public static void main(String[] args){
    //办理取钱流程
    AbstractTemplate template1=new TakeMoney();
    template1.templateMethod();
    //办理存储流程
    AbstractTemplate template2=new TakeMoney();
    template1.templateMethod();
}
```

在使用模板模式时只需按照需求定义具体的模板类实例并调用其模板方法即可。

## 17.观察者模式

观察者（Observer）模式指在被观察者的状态发生变化时，系统基于事件驱动理论将其状态通知到订阅其状态的观察者对象中，以完成状态的修改和事件传播。这种模式有时又叫作发布-订阅模式或者模型-视图模式。

观察者模式是一种对象行为型模式，观察者和被观察者之间的关系属于抽象耦合关系，主要优点是在观察者与被观察者之间建立了一套事件触发机制，以降低二者之间的耦合度。

观察者模式的主要角色如下。

- 抽象主题（Subject）：持有订阅了该主题的观察者对象的集合，同时提供了增加、删除观察者对象的方法和主题状态发生变化后的通知方法。
- 具体主题（Concrete Subject）：实现了抽象主题的通知方法，在主题的内部状态发生变化时，调用该方法通知订阅了主题状态的观察者对象。
- 抽象观察者（Observer）：观察者的抽象类或接口，定义了主题状态发生变化时需要调用的方法。
- 具体观察者（Concrete Observer）：抽象观察者的实现类，在收到主题状态变化的信息后执行具体的触发机制。

具体实现如下。

（1）定义抽象主题Subject：

```html
//抽象目标类
public abstract class Subject{
    protected List<Observer> observers=new ArrayList<Observer>();
    //增加观察者
    public void add(Observer observer){
        observers.add(observer);
    }
    //删除观察者
    public void remove(Observer observer){
        observers.remove(observer);
    }
    public abstract void notifyObserver(String message);//通知观察者的抽象方法
}
```

以上代码定义了抽象主题Subject类，并定义和实现了方法add()、remove()来向Subject添加观察者和删除观察者，定义了抽象方法notifyObserver()来实现在消息发生变化时将变化后的消息发送给观察者。

（2）定义具体的主题ConcreteSubject：

```html
public class ConcreteSubject extends Subject{
    public void notifyObserver(String message){
        for(Object obs:observers){
            ((Observer)obs).dataChange(message);
        }
    }
}
```

以上代码定义了ConcreteSubject类，该类继承了Subject并实现了notifyObserver()，用于向观察者发送消息。

（3）定义抽象观察者Observer：

```html
public interface Observer{
    void dataChange(String message);//接收数据
}
```

以上代码定义了观察者Observer接口并定义了messageReceive()，用于接收ConcreteSubject发送的通知。

（4）定义具体的观察者ConcreteObserver：

```html
public class ConcreteSubject extends Subject{
    public void dataChange(String message){
    }
}
```

以上代码定义了具体的观察者ConcreteObserver类，用于接收Observer发送过来的通知并做具体的消息处理。

（5）使用观察者模式：

```html
public static void main(String[] args){
    Subject subject=new ConcreteSubject();
    Observer obs=new ConcreteObserver();
    subject.add(obs);
    subject.notifyObserver("datail");
}
```

在使用观察者模式时首先要定义一个Subject主题，然后定义需要接收通知的观察者，接着将观察者加入主题的监控列表中，在有数据发生变化时，Subject（主题）会将变化后的消息发送给观察者，最后调用subject的方法notifyObserver()发送一个数据变化的通知。

## 18.迭代器模式

迭代器（Iterator）模式提供了顺序访问集合对象中的各种元素，而不暴露该对象内部结构的方法。

Java中的集合就是典型的迭代器模式，比如HashMap，在我们需要遍历HashMap时，通过迭代器不停地获取Next元素就可以循环遍历集合中的所有元素。

迭代器模式将遍历集合中所有元素的操作封装成迭代器类，其目的是在不暴露集合对象内部结构的情况下，对外提供统一访问集合的内部数据的方法。迭代器的实现一般包括一个迭代器，用于执行具体的遍历操作；以及一个Collection，用于存储具体的数据。我们以Collection集合的迭代器设计为例介绍迭代器模式的设计思路。

具体实现如下。

（1）定义名为Collection的集合接口：

```html
public interface Collection{
    //对集合元素的迭代
    public Iterator iterator();
    //取得集合元素
    public Object get(int i);
    //向集合添加元素
    public boolean add(Object object);
    //取得集合大小
    public int size();
}
```

以上代码定义了名为Collection的接口，用于制定集合操作的规范。在该接口中定义了iterator()用于集合接口的遍历，定义了get()用于获取集合中的元素，定义了add()用于向集合中添加元素，定义了size()用于获取集合的大小。

（2）定义Collection接口实现类ListCollection：

```html
public class ListCollection implements Collection{
    public List list=new ArrayList();//list用于数据的存储
    @Override
    public Iterator iterator(){
        reeturn new ConcreteIterator(this);
    }
    @Override
    public Object get(int i){
        reeturn list.get(i);
    }
    @Override
    public boolean add(Object object){
        list.add(object);
        reeturn true;
    }
    @Override
    public int size(){
        reeturn list.size();
    }
}
```

以上代码定义了Collection接口的实现类ListCollection，ListCollection类用于存储具体的数据并实现数据操作方法，其中，list用于存储数据，iterator()用于构造集合迭代器。

（3）定义迭代器接口Iterator：

```html
public interface Iterator{
    //指针前移
    public Object previous();
    //指针后移
    public Object next();
    public boolean hasNext();
}
```

以上代码定义了迭代器接口Iterator，在该接口中规范了迭代器应该实现的方法，其中，previous()用于访问迭代器中的上一个元素，next()用于访问迭代器中的下一个元素，hasNext()用于判断在迭代器中是否还有元素。

（4）定义迭代器接口Iterator的实现类ConcreteIterator：

```html
public class ConcreteIterator implements Iterator{
    private Collection collection;
    private int pos=-1;//当前迭代器遍历到的元素位置
    public ConcreteIterator(Collection collection){
        this.collection=collection;
    }
    @Override
    public Object previous(){
        if(pos>0){
            pos--;
        }
        return collection.get(pos);
    }
    @Override
    public Object next(){
        if(pos<collection.size()-1){
            pos++;
        }
        return collection.get(pos);
    }
    @Override
    public boolean hasNext(){
        if(pos<collection.size()-1){
            return true;
        }else{
            return false;
        }
    }
}
```

以上代码定义了迭代器接口Iterator的实现类ConcreteIterator，在ConcreteIterator中定义了Collection用于访问集合中的数据，pos用于记录当前迭代器遍历到的元素位置，同时实现了在Iterator接口中定义的方法previous()、next()和hasNext()，以完成具体的迭代器需要实现的基础功能。

（5）使用迭代器：

```html
public static void main(String[] args){
    //定义集合
    Collection collection=new ListCollection();
    //向集合中添加数据
    collection.add("object1");
    //使用迭代器遍历集合
    Iterator it=collection.iterator();
    while(it.hasNext()){
    }
}
```

迭代器的使用方法比较简单：首先需要定义一个集合并向集合中加入数据，然后获取集合的Iterator迭代器并通过循环遍历集合中的数据。

## 19.责任链模式

责任链（Chain of Responsibility）模式也叫作职责链模式，用于避免请求发送者与多个请求处理者耦合在一起，让所有请求的处理者持有下一个对象的引用，从而将请求串联成一条链，在有请求发生时，可将请求沿着这条链传递，直到遇到该对象的处理器。

在责任链模式下，用户只需将请求发送到责任链上即可，无须关心请求的处理细节和传递过程，所以责任链模式优雅地将请求的发送和处理进行了解耦。

在责任链模式下，用户只需将请求发送到责任链上即可，无须关心请求的处理细节和传递过程，所以责任链模式优雅地将请求的发送和处理进行了解耦。

责任链模式包含以下三种角色。

- Handler接口：用于规定在责任链上具体要执行的方法。
- AbstractHandler抽象类：持有Handler实例并通过setHandler()和getHandler()将各个具体的业务Handler串联成一个责任链，客户端上的请求在责任链上执行。
- 业务Handler：用户根据具体的业务需求实现的业务逻辑。

具体实现如下。

（1）定义Handler接口：

```html
public interface Handler{
    void operator();
}
```

以上代码定义了Handler接口，该接口用于规定责任链上各个环节的操作，这里定义了operator()，用于在责任链上各个环节处理任务时进行调用。

（2）定义AbstractHandler类：

```html
public abstract class AbstractHandler{
    private Handler handler;
    private Handler getHandler(){
        return handler;
    }
    public void setHandler(Handler handler){
        this.handler=handler;
    }
}
```

以上代码定义了抽象类AbstractHandler来将责任链上的各个组件连接起来，具体操作是通过setHandler()设置下一个环节的组件，通过getHandler()获取下一个环节的组件。

（3）定义用户授权类AuthHandler：

```html
public class AuthHandler extends AbstractHandler implements Handler{
    private String name;
    public AuthHandler(String name){
        this.name=name;
    }
    @Override
    public void operator(){
        if(getHandler()!=null){//执行责任链的下一个流程
            getHandler().operator();
        }
    }
}
```

以上代码定义了用户授权类AuthHandler并实现了operator()，该方法首先调用当前环节的业务流程，即用户授权，然后通过getHandler()获取下一个组件并调用其operator()，使其执行下一个责任链流程。

（4）定义业务处理类BusinessHandler：

```html
public class BusinessHandler extends AbstractHandler implements Handler{
    private String name;
    public BusinessHandler(String name){
        this.name=name;
    }
    @Override
    public void operator(){
        if(getHandler()!=null){//执行责任链的下一个流程
            getHandler().operator();
        }
    }
}
```

以上代码定义了用户授权类BusinessHandler并实现了方法operator()，该方法首先调用当前环节的业务流程，即业务处理流程，然后通过getHandler()获取下一个组件并调用其operator()，使其执行责任链的下一个流程。

（5）定义请求反馈类ResponseHandler：

```html
public class ResponseHandler extends AbstractHandler implements Handler{
    private String name;
    public ResponseHandler(String name){
        this.name=name;
    }
    @Override
    public void operator(){
        if(getHandler()!=null){//执行责任链的下一个流程
            getHandler().operator();
        }
    }
}
```

以上代码定义了用户授权类ResponseHandler并实现了operator()，该方法首先调用当前环节的业务流程，这里的业务流程主要是判断业务流程执行的结果并做出相应的反馈，然后通过getHandler()获取下一个组件并调用其operator()，使其执行下一个责任链流程。

（6）使用责任链模式：

```html
public static void main(String[] args){
    AuthHandler authHandler=new AuthHandler("auth");
    BusinessHandler businessHandler=new BusinessHandler("business");
    ResponseHandler responseHandler=new ResponseHandler("response");
    authHandler.setHandler(businessHandler);
    businessHandler.setHandler(responseHandler);
    authHandler.operator();
}
```

在使用责任链模式时，首先要定义各个责任链的组件，然后将各个组件通过setHandler()串联起来，最后调用第一个责任链上的operator()，接着程序就像多米诺骨牌一样在责任链上执行下去。

## 20.命令模式

命令（Command）模式指将请求封装为命令基于事件驱动异步地执行，以实现命令的发送者和命令的执行者之间的解耦，提高命令发送、执行的效率和灵活度。

命令模式将命令调用者与命令执行者解耦，有效降低系统的耦合度。同时，由于命令调用者和命令执行者进行了解耦，所以增加和删除（回滚）命令变得非常方便。

命令模式包含以下主要角色。

- 抽象命令类（Command）：执行命令的接口，定义执行命令的抽象方法execute()。
- 具体命令类（Concrete Command）：抽象命令类的实现类，持有接收者对象，并在接收到命令后调用命令执行者的方法action()实现命令的调用和执行。
- 命令执行者（Receiver）：命令的具体执行者，定义了命令执行的具体方法action()。
- 命令调用者（Invoker）：接收客户端的命令并异步执行。

具体实现如下。

（1）定义Command接口：

```html
public interface Command{
    public void exe(String command);
}
```

以上代码定义了Command接口，并在该接口中定义了Command的执行方法exe()。

（2）定义Command接口的实现类ConcreteCommand：

```html
public class ConcreteCommand implements Command{
    private Receiver receiver;
    public ConcreteCommand(Receiver receiver){
        this.receiver=receiver;
    }
    @Override
    public void exe(String command){
        receiver.action(command);
    }
}
```

以上代码定义了Command接口的实现类ConcreteCommand，该类持有命令接收和执行者Receiver的实例，并实现了Command接口中的exe()，具体操作是在ConcreteCommand接收到命令后，调用Receiver的action()将命令交给Receiver执行。

（3）定义命令调用者类Invoker：

```html
public class Invoker{
    private Command command;
    public Invoker(Command command){
        this.command=command;
    }
    public void action(String commandMessage){
        command.exe(commandMessage);
    }
}
```

以上代码定义了命令调用者类Invoker，该类持有Command实例并在action()中实现了对命令的调用，具体做法是在action()中执行Command的exe()。

（4）定义命令的接收和执行者类Receiver：

```html
public class Receiver{
    public void action(String command){//接收并执行命令
    }
}
```

以上代码定义了命令的接收和执行者类Receiver，并在action()中接收和执行命令。

（5）使用命令模式：

```html
public static void main(String[] args){
    //定义命令的接收和执行者
    Receiver receiver=new Receiver();
    //定义命令实现类
    Command cmd=new ConcreteCommand(receiver);
    //定义命令调用者
    Invoker invoker=new Invoker(cmd);
    //命令调用
    invoker.action("command1");
}
```

在使用命令模式时首先要定义一个命令接收和执行者Receiver，接着定义一个具体的命令ConcreteCommand实例，并将命令接收者实例设置到实例中，然后定义一个命令的调用者Invoker实例，并将命令实例设置到实例中，最后调用命令调用者的action()，将命令发送出去，在命令接收者收到数据后会执行相关命令，这样就完成了命令的调用。

## 21.备忘录模式

备忘录（Memento）模式又叫作快照模式，该模式将当前对象的内部状态保存到备忘录中，以便在需要时能将该对象的状态恢复到原先保存的状态。

备忘录模式提供了一种保存和恢复状态的机制，常用于快照的记录和状态的存储，在系统发生故障或数据发生不一致时能够方便地将数据恢复到某个历史状态。

备忘录模式的核心是设计备忘录类及用于管理备忘录的管理者类，其主要角色如下。

- 发起人（Originator）：记录当前时刻对象的内部状态，定义创建备忘录和恢复备忘录数据的方法。
- 备忘录（Memento）：负责存储对象的内部状态。
- 状态管理者（Storage）：对备忘录的历史状态进行存储，定义了保存和获取备忘录状态的功能。注意，备忘录只能被保存或恢复，不能进行修改。

具体实现如下。

（1）定义原始数据Original：

```html
public class Original{
    private String value;
    public Memento createMemento(){
        return new Memento(value);
    }
    public void restoreMemento(Memento memento){
        this.value=memento.getValue();
    }
}
```

以上代码定义了原始数据Original，在原始数据中定义了createMemento()和restoreMemento()分别用于创建备忘录和从备忘录中恢复数据。

（2）定义备忘录Memento：

```html
public class Memento{
    private String value;
}
```

以上代码定义了备忘录Memento，其中value为备忘录具体的数据内容。

（3）定义备忘录管理者Storage：

```html
public class Storage{
    private Memento memento;
}
```

以上代码定义了备忘录管理者Storage，持有备忘录实例，并提供了setMemento()和getMemento()分别用来设置和获取一个备忘录数据。

（4）使用备忘录：

```html
public static void main(String[] args){
	//创建原始类
	Original original=new Original("张三");
	//创建备忘录
	Storage storage=new Storage(original.createMemento());
	//修改原始类的状态
	original.setValue("李四");
	//恢复原始类的状态
	original.restoreMemento(storage.getMemento());
}
```

备忘录的使用方法比较简单：先定义一个原始数据，然后将数据存储到Storage，这时我们可以修改数据，在我们想把数据回滚到之前的状态时调用Original的restoreMemento()便可将存储在Storage中上次数据的状态恢复。其实，备忘录简单来说就是把原始数据的状态在Storage中又重新存储一份，在需要时可以恢复数据。

上面的例子只存储了数据的上一次状态，如果想存储多个状态，就可以在Storage中使用列表记录多个状态的数据。

## 22.状态模式

状态模式指给对象定义不同的状态，并为不同的状态定义不同的行为，在对象的状态发生变换时自动切换状态的行为。

状态模式是一种对象行为型模式，它将对象的不同行为封装到不同的状态中，遵循了“单一职责”原则。同时，状态模式基于对象的状态将对象行为进行了明确的界定，减少了对象行为之间的相互依赖，方便系统的扩展和维护。

状态模式在生活中很常见，比如日常生活有工作状态、休假状态；钉钉有出差、会议、工作中等状态。每种状态都对应不同的操作，比如工作状态对应的行为有开会、写PPT、写代码、做设计等，休假状态对应的行为有旅游、休息、陪孩子等。

状态模式把受环境改变的对象行为包装在不同的状态对象里，用于让一个对象在其内部状态改变时，行为也随之改变。具体的角色如下。

- 环境（Context）：也叫作上下文，用于维护对象当前的状态，并在对象状态发生变化时触发对象行为的变化。
- 抽象状态（AbstractState）：定义了一个接口，用于定义对象中不同状态所对应的行为。
- 具体状态（Concrete State）：实现抽象状态所定义的行为。

具体实现如下。

（1）定义AbstractState：

```html
public abstract class AbstractState{
	public abstract void action(Context context);
}
```

以上代码定义了AbstractState抽象类，在类中定义了action()用于针对不同的状态执行不同的动作。

（2）定义AbstractState的子类HolidayState：

```html
public class HolidayState extends AbstractState{
	public void action(Context context){
	}
}
```

以上代码定义了AbstractState的子类HolidayState并实现了action()，HolidayState中的action()的主要动作是旅行（travel）、购物（shopping）、看电视（watch television）等。

（3）定义AbstractState的子类WorkState：

```html
public class WorkState extends AbstractState{
	public void action(Context context){
	}
```

以上代码定义了AbstractState的子类WorkState并实现了action()，WorkState中action()的主要动作是开会（meeting）、设计（design）、写代码（coding）等。

（4）定义Context用于存储状态和执行不同状态下的行为：

```html
public class Context{
	private AbstractState state;
	public Context(AbstractState state){
		this.state=state;
	}
	public void action(){
		this.state.action(this);
	}
}
```

以上代码定义了Context类，该类用于设置上下文环境中的状态，并根据不同的状态执行不同的action()。这里状态的设置通过setState()完成，具体的动作执行通过action()完成。

（5）使用状态模式：

```html
public static void main(String[] args){
	//定义当前状态为工作状态
	Context context=new Context(new WorkState());
	context.action();
	//切换当前状态为修改状态
	context.setState(new HolidayState());
	context.action();
}
```

在使用状态模式时，只需定义一个上下文Context，并设置Context中的状态，然后调用Context中的行为方法即可。以上代码首先通过Context的构造函数将状态设置为WorkState，接着通过setState()将状态设置为HolidayState，两种不同的状态将对应不同的行为。

## 23.访问者模式

访问者（Visitor）模式指将数据结构和对数据的操作分离开来，使其在不改变数据结构的前提下动态添加作用于这些元素上的操作。它将数据结构的定义和数据操作的定义分离开来，符合“单一职责”原则。访问者模式通过定义不同的访问者实现对数据的不同操作，因此在需要给数据添加新的操作时只需为其定义一个新的访问者即可。

访问者模式是一种对象行为型模式，主要特点是将数据结构和作用于结构上的操作解耦，使得集合的操作可自由地演化而不影响其数据结构。它适用于数据结构稳定但是数据操作方式多变的系统中。

访问者模式实现的关键是将作用于元素的操作分离出来封装成独立的类，包含以下主要角色。

- 抽象访问者（Visitor）：定义了一个访问元素的接口，为每类元素都定义了一个访问操作visit()，该操作中的参数类型对应被访问元素的数据类型。
- 具体访问者（ConcreteVisitor）：抽象访问者的实现类，实现了不同访问者访问到元素后具体的操作行为。
- 抽象元素（Element）：元素的抽象表示，定义了访问该元素的入口的accept()方法，不同的访问者类型代表不同的访问者。
- 具体元素（Concrete Element）：实现抽象元素定义的accept()操作，并根据访问者的不同类型实现不同的业务逻辑。

比如，我们有个项目计划需要上报，项目计划的数据结构是稳定的，包含项目名称和项目内容，但项目的访问者有多个，比如项目经理、CEO和CTO。类似的数据结构稳定但对数据的操作多变的情况很适合只用访问者模式实现。

具体实现如下。

（1）定义抽象Visitor接口：

```html
public interface Visitor{
	void visit(ProjectElement element);
}
```

以上代码定义了Visitor接口，并在接口中定义了visit()用于指定要访问的数据。

（2）定义Visitor实现类CEOVisitor：

```html
public class CEOVisitor implements Visitor{
	@Override
	public void visit(ProjectElement element){
		element.signature("CEO",new Date());
	}
}
```

以上代码定义了Visitor实现类CEOVisitor，并实现了其方法visit()，该方法在接收到具体的元素时，访问该元素并调用signature()签名方法表示CEOVisitor已经访问和审阅了该项目。

（3）定义Visitor实现类CTOVisitor：

```html
public class CTOVisitor implements Visitor{
	@Override
	public void visit(ProjectElement element){
		element.signature("CTO",new Date());
	}
}
```

以上代码定义了Visitor实现类CTOVisitor，并实现了其方法visit()，该方法在接收到具体的元素时，会访问该元素并调用signature()签名方法表示CTOVisitor已经访问和审阅了该项目。

（4）定义抽象元素Element的接口：

```html
public interface Element{
	void accept(Visitor visitor);
}
```

以上代码定义了抽象元素Element，并定义了accept()用于接收访问者对象。

（5）定义具体元素ProjectElement的类：

```html
public class ProjectElement implements Element{
	private String projectName;
	private String projectContent;
	private String visitorName;
	private Date visitorTime;
	public ProjectElement(String projectName,String projectContent){
		this.projectName=projectName;
		this.projectContent=projectContent;
	}
	public void sccept(Visitor visitor){
		visitor.visit(this);
	}
	public void signature(String visitorName,Date visitorTime){
		this.visitorName=visitorName;
		this.visitorTime=visitorTime;
	}
}
```

以上代码定义了ProjectElement用于表示一个具体的元素，该元素表示一个项目信息，包含项目名称projectName、项目内容projectContent、项目访问者visitorName和项目访问时间，还定义了signature()用于记录访问者的签名，以及accept()用于接收具体的访问者。

（6）使用访问者模式：

```html
public static void main(String[] args){
	Element element=new ProjectElement("mobike","share bicycle");
	element.accept(new CTOVisitor());
	element.accept(new CEOVisitor());
}
```

在使用访问者模式时，首先需要定义一个具体的元素，然后通过accept()为元素添加访问者即可。

## 24.中介者模式

中介者（Mediator）模式指对象和对象之间不直接交互，而是通过一个名为中介者的角色来实现对象之间的交互，使原有对象之间的关系变得松散，且可以通过定义不同的中介者来改变它们之间的交互。中介者模式又叫作调停模式，是迪米特法则的典型应用。

中介者模式属于对象行为型模式，其主要特点是将对象与对象之间的关系变为对象和中介者之间的关系，降低了对象之间的耦合性，提高了对象功能的复用性和系统的灵活性，使得系统易于维护和扩展。

中介者模式包含以下主要角色。

- 抽象中介者（Mediator）：中介者接口，定义了注册同事对象方法和转发同事对象信息的方法。
- 具体中介者（Concrete Mediator）：中介者接口的实现类，定义了一个List来保存同事对象，协调各个同事角色之间的交互关系。
- 抽象同事类（Colleague）：定义同事类的接口，持有中介者对象，并定义同事对象交互的抽象方法，同时实现同事类的公共方法和功能。
- 具体同事类（Concrete Colleague）：抽象同事类的实现者，在需要与其他同事对象交互时，通过中介者对象来完成。

下面以租房场景为例来介绍中介者模式。我们知道，在租房时会找房屋中介，把自己的租房需求告知中介，中介再把需求告知房东，在整个过程中租房者和房东不产生直接关系（也不能产生关系，不然中介就没钱赚了），而是通过中介来完成信息交互，这样就完成了对象之间的解耦，也就是租户和房东的解耦，房东不用关心具体有哪些房客、房客有哪些需求，租房者也不用辛苦寻找房东及房子的信息。

具体实现如下。

（1）定义抽象的Colleague类：

```html
public abstract class Colleague{
	protected Mediator mediator;
	public abstract boolean operator(String message);//同事类的操作
}
```

以上代码定义了抽象同事类Colleague，该类持有中介者对象并定义了同事类的具体操作方法operation()。

（2）定义Colleague实现类ColleagueLandlord以代表房东：

```html
public class ColleagueLandlord extends Colleague{
	@Override
	public boolean operation(String message){//收到房客的需求
		logger.info();
		return true;	
	}
}
```

以上代码定义了Colleague实现类ColleagueLandlord以代表房东，并实现了方法operation()，该方法用来接收中介者传递的房客需求并做出具体响应。

（3）定义Colleague实现类ColleagueTenant以代表租户：

```html
public class ColleagueTenant extends Colleague{
	@Override
	public boolean operation(String message){//收到房客的需求
		logger.info();
		return true;	
	}
}
```

以上代码定义了Colleague实现类ColleagueTenant以代表租户，并实现了方法operation()，该方法用来接收中介者传递的房东的房源信息并做出具体的响应。

（4）定义抽象中介者Mediator类：

```html
public abstract class Mediator{
	protected Colleague colleagueTenant;
	protected Colleague colleagueLandlord;
	public abstract boolean notifyColleagueTenant(String message);
	public abstract boolean notifyColleagueLandlord(String message);
}
```

以上代码定义了抽象中介者Mediator类，该类持有租客和房东类的实例，并定义了notifyColleagueTenant()和notifyColleagueLandlord()分别向房客和房东传递信息。

（5）定义Mediator实现类ConcreteMediator代表一个具体的中介：

```html
public class ConcreteMediator extends Mediator{
	public ConcreteMediator(Colleague colleagueTenant,Colleague colleagueLandlord){
		super(colleagueTenant,colleagueLandlord);
	}
	@Override
	public boolean notifyColleagueTenant(String message){
		if(colleagueTenant!=null){
			return colleagueTenant.operation(message);
		}
		return false;
	}
	@Override
	public boolean notifyColleagueLandlord(String message){
		if(colleagueLandlord!=null){
			return colleagueLandlord.operation(message);
		}
		return false;
	}
}
```

以上代码定义了Mediator实现类ConcreteMediator来代表一个具体的中介，该中介实现了notifyColleagueTenant()和notifyColleagueLandlord()来完成房客和房东直接、具体的消息传递。

（6）使用中介者模式：

```html
public static void main(String[] args){
	//定义客房同事类
	Colleague colleagueTenant=new ColleagueTenant();
	//定义房东同事类
	Colleague colleagueLandlord=new ColleagueLandlord();
	//创建一个具体的中间者，这里可以将其理解为房屋中介
	ConcreteMediator concreteMediator=new ConcreteMediator(colleagueTenant,colleagueLandlord);
	boolean resoult=concreteMediator.notifyColleagueTenant("想租2室1厅吗")
	if(resoult){
		concreteMediator.notifyColleagueLandlord("租户对面积满意");
	}else{
		concreteMediator.notifyColleagueLandlord("租户对面积不满意");
	}
}
```

在使用中介者模式时，首先要定义同事类，然后定义中介者并通过中介者完成对象之间的交互。以上代码首先定义了房客类和房东类，然后定义了中介者，最后通过中介者的notifyColleagueTenant()和notifyColleagueLandlord()完成房客和中间者之间的交互。以上代码的流程是中介者首先向房客询问对方对房屋面积的需求，然后将需求反馈给房东。

## 25.解释器模式

解释器（Interpreter）模式给定一种语言，并定义该语言的语法表示，然后设计一个解析器来解释语言中的语法，这种模式常被用于SQL解析、符号处理引擎等。

解释器模式包含以下主要角色。

- 抽象表达式（Abstract Expression）：定义解释器的接口，约定解释器所包含的操作，比如interpret()方法。
- 终结符表达式（Terminal Expression）：抽象表达式的子类，用来定义语法中和终结符有关的操作，语法中的每一个终结符都应有一个与之对应的终结表达式。
- 非终结符表达式（Nonterminal Expression）：抽象表达式的子类，用来定义语法中和非终结符有关的操作，语法中的每条规则都有一个非终结符表达式与之对应。
- 环境（Context）：定义各个解释器需要的共享数据或者公共的功能。

解释器模式主要用于和语法及表达式有关的应用场景，例如正则表达式解释器等。

具体实现如下。

（1）定义Expression接口：

```html
public interface Expression{
	public void interpret(Context ctx);//解释方法
}
```

以上代码定义了Expression接口，并定义了解释器方法。

（2）定义NonterminalExpression类：

```html
public class NonterminalExpression implements Expression{
	private Expression left;
	private Expression right;
	public void interpret(Context ctx){
		//递归调用每一个组成部分的interpret()
		//在递归调用时指定组成部分的连接方式，即非终结符的功能
	}
}
```

以上代码定义了Expression的实现类NonterminalExpression，NonterminalExpression类主要用于对非终结元素的处理。NonterminalExpression定义了left和right的操作元素。

（3）定义TerminalExpression：

```html
public class TerminalExpression implements Expression{
	@Override
	public void interpret(Context ctx){
		//终结符表达式的解释操纵
	}
}
```

以上代码定义了Expression的实现类TerminalExpression，TerminalExpression类主要用于对终结元素的处理，表示该元素是整个语法表达式的最后一个元素。

（4）定义Context：

```html
public class Context{
	private HashMap map=new HashMap();
	public void assign(String key,String value){
		//在环境类中设值
	}
	public String get(String key){
		//获取存储在环境类中的值
		return "";
	}
}
```

以上代码定义了Context的全局类用于存储表达式解析出来的值，并提供查询和解析后表达式的结果，以便其他表达式进一步使用。

## 26.设计模式

代理模式

代理模式的定义：为其他对象提供一种代理以控制对这个对象的访问。在某些情况下， 一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。

举例子：Thread其实实现了Runnable接口，但是它还干了许多Runnable接口没有干的事情，它先完成比线程主体更多的操作，比如分配CPU资源，线程是否启动等等，从类关系上看是典型的代理模式。

策略模式

策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以相互替 换。策略模式让算法独立于使用它的客户而独立变化。将算法的责任委派给不同的对象处理，在比较和排序时候经常用到。

举例子：java的自定义类型内部新建一个内部类，有name和id两个属性，为了比较两个自定义类型，实现compartor接口，而不是直接重写comparable接口，在调用sort()函数的时候，可以把这个内部类直接传给sort()函数，这样就可以避免重写compareTo()方 法，只要写两个内部类实现comparator接口即可。

Hibernate的二级缓存有不同的缓存提供商，这也是一种策略模式，例如ehcache, hashset, oscache等等

单例模式

单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证系统中一个类只有一个实例

应用场景：主要用在资源共享，控制资源之间交流 1.数据库连接池 2.日志应用 3.应用配置 4.线程池

JDKRunTime，Selector类用到了单例模式 Spring IoC控制的bean默认的就是单例的，但是我们可以通过改scope属性来改成prototype的。

Hibernate的SessionFactory可以写成一个单例模式，因为一个SessionFactory相当于一个数据库的内存镜像，存在多个也是没有意义的，所以在Spring IoC中只要把它设置成一个Singleton模式的就可以了，就可以一些不必要的资源浪费了。

单例模式实现：

懒汉模式（懒加载）：首先将构造函数设成private型，定义一个static变量来储存实例， 调用getInstance方法获得实例，方法内部判断实例是否已经建立，没有就建一个，否则直接返回已有实例

饿汉模式：定义变量的时候直接初始化。

线程安全：懒汉模式不是线程安全的，因为可能有两个线程同时判断出对象没有实例 化，于是创建了两个实例，饿汉模式一开始就初始化了实例，所以始终只有一个，不需要再创建

实例化时机不同：懒汉模式获取的时候才实例化，饿汉定义变量的时候就实例化了

延迟加载：懒汉模式需要的时候才创建，体现了延迟加载，（可用于缓存，实例就是缓存，有了就不再往缓存立方，没有才放）

双重加锁：double-check：懒汉模式实现线程安全，每次获取实例的时候都需要加锁同步，影响效率，所以在外面在加一层判断，对象是否实例化，如果已经实例化过了就不需要再进里面去加锁同步了，（变量要定义成volatile类型）这还不是线程安全的？该还有将instance加个关键字volatile，不然的话编译重排序可能造成还没初始化完成就已经完成对象引用的复制，但是此时对象还没有初始化完毕。饱汉模式的区别volatile内存模型防止被优化

枚举实现单例最好

一种是通过枚举，一种是通过静态内部类

装饰模式

在不必改变原类文件和使用继承的情况下，动态地扩展一个对象的功能。它是通过创建一个包装对象，也就是装饰来包裹真实的对象。就是把想要包装的类，通过作为初始化参数传递给装饰类，然后装饰类给他加了一些功能。

Java中的打印流，PrintStream类PrintWriter类就用到了装饰模式，它本身实现的就是

PrintStream(OutputStream),它所要干的事情就是构造函数里的OutputStream要干的事情，把数据传入到输入流当中，但是如果直接用OutputStream的话只能用write()方法， 并请只能写byte类型，感觉很苦逼，所以它用PrintStream类来装饰（包装）了一下

OutputStream类，这样它就可以更加方便的使用了，比如可以直接调用print();println();各种函数往流里面写东西。

ObjectOutputStream类就采用了装饰者模式，并要求通过另一个OutputStream从物理上写入序列化数据。ObjectOutputStream类包含了覆盖所有原始类型的方法，以及一个使用与引用类型的方法，通过这些方法可以将对应类型的值写入流中。

工厂模式

工厂模式又分为:简单工厂模式，工厂模式和抽象工厂模式。目的是解耦合。

简单工厂模式就是一个父类产品抽象类（接口），N个子类产品继承自父类，然后工厂类有一个static方法来根据不同的参数（函数内用switch或者if语句来判断）来生产不同的子类对象。

工厂模式比简单工厂模式更加具体化，工厂模式还是N个子类产品继承自一个父类，然后工厂类这回不是大包干了，而是工厂类也有一个父类，然后派生出不同的子类来对N个产品子类进行生产，这样在应用的时候，我们只要先声明一个工厂类对象，然后再根据不同的工厂类对象生产处不同的产品对象。

抽象工厂模式与工厂模式相比它提供了一个产品族的生产方法，也就是一个工厂类里生产了不同的等级结构的产品。所谓产品族是处于不同等级结构的产品之间有关联，然后他们组成了一个产品组。比如Car是一个大类，可以派生出BenzCar和BmwCar，而BenzCar又可以派生出BenzSportsCar，BMWCar又派生出BMWSportsCar，这两个SportsCar就是一个产品族的。

优点：

可以使代码结构清晰，有效地封装变化。在编程中，产品类的实例化有时候是比较复杂和多变的，通过工厂模式，将产品的实例化封装起来，使得调用者根本无需关心产品的实例化过程，只需依赖工厂即可得到自己想要的产品。

对调用者屏蔽具体的产品类。如果使用工厂模式，调用者只关心产品的接口就可以了， 至于具体的实现，调用者根本无需关心。即使变更了具体的实现，对调用者来说没有任何影响。

降低耦合度。产品类的实例化通常来说是很复杂的，它需要依赖很多的类，而这些类对于调用者来说根本无需知道，如果使用了工厂方法，我们需要做的仅仅是实例化好产品类，然后交给调用者使用。对调用者来说，产品所依赖的类都是透明的。

工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。

最主要的作用是解耦和，通过父类引用创建对象。可以利用反射机制实现工厂模式。

原型模式

原型模式(Prototype)，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

原型模式 其实就是从一个对象再创建另外一个可定制的对象，并且不需要知道任何创建的细节。

JAVA原型模式是实现cloneable接口，并且重写clone（）方法。分为浅复制和深复制。 **PS**： 深拷贝与浅拷贝问题中，会发生深拷贝的有**java**中的**8**中基本类型以及他们的封装类型，另外还有**String**类型。其余的都是浅拷贝。

原型模式的优点及适用场景

使用原型模式创建对象比直接new一个对象在性能上要好的多，因为Object类的clone方法是一个本地方法，它直接操作内存中的二进制流，特别是复制大对象时，性能的差别非常明 显。

使用原型模式的另一个好处是简化对象的创建，使得创建对象就像我们在编辑文档时的复制粘贴一样简单。

因为以上优点，所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多。

模板方法模式

定义一个操作中的算法的股价，而将一些步骤延迟到子类中。模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。子类替换掉父类中的抽象方法。

优点：模板方法模式是通过把不变行为搬到超类，去除子类中的重复代码来体现它的优势， 提供了一个很好的代码复用平台。当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。我们通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。

## 27.设计模式

### 1.单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点。

单例模式一般体现在类声明中，单例的类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。

用途

单例模式有以下两个优点：

在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如网站首页页面缓存）。

避免对资源的多重占用（比如写文件操作）。

实现方式

饿汉式

```html
public class Singleton {
    //在类内部实例化一个实例
    private static Singleton instance = new Singleton();
    //私有的构造函数,外部无法访问
    private Singleton() {
    }
    //对外提供获取实例的静态方法
    public static Singleton getInstance() {
        return instance;
    }
}
```

由于该实例在类被加载的时候就创建出来了，所以也避免了线程安全问题。

饿汉模式的变种

```html
public class Singleton2 {
    //在类内部定义
    private static Singleton2 instance;
    static {
        //实例化该实例
        instance = new Singleton2();
    }
    //私有的构造函数,外部无法访问
    private Singleton2() {
    }
    //对外提供获取实例的静态方法
    public static Singleton2 getInstance() {
        return instance;
    }
}
```

**饿汉式单例，在类被加载的时候对象就会实例化。这也许会造成不必要的消耗，因为有可能这个实例根本就不会被用到。而且，如果这个类被多次加载的话也会造成多次实例化。**

静态内部类式

```html
public class StaticInnerClassSingleton {
    //在静态内部类中初始化实例对象
    private static class SingletonHolder {
        private static final StaticInnerClassSingleton INSTANCE = new StaticInnerClassSingleton();
    }
    //私有的构造方法
    private StaticInnerClassSingleton() {
    }
    //对外提供获取实例的静态方法
    public static final StaticInnerClassSingleton getInstance() {
        return SingletonHolder.INSTANCE;
    }
}
```

这种方式同样利用了classloder的机制来保证初始化`instance`时只有一个线程，它跟饿汉式不同的是（很细微的差别）：饿汉式是只要`Singleton`类被装载了，那么`instance`就会被实例化（没有达到lazy loading效果），而这种方式是`Singleton`类被装载了，`instance`不一定被初始化。因为`SingletonHolder`类没有被主动使用，只有显示通过调用`getInstance`方法时，才会显示装载`SingletonHolder`类，从而实例化`instance`。想象一下，如果实例化`instance`很消耗资源，我想让他延迟加载，另外一方面，我不希望在`Singleton`类加载时就实例化，因为我不能确保`Singleton`类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化`instance`显然是不合适的。这个时候，这种方式相比饿汉式更加合理。

懒汉式

```html
public class Singleton {
    //定义实例
    private static Singleton instance;
    //私有构造方法
    private Singleton(){}
    //对外提供获取实例的静态方法
    public static Singleton getInstance() {
        //在对象被使用的时候才实例化
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

上面这种单例叫做懒汉式单例。懒汉，就是不会提前把实例创建出来，将类对自己的实例化延迟到第一次被引用的时候。`getInstance`方法的作用是希望该对象在第一次被使用的时候被`new`出来。

这种懒汉式单例其实还存在一个问题，那就是线程安全问题。在多线程情况下，有可能两个线程同时进入`if`语句中，这样，在两个线程都从if中退出的时候就创建了两个不一样的对象。

线程安全的懒汉式

```html
public class SynchronizedSingleton {
    //定义实例
    private static SynchronizedSingleton instance;
    //私有构造方法
    private SynchronizedSingleton(){}
    //对外提供获取实例的静态方法,对该方法加锁
    public static synchronized SynchronizedSingleton getInstance() {
        //在对象被使用的时候才实例化
        if (instance == null) {
            instance = new SynchronizedSingleton();
        }
        return instance;
    }
}
```

这种写法能够在多线程中很好的工作，而且看起来它也具备很好的延迟加载，但是，遗憾的是，他效率很低，因为99%情况下不需要同步。（因为上面的`synchronized`的加锁范围是整个方法，该方法的所有操作都是同步进行的，但是对于非第一次创建对象的情况，也就是没有进入`if`语句中的情况，根本不需要同步操作，可以直接返回`instance`。）

双重校验锁

上面的代码存在的问题主要是锁的范围太大了。只要缩小锁的范围就可以了。那么如何缩小锁的范围呢？相比于同步方法，同步代码块的加锁范围更小。

```html
public class Singleton {
    private static Singleton singleton;
    private Singleton() {
    }
    public static Singleton getSingleton() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }
}
```

线程A发现变量没有被初始化, 然后它获取锁并开始变量的初始化。

由于某些编程语言的语义，编译器生成的代码允许在线程A执行完变量的初始化之前，更新变量并将其指向部分初始化的对象。

线程B发现共享变量已经被初始化，并返回变量。由于线程B确信变量已被初始化，它没有获取锁。如果在A完成初始化之前共享变量对B可见（这是由于A没有完成初始化或者因为一些初始化的值还没有穿过B使用的内存(缓存一致性)），程序很可能会崩溃。

volatile关键字保证多个线程可以正确处理单件实例

在singleton前加上volatile可以避免此问题。

枚举式

```html
public enum  Singleton {

    INSTANCE;
    Singleton() {
    }
}
```

不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。

### 2.抽象工厂模式

概念

抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。

抽象工厂模式提供了一种方式，可以将同一产品族的单独的工厂封装起来。在正常使用中，客户端程序需要创建抽象工厂的具体实现，然后使用抽象工厂作为接口来创建这一主题的具体对象。客户端程序不需要知道（或关心）它从这些内部的工厂方法中获得对象的具体类型，因为客户端程序仅使用这些对象的通用接口。抽象工厂模式将一组对象的实现细节与他们的一般使用分离开来。

用途

抽象工厂模式和工厂方法模式一样，都符合开放-封闭原则。但是不同的是，工厂方法模式在增加一个具体产品的时候，都要增加对应的工厂。但是抽象工厂模式只有在新增一个类型的具体产品时才需要新增工厂。也就是说，工厂方法模式的一个工厂只能创建一个具体产品。而抽象工厂模式的一个工厂可以创建属于一类类型的多种具体产品。工厂创建产品的个数介于简单工厂模式和工厂方法模式之间。

在以下情况下可以使用抽象工厂模式：

一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是重要的。

系统中有多于一个的产品族，而每次只使用其中某一产品族。

属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。

系统提供一个产品类的库，所有的产品以同样的接口出现，从而使客户端不依赖于具体实现。

实现方式

抽象工厂模式包含如下角色：

AbstractFactory(抽象工厂)：用于声明生成抽象产品的方法。

ConcreteFactory(具体工厂)：实现了抽象工厂声明的生成抽象产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；

AbstractProduct(抽象产品)：为每种产品声明接口，在抽象产品中定义了产品的抽象业务方法；

Product(具体产品)：定义具体工厂生产的具体产品对象，实现抽象产品接口中定义的业务方法。

“开闭原则”的倾斜性

“开闭原则”要求系统对扩展开放，对修改封闭，通过扩展达到增强其功能的目的。对于涉及到多个产品族与多个产品等级结构的系统，其功能增强包括两方面：

增加产品族：对于增加新的产品族，工厂方法模式很好的支持了“开闭原则”，对于新增加的产品族，只需要对应增加一个新的具体工厂即可，对已有代码无须做任何修改。

增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色，包括抽象工厂类，在所有的工厂类中都需要增加生产新产品的方法，不能很好地支持“开闭原则”。

抽象工厂模式的这种性质称为“开闭原则”的倾斜性，抽象工厂模式以一种倾斜的方式支持增加新的产品，它为新产品族的增加提供方便，但不能为新的产品等级结构的增加提供这样的方便。

三种工厂模式之间的关系

当抽象工厂模式中每一个具体工厂类只创建一个产品对象，也就是只存在一个产品等级结构时，抽象工厂模式退化成工厂方法模式；

抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构。

当工厂方法模式中抽象工厂与具体工厂合并，提供一个统一的工厂来创建产品对象，并将创建对象的工厂方法设计为静态方法时，工厂方法模式退化成简单工厂模式。

总结

抽象工厂模式提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式，属于对象创建型模式。

抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形态。

抽象工厂模式的主要优点是隔离了具体类的生成，使得客户并不需要知道什么被创建，而且每次可以通过具体工厂类创建一个产品族中的多个对象，增加或者替换产品族比较方便，增加新的具体工厂和产品族很方便；主要缺点在于增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。

### 3.建造者模式

概念

建造者模式（英：Builder Pattern）是一种创建型设计模式，又名：生成器模式。GOF 给建造者模式的定义为：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。这句话说的比较抽象，其实解释一下就是：将建造复杂对象的过程和组成对象的部件解耦。

用途

将具体部位的创建工作和对象的创建进行解耦。这就是建造者模式。

实现方式

建造者模式包含如下角色：

Builder：抽象建造者(`Builder`)

ConcreteBuilder：具体建造者(`CommonBuilder`、`SuperBuilder`)

Director：指挥者(`Director`)

Product：产品角色(`Role`)

建造者模式的优缺点

优点

建造者模式的**封装性很好。使用建造者模式可以有效的封装变化**，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在导演类中对整体而言可以取得比较好的稳定性。

在建造者模式中，**客户端不必知道产品内部组成的细节**，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。

**可以更加精细地控制产品的创建过程** 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。

其次，**建造者模式很容易进行扩展**。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。

缺点

建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。

如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

适用环境

在以下情况下可以使用建造者模式：

需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。

需要生成的产品对象的属性相互依赖，需要指定其生成顺序。

对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。

隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。

建造者模式与工厂模式的区别

我们可以看到，建造者模式与工厂模式是极为相似的，总体上，建造者模式仅仅只比工厂模式多了一个"指挥者"的角色。在建造者模式的类图中，假如把这个导演类看做是最终调用的客户端，那么图中剩余的部分就可以看作是一个简单的工厂模式了。

与工厂模式相比，建造者模式一般用来创建更为复杂的对象，因为对象的创建过程更为复杂，因此将对象的创建过程独立出来组成一个新的类——导演类。

也就是说，工厂模式是将对象的全部创建过程封装在工厂类中，由工厂类向客户端提供最终的产品；而建造者模式中，建造者类一般只提供产品类中各个组件的建造，而将具体建造过程交付给导演类。由导演类负责将各个组件按照特定的规则组建为产品，然后将组建好的产品交付给客户端。

建造者模式与工厂模式类似，适用的场景也很相似。一般来说，如果产品的建造很复杂，那么请用工厂模式；如果产品的建造更复杂，那么请用建造者模式。

总结

建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

在建造者模式的结构中引入了一个指挥者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。

### 4.工厂模式

概念

工厂方法模式(Factory Method Pattern)又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式，它属于类创建型模式。

工厂方法模式是一种实现了“工厂”概念的面向对象设计模式。就像其他创建型模式一样，它也是处理在不指定对象具体类型的情况下创建对象的问题。

工厂方法模式的实质是“定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。工厂方法让类的实例化推迟到子类中进行。”

用途

**工厂方法模式和简单工厂模式虽然都是通过工厂来创建对象，他们之间最大的不同是——工厂方法模式在设计上完全完全符合“开闭原则”。**

在以下情况下可以使用工厂方法模式：

一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。

一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。

将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。

实现方式

工厂方法模式包含如下角色：

Product：抽象产品（`Operation`），定义工厂方法所创建的对象的接口。

ConcreteProduct：具体产品(`OperationAdd`)，

Factory：抽象工厂(`IFactory`)

ConcreteFactory：具体工厂(`AddFactory`)

工厂方法模式的利与弊

为什么要使用工厂来创建对象？

封装对象的创建过程。

在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户**隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。**

基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。**它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。**工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。

为什么每种对象要单独有一个工厂？

符合『开放-封闭原则』

主要目的是为了解耦。在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。

缺点

在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。

由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。

工厂方法与简单工厂的区别

工厂模式克服了简单工厂模式违背开放-封闭原则的缺点，又保持了封装对象创建过程的优点。

他们都是集中封装了对象的创建，使得要更换对象时，不需要做大的改动就可实现，降低了客户端与产品对象的耦合。

总结

工厂方法模式是简单工厂模式的进一步抽象和推广。

由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。

在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。

工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。

### 5.适配器模式

概念

GOF是这样给适配器模式(Adapter)定义的：将一个类的接口转化成用户需要的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

GOF中将适配器模式分为类适配器模式和对象适配器模式。区别仅在于适配器角色对于被适配角色的适配是通过继承还是组合来实现的。由于在Java 中不支持多重继承，而且有破坏封装之嫌。而且我们也提倡多用组合少用继承。

用途

1、系统需要使用现有的类，而此类的接口不符合系统的需要。

2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。

3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

以上场景都适合使用适配器模式。

实现方式

适配器模式包含如下角色：

Target：目标抽象类

Adapter：适配器类

Adaptee：适配者类

Client：客户类

优缺点

优点

将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。

增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。

灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。

缺点

过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。

对于类适配器而言，由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类

总结

结构型模式描述如何将类或者对象结合在一起形成更大的结构。

适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。

适配器模式包含四个角色：

目标抽象类定义客户要用的特定领域的接口；

适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；

适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；

在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。

在对象适配器模式中，适配器类继承了目标抽象类(或实现接口)并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。

适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。

适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。

### 6.迭代器模式

概念

迭代器模式提供一种方法访问一个容器中各个元素，而又不需要暴露该对象的内部细节。

那么，这里提到的容器是什么呢？其实就是可以包含一组对象的数据结构，如Java中的`Collection`和`Set`。

用途

迭代器模式的重要用途就是帮助我们遍历容器。

实现方式

迭代器模式包含如下角色：

Iterator 抽象迭代器

ConcreteIterator 具体迭代器

Aggregate 抽象容器

Concrete Aggregate 具体容器

### 7.策略模式

概念

策略模式(Strategy Pattern)：定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。

实现方式

策略模式包含如下角色：

Context: 环境类

Strategy: 抽象策略类

ConcreteStrategy: 具体策略类

优缺点

优点

- 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。
- 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码移到父类里面，从而避免代码重复。
- 使用策略模式可以避免使用多重条件(if-else)语句。多重条件语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重条件语句里面，比使用继承的办法还要原始和落后。

缺点

- 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。
- 由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。可以通过使用享元模式在一定程度上减少对象的数量。



### 74.什么是单例模式？

**什么是单例**

单例模式，也叫单子模式，是一种常用的软件设计模式。**在应用这个模式时，单例对象的类必须保证只有一个实例存在。**

许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。

在面向对象的思想中，通过**类的构造函数可以创建对象**，只要内存足够，可以创建任意个对象。

所以，要想限制某一个类只有一个单例对象，就需要在他的构造函数上下功夫。

实现对象单例模式的思路是：

1、一个类能返回对象一个引用(永远是同一个)和一个获得该实例的方法（必须是静态方法，通常使用getInstance这个名称）；

2、当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类保持的引用为空就创建该类的实例并将实例的引用赋予该类保持的引用；

3、同时我们还将该类的构造函数定义为私有方法，这样其他处的代码就无法通过调用该类的构造函数来实例化该类的对象，只有通过该类提供的静态方法来得到该类的唯一实例。

```html
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  

    public static Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}  
```

**以上Java代码，就实现了一个简单的单例模式。我们通过将构造方法定义为私有，然后提供一个getInstance方法，该方法中来判断是否已经存在该类的实例，如果存在直接返回。如果不存在则创建一个再返回。**

**线程安全的单例**

如果有两个线程同时执行到if(instance==null)这行代码，这是判断都会通过，然后各自会执行instance = new Singleton();并各自返回一个instance，这时候就产生了多个实例，就没有保证单例！

上面这种单例的实现方式我们通常称之为懒汉模式，所谓懒汉，指的是只有在需要对象的时候才会生成（getInstance方法被调用的时候才会生成）。

上面的这种懒汉模式并不是线程安全的，所以并不建议在日常开发中使用。基于这种模式，我们可以实现一个线程安全的单例的，如下：

```html
public class Singleton {  
    private static Singleton instance;  
    private Singleton (){}  
    public static synchronized Singleton getInstance() {  
    if (instance == null) {  
        instance = new Singleton();  
    }  
    return instance;  
    }  
}  
```

通过在getInstance方法上增加synchronized，通过锁来解决并发问题。这种实现方式就不会发生有多个对象被创建的问题了。

**双重校验锁**

上面这种线程安全的懒汉写法能够在多线程中很好的工作，但是，遗憾的是，这种做法效率很低，因为只有第一次初始化的时候才需要进行并发控制，大多数情况下是不需要同步的。

我们其实可以把上述代码做一些优化的，因为懒汉模式中使用synchronized定义一个同步方法，我们知道，**synchronized还可以用来定义同步代码块，而同步代码块的粒度要比同步方法小一些，从而效率就会高一些。**如以下代码：

```html
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getSingleton() {  
    if (singleton == null) {  
        synchronized (Singleton.class) {  
        if (singleton == null) {  
            singleton = new Singleton();  
        }  
        }  
    }  
    return singleton;  
    }  
}  
```

上面这种形式，只有在singleton == null的情况下再进行加锁创建对象，如果singleton!=null的话，就直接返回就行了，并没有进行并发控制。大大的提升了效率。

从上面的代码中可以看到，其实整个过程中进行了两次singleton == null的判断，所以这种方法被称之为"双重校验锁"。

还有值得注意的是，**双重校验锁的实现方式中，静态成员变量singleton必须通过volatile来修饰，保证其初始化不被重排，否则可能被引用到一个未初始化完成的对象。**

**饿汉模式**

所谓饿汉，就是事先准备好，需要的时候直接给你就行了。

如以下代码，饿汉模式：

```html
public class Singleton {  
    private static Singleton instance = new Singleton();  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return instance;  
    }  
}   
```

或者以下代码，饿汉变种：

```html
public class Singleton {  
    private Singleton instance = null;  
    static {  
    instance = new Singleton();  
    }  
    private Singleton (){}  
    public static Singleton getInstance() {  
    return this.instance;  
    }  
}  
```

以上两段代码其实没有本质的区别，都是通过static来实例化类对象。**饿汉模式中的静态变量是随着类加载时被完成初始化的。饿汉变种中的静态代码块也会随着类的加载一块执行。**

以上两个饿汉方法，其实都是通过定义静态的成员变量，以保证instance可以在类初始化的时候被实例化。

因为类的初始化是由ClassLoader完成的，这其实是利用了ClassLoader的线程安全机制。ClassLoader的loadClass方法在加载类的时候使用了synchronized关键字。也正是因为这样， 除非被重写，这个方法默认在整个装载过程中都是同步的（线程安全的）

除了以上两种饿汉方式，还有一种实现方式也是借助了calss的初始化来实现的，那就是通过静态内部类来实现的单例：

```html
public class Singleton {  
    private static class SingletonHolder {  
    private static final Singleton INSTANCE = new Singleton();  
    }  
    private Singleton (){}  
    public static final Singleton getInstance() {  
    return SingletonHolder.INSTANCE;  
    }  
}  
```

前面提到的饿汉模式，只要Singleton类被装载了，那么instance就会被实例化。

而这种方式是Singleton类被装载了，instance不一定被初始化。因为SingletonHolder类没有被主动使用，只有显示通过调用getInstance方法时，才会显示装载SingletonHolder类，从而实例化instance。

使用静态内部类，借助了classloader来实现了线程安全，这与饿汉模式有着异曲同工之妙，但是他有兼顾了懒汉模式的lazy-loading功能，相比较之下，有很大优势。

**单例的破坏**

我们实现的单例，把构造方法设置为私有方法来避免外部调用是很重要的一个前提。但是，私有的构造方法外部真的就完全不能调用了么？

其实不是的，**我们是可以通过反射来调用类中的私有方法的**，构造方法也不例外，所以，我们可以通过反射来破坏单例。

除了这种情况，还有一种比较容易被忽视的情况，那就是其实对象的序列化和反序列化也会破坏单例。

如使用ObjectInputStream进行反序列化时，在ObjectInputStream的readObject生成对象的过程中，其实会通过反射的方式调用无参构造方法新建一个对象。

所以，在对单例对象进行序列化以及反序列化的时候，一定要考虑到这种单例可能被破坏的情况。

可以通过在Singleton类中定义readResolve的方式，解决该问题：

```html
/**
 * 使用双重校验锁方式实现单例
 */
public class Singleton implements Serializable{
    private volatile static Singleton singleton;
    private Singleton (){}
    public static Singleton getSingleton() {
        if (singleton == null) {
            synchronized (Singleton.class) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }
        return singleton;
    }

    private Object readResolve() {
        return singleton;
    }
} 
```

**枚举实现单例**

使用枚举实现单例的方法虽然还没有广泛采用，但是单元素的枚举类型已经成为实现Singleton的最佳方法。

枚举实现单例：

```html
public enum Singleton {  
    INSTANCE;  
    public void whateverMethod() {  
    }  
}  
```

以上，就实现了一个非常简单的单例，从代码行数上看，他比之前介绍过的任何一种都要精简，并且，他还是线程安全的。

这些，其实还不足以说服我们这种方式最优。但是还有个至关重要的原因，那就是：**枚举可解决反序列化会破坏单例的问题**

**不使用synchronized实现单例**

前面讲过的所有方式，只要是线程安全的，其实都直接或者间接用到了synchronized，那么，如果不能使用synchronized的话，怎么实现单例呢？

使用Lock？这当然可以了，但是其实根本还是加锁，有没有不用锁的方式呢？

答案是有的，那就是CAS。CAS是一项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。

在JDK1.5 中新增java.util.concurrent(J.U.C)就是建立在CAS之上的。相对于对于synchronized这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升。

借助CAS（AtomicReference）实现单例模式：

```html
public class Singleton {
    private static final AtomicReference<Singleton> INSTANCE = new AtomicReference<Singleton>(); 

    private Singleton() {}

    public static Singleton getInstance() {
        for (;;) {
            Singleton singleton = INSTANCE.get();
            if (null != singleton) {
                return singleton;
            }

            singleton = new Singleton();
            if (INSTANCE.compareAndSet(null, singleton)) {
                return singleton;
            }
        }
    }
}
```

用CAS的好处在于不需要使用传统的锁机制来保证线程安全,CAS是一种基于忙等待的算法,依赖底层硬件的实现,相对于锁它没有线程切换和阻塞的额外消耗,可以支持较大的并行度。

使用CAS实现单例只是个思路而已，只是拓展一下帮助读者熟练掌握CAS以及单例等知识、千万不要在代码中使用！！！这个代码其实有很大的优化空间。

### 75.什么是策略模式？

策略

**策略，指的是可以实现目标的方案集合，在某些特定情况下，策略之间是可以相互替换的。**

比如我们在外卖平台上看到的这些优惠。满减、会员和红包等，每一个大项优惠都具体包含了多个优惠方案。如满减活动中，可以同时有满20减15、满50减30等。会员包含普通会员、超级会员等。

每一个优惠方式下面的多个优惠方案，其实都是一个策略。这些策略之间是相互排斥、可替换的。并且是有一定的优先级顺序的。

**策略模式**

我们说日常生活中，我们要实现目标，有很多方案，每一个方案都被称之为一个策略。在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。这就是策略模式。

**策略模式(Strategy Pattern)，指的是定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化。**

> 特别说明一下，策略模式只适用管理一组同类型的算法，并且这些算法是完全互斥的情况。也就是说任何时候，多个策略中只有一个可以生效的那一种。如满减中的满20减10与满30减20之间；普通会员折扣与超级会员折扣之间等。

在策略模式中，定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略(Strategy)，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。

要实现策略模式，肯定离不开策略。如前面提到的超级会员、普通会员、专属会员等的折扣其实都是策略。完全可以通过策略模式来实现。

**抽象策略类**

先定义一个接口，这个接口就是抽象策略类，该接口定义了计算价格方法，具体实现方式由具体的策略类来定义。

```html
public interface Buyer {

    /**
     * 计算应付价格
     */
    public BigDecimal calPrice(BigDecimal orderPrice);
}
```

**具体策略类**

针对不同的会员，定义三种具体的策略类，每个类中都分别实现计算价格方法。

```html
/**
 * 超级会员
 */
public class SuperVipBuyer implements Buyer {

    @Override
    public BigDecimal calPrice(BigDecimal orderPrice) {
        return orderPrice.multiply(new BigDecimal(0.8));
    }
}
```

**上面几个类的定义体现了封装变化的设计原则，不同会员的具体折扣方式改变不会影响到其他的会员。**

定义好了抽象策略类和具体策略类之后，我们再来定义上下文类，所谓上下文类，就是集成算法的类。这个例子中就是收银台系统。采用组合的方式把会员集成进来。

```html
public class Cashier {

    /**
     * 会员,策略对象
     */
    private Buyer buyer;

    public Cashier(Buyer buyer){
        buyer = buyer;
    }

    public BigDecimal quote(BigDecimal orderPrice) {
        return this.buyer.calPrice(orderPrice);
    }
}
```

这个Cashier类就是一个上下文类，该类的定义体现了**多用组合，少用继承、针对接口编程，不针对实现编程两个设计原则**。

由于这里采用了组合+接口的方式，后面我们在推出其他类型会员的时候无须修改Cashier类。只要再定义一个类实现Buyer接口 就可以了。

策略模式仅仅封装算法，提供新的算法插入到已有系统中，策略模式并不决定在何时使用何种算法。在什么情况下使用什么算法是由客户端决定的。

策略模式的优缺点

**策略模式可以充分的体现面向对象设计原则中的封装变化、多用组合，少用继承、针对接口编程，不针对实现编程等原则。**

策略模式具有以下特点：

- 策略模式的关注点不是如何实现算法，而是如何组织、调用这些算法，从而让程序结构更灵活，具有更好的维护性和扩展性。
- 策略模式中各个策略算法是平等的。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换。所有的策略算法在实现上也是相互独立的，相互之间是没有依赖的。所以可以这样描述这一系列策略算法：策略算法是相同行为的不同实现。
- 运行期间，策略模式在每一个时刻只能使用一个具体的策略实现对象，虽然可以动态地在不同的策略实现中切换，但是同时只能使用一个。

如果所有的具体策略类都有一些公有的行为。这时候，就应当把这些公有的行为放到共同的抽象策略角色Strategy类里面。当然这时候抽象策略角色必须要用Java抽象类实现，而不能使用接口。

也有如下缺点：

- 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。这种策略类的创建及选择其实也可以通过**工厂模式**来辅助进行。
- 由于策略模式把每个具体的策略实现都单独封装成为类，如果备选的策略很多的话，那么对象的数目就会很可观。可以通过使用**享元模式**在一定程度上减少对象的数量。

### 78.什么是适配器模式?

适配器模式

Adapter Pattern，通常被翻译成适配器模式，有时候也叫做包装模式（wrapper pattern），是GOF 23种设计模式之一。主要作用是将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

GOF中将适配器模式分为类适配器模式和对象适配器模式。

**对象适配器模式**

在这种适配器模式中，适配器容纳一个它包裹的类的实例。在这种情况下，适配器调用被包裹对象的物理实体。

**类适配器模式**

这种适配器模式下，适配器继承自已实现的类（一般多重继承）。

二者区别仅在于适配器角色对于被适配角色的适配是通过继承还是组合来实现的，由于Java中不支持多继承，而且类适配器模式有破坏封装之嫌，而且我们也提倡多用组合少用继承。**所以本文主要介绍对象适配器**。

**适配器模式用途**

在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足。如以下类似的场景：

1、系统需要使用现有的类，而此类的接口不符合系统的需要。

2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。

3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

适配器模式，就可以解决以上的问题。

**适配器模式实现方式**

```html
/**
 * Lightning充电接口
 */
public interface LightningInterface {
    public void chargeWithLightning();
}

/**
 * TypeC充电接口
 */
public interface TypeCInterface {
    public void chargeWithTypeC();
}
```

接下来定义我们的苹果手机，他只支持使用 Lightning插口充电：

```html
public class IphoneX {

    private LightningInterface lightningInterface;

    public IphoneX() {
    }

    public IphoneX(LightningInterface lightningInterface) {
        this.lightningInterface = lightningInterface;
    }

    public void charge() {
        System.out.println("开始给我的IphoneX手机充电...");
        lightningInterface.chargeWithLightning();
        System.out.println("结束给我的IphoneX手机充电...");
    }
    //setter/getter
}
```

然后再来看看我们的安卓充电器应该如何定义：

```html
/**
 * 安卓设备的充电器
 */
public class AndroidCharger implements TypeCInterface {
    @Override
    public void chargeWithTypeC() {
        System.out.println("使用Type-C型号的充电器充电...");
    }
}
```

有了安卓充电器和苹果手机。接下来，我们就要定义一个适配器了，希望通过这个适配器，我们可以实现使用安卓设备的充电器给苹果手机充电：

```html
public class Adapter implements LightningInterface {
    private TypeCInterface typeCInterface;

    public Adapter() {
    }

    public Adapter(TypeCInterface typeCInterface) {
        typeCInterface = typeCInterface;
    }

    @Override
    public void chargeWithLightning() {
        typeCInterface.chargeWithTypeC();
    }

    //setter/getter
}
```

这个适配器实现了LightningInterface，并组合了TypeCInterface，当外部调用chargeWithLightning方法的时候，实际上调用的是typeCInterface.chargeWithTypeC方法。

这个例子中，共出现了四种角色：

以上四个角色中，目标抽象类（Lightning接口）、适配者类（安卓充电器）、客户端（苹果手机）都是原来代码中就有的，我们完全不需要对他们进行修改。只需要引入一个适配器（接口转换器）即可。

优缺点

**优点**

适配器模式（对象适配器模式），是一种组合优于集成的思想的实现。通过使用适配器模式，我们可以最大程度的复用已有的了类和代码。他主要有以下有点：

- 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。
- 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。
- 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。

**缺点**

当然，适配器模式并不是完美的，过度使用还是会带来一些问题的。缺点如下：

- 过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。

使用场景

关于适配器模式的使用场景，一般主要是当我们需要修改一些正在运行着的代码，并且希望可以复用原有代码实现新的功能的时候，就要考虑适配器模式。

在Spring框架中，就大量的使用了适配器模式，读者可以打开自己的IDE，尝试着以关键字"Adapter"全局搜索下，一定会有很多的实际应用。

当你遇到的问题，和你想用安卓充电器给苹果手机充电类似的时候，就一定要想到适配器模式哦！