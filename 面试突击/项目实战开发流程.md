# 项目实战开发流程

### 1.软件工程

- 业务调研：主要是完全跟技术无关，站在业务的角度去定义系统要干嘛
  - 组织结构图：部门+岗位
  - 业务流程图：泳道图，一级业务流程+二级业务流程
    - 系统多个模块的整体业务流程
    - 每个模块内部的业务流程
  - 业务表单
  - 业务需求
- 需求分析：站在技术的角度，去分析系统要干嘛
  - 用例图
    - 用例表：用例名称+多个参与者+每个参与者对这个用例做的事情
    - 用例描述+用例流程（泳道图）
    - 用例图：参与者+用例，一个用例就是一个功能需求
    - 用例划分
      - 每个模块都划分出对应的用例来
      - 从业务流程图的运行节点中，抽取用例
  - 领域类图
    - 主要根据业务表单来抽象
  - 非功能需求
    - 物理部署需求
    - 实施需求
    - 易用性需求
    - 性能需求
    - 可靠性需求
- 概要设计：架构师一个人去做的
  - 逻辑架构图：根据需求，画出来逻辑上，系统要长成什么样子
  - 运行架构图：时序图、活动图（可选）、状态图（可选），系统的逻辑架构有了，系统跑起来是什么流程
  - 物理架构图：组件图、配置图，系统长什么样子，系统跑起来流程是什么，系统真正怎么去部署
- 概要设计评审
- 详细设计：下推给项目组里的每个人去做
  - 数据架构图
    - 数据库ER模型图
    - 数据库逻辑设计图
    - 数据库物理设计图
  - 接口设计
  - 开发架构图：实现类图、包图
  - 系统运行流程图（活动图）
  - 测试用例设计
    - 单元测试用例设计
    - 冒烟测试用例设计
  - 日志设计
- 详细设计评审
- 项目管理计划（每个人给出自己的排期计划）
  - 活动图
  - 网络图
  - 进度计划（甘特图）
  - 资源配置
- 工程初始化
  - 每个人本地的开发环境搭建
  - 资源申请：机器、数据库、缓存、MQ，包含了各个环境的资源申请
  - 数据库初始化
  - 代码初始化和上传
- 版本控制
- 编码开发
- 系统测试
  - 单元测试（白盒测试）
  - 冒烟测试
  - 静态代码扫描
  - 代码审查
  - 集成测试（联调测试，也可能是RD自己干，不是QA干）
  - 系统测试（QA去干，黑盒测试）
  - 验收测试（让业务需求方来试用一下，验收一下，一般来说，互联网行业里做验收测试的，一般是产品经理，PM）
- 系统上线
- 系统运维：跟进bug的反馈，排查线上日志，解决bug

### 2.项目管理

软件工程和项目管理，密不可分。

依靠项目管理，对整个项目进行管理和把控，确保说带着一个team可以把你定义好的一整套东西全部做出来。

（1）项目管理：项目管理计划、项目执行和监控、风险管理、变更管理、质量管理（配置管理+测试管理+缺陷管理），5大过程域、9大领域、44个定义。

（2）瀑布式 vs 敏捷式

在一个项目从0到1的时候，采取瀑布式的方式来做，是挺靠谱的。需求变动是比较少的，还没有涉及到终端用户的反馈，其实就是一个初始产品的研发。

但是从1到10的时候，此时系统已经上线了，面向终端用户去使用了，大量的需求迭代，并行的多个项目，直接会喷涌而来，此时瀑布式的方式来做，就不太灵活了，这个时候可能就需要用到敏捷式的开发流程和项目管理。

### 3.开发流程

1.业务调研

产品经理搞明白需求是什么。

2.需求分析

作为架构师，你拿到了一份产品经理给的需求文档之后，这个需求文档里，定义清楚了整体的一个需求，包含系统需要哪些功能模块，整体系统的核心业务流程是什么样子的，还有一些其他的特殊需求。

我们第一件事情，就是要对这份需求文档，进行需求分析。

不是上来就开始进行需求分析了，而是说先去定下来需求分析的规范，怎么进行需求分析。

在规范里，我们是没有包含特定的项目相关的信息的，其实就是一份通用模板，包含了这个需求分析文档要有哪些部分，每个部分要放什么东西。

用例到底是什么？其实很简单，一个用例就是一个功能。

其实用例图怎么画呢？其实就是从我们之前写的那份需求文档里抽取出来的，在需求文档里系统流程中，执行的各种动词，一个动词基本就是这个系统要实现的一个功能，一个动词一般来说就对应着一个用例。

画这个用例图，其实就是要标明，这个系统他到底有哪些功能，这些功能是跟谁相关的。

需求分析，是基于需求文档来的（我们之前产出的那个需求文档），需求分析做完以后，我们应该非常清楚，系统的具体的功能有哪些，每个功能的具体业务流程是什么，系统在运转过程中需要的核心数据是什么（领域类）。

用例图、每个用例的泳道图

3.概要设计

作为架构师，我们自己去设计全局性的技术架构、系统运行流程、物理部署架构。

4.概要设计评审

在完成了概要设计之后，一般会召开这个概要设计的评审。而且可能不只是评审一次，可能会先第一次评审，然后一堆人指出一堆问题，然后负责设计的架构师回去修改，修改完之后，二次评审，可能还是不行，继续回去修改，接着进行三次评审。

每次评审，就是召开一个评审会议，架构师负责在评审会议上讲解自己整个设计方案，一般会邀请级别较高的人出席这个评审会议，来对技术架构进行严格的把关。比如我是一个部门的架构师，我的重要方案评审的时候，可能会找其他部门的架构师过来，帮忙评审。同时也会让项目组内的全体成员都出席，确保每个人都听明白了架构设计，有问题及时抛出，然后讨论。

之所以要评审，是为了保证说，架构师设计出来的架构方案，是比较合理的，而且没有什么明显的缺陷。

这份规范，是约定一下，在评审的时候，负责评审的人，主要从哪些方面去挑剔和挑战负责架构设计的同学，尽量去找出来系统可能存在的漏洞。

5.详细设计

概要设计已经完成，而且通过了评审

（1）逻辑架构 -> 技术架构，已经确定ok了

（2）运行架构 -> 时序图，已经确定ok了，系统跑起来是什么样子的

（3）物理架构 -> 系统开发、测试和线上环境部署的

团队内部每个人认领部分模块或者子系统，然后每个人自己做详细设计。

概要设计主要确定的是架构，详细设计主要确定的是如何去编码实现。

也就是说，一份良好的详细设计文档，写好之后，基本你看着文档，就是傻瓜式的将设计翻译为代码了。

实际上来说，你写代码的过程，就是一个傻瓜式的过程，因为你怎么写这个代码，在详细设计文档里基本都已经定义清楚了。

6.详细设计评审

每个人都完成各自的负责的子系统的详细设计之后，每个人各自要召开自己的详细设计评审会。

这个详细设计的评审，就不是从其他部门请来一些架构师来评审，人家精力有限，不会给你过那么细节的东西，概要设计评审的时候，给你看看主要的架构的设计。

详细设计，就落实到具体的细节的层面，主要是靠架构师来对自己的团队内的各个成员的详细设计来进行评审。

7.工程初始化

每个人本地的开发环境搭建。

资源申请：机器、数据库、缓存、MQ，包含了各个环境的资源申请。

数据库初始化。

代码初始化和上传。

整个软件工程的流程，是环环相扣的，需求分析 -> 概要设计 -> 详细设计 -> 工程初始化。

8.版本控制

版本控制规范是什么意思呢？

这个时候代码还不能开始写，为什么呢？你这个时候不是在瞎写么？每个人用一个分支？每个人用不同的分支？分支与分支之间什么时候集成？怎么集成？在各个环境中流转的时候，分支怎么切换？

版本控制规范

（1）Git工作流，为你的团队和你的项目选择一套合理的Git工作流：分支如何管理，如何合并，分支工作的流程。

（2）在Git工作流之外的一些规范，比如commit的提交规范，每天提交一次？还是按照什么粒度提交一次？commit的时候，写comment的备注的规范是什么？

GitFlow工作流，大家会发现，严格要求版本稳定，一个大版本，一个大版本的往前走。

比较适合系统从0到1的时候。

9.编码开发

编码，可是要规范的啊。

如果编码这块随便瞎编写的话，那就很坑爹，很多人按照自己的风格来写代码，最后出来的这个代码很乱。

一个系统里，感觉不同的人写出来的代码差别很大。

比如有的人，把UserDAO；有的人，是写成UserDao。

还有的人，IUserService；有的人，就是UserService。

如果你没有一套统一的编码规范的话，会导致不同的人出来的这个代码看起来差别很大，增加以后的代码的维护成本。

别人要来读懂你的代码，要来维护和修改的话，会导致无所适从。

一般来说，正经的公司，对编码规范这块，需要两个东西，第一个东西，是说约定好编码按照什么样的一整套的规范来；第二个东西，是说后面你需要有一个机制来确保每个人都是按照这个规范来走的。

在以前很早的时候，编码规范是有的，然后靠哪个环节来控制编码规范呢？靠的是code review，代码审查，别人在你写好代码之后，来阅读你的代码，如果有发现没有按照编码规范来的情况，告诉你，让你来修改代码。这个方式有很大的弊端，首先就是靠人力一点一点去审查代码，看有没有按照标准来写代码，会耗费很大的人力成本。另外一个，靠人力来审查，很可能会漏掉一些问题，不一定能做到百分之百的准确。

比较好的一件事情，到我们今天为止，正好，就是有个比较大的福音，阿里发布了自己的一个Java开发手册。就是比较标准和完善的一份Java开发手册，基本上都是比较核心的，和重要的一些规范。如果规范写得太多太细了，没有人能记得住的。编码规范，就是提取比较重要的一些规范，精简，让人可以记住，可以按照这个去做就ok了。

直接采用阿里巴巴的java开发规范手册就可以了 。

阿里还有一点比较好，就是他们出版了对应这个java开发手册的一个静态代码扫描的插件，跟eclipse，IntelliJ IDEA整合起来。

我们就是需要熟悉一下阿里的java规范手册，写代码按照这个来；写完代码之后，用静态代码扫描插件，扫描一下我们的代码，它会按照它预定义的规则，去检查代码，如果有不符合标准的地方，然后按照插件给出的建议来修改即可。

我们基于这个蓝本去修改一下，简化一下，形成我们自己的一个word版本的一个文档。

10.系统测试

1. 单元测试（白盒测试）
2. 冒烟测试
3. 静态代码扫描
4. 代码审查
5. 集成测试（联调测试，也可能是RD自己干，不是QA干）
6. 系统测试（QA去干，黑盒测试）
7. 验收测试（让业务需求方来试用一下，验收一下，一般来说，互联网行业里做验收测试的，一般是产品经理，PM）

11.系统上线

12.线上运维

### 4.项目管理

1.项目管理计划

项目管理计划：就是在完成所有的技术设计之后，我们已经知道要怎么做这个系统了。但是现在的问题在于说，按照什么样的节奏、步骤和进度去完成所有的开发、测试以及上线的工作呢？

在概要设计+详细设计都搞定之后，会有一个步骤，叫做排期。

每个人给出自己的排期，所有人的排期合并在一起，组成项目的一个完整的排期。就是每个人对自己负责的那个部分，给出来每个环节/功能要做完，需要花费多少时间，需要从几号到几号去做。然后的话呢，项目的总负责人，大R，就会按照这份排期去跟进和管理项目组的开发，直到最后确保项目的上线。

制定下来一套初步的立刻可以落地执行和实施的项目管理的规范，按照这套规范去执行整个项目的管理。

2.项目监控

项目中可能有很多个人，很多种角色，可能项目组里有4个人，5个人，10个人，20人，30人，50人。100人的大团队协同作战。

如果你只是定好了项目的管理计划，而没有做任何的项目执行的进度把控，那么其实那个计划，正常来说，就会流于形式和表面。设想一个场景，假设你把项目进度计划做的很棒，很好了，这份项目计划直接发下去。然后接下来你就不管了，你可以想象一下，项目会干成什么样子？两个问题，一定是人都是有惰性的，这个是人性，不是说一个人是好人，还是坏人，就是只要没有监督和管理，人一定是会或多或少有惰性的。哪怕是一个靠谱的人，在没有监管的情况下，惰性一旦发生，就可能会导致什么呢？

项目执行的监控和把控

如果不进行严格、科学以及良好的项目执行的监控，可能就会发生各种各样想不到的情况跟，到每周看一下进度的时候，各种delay，各种延期，各种没做完，找了一大堆的借口出来，死猪不怕开水烫的样子。项目就濒临崩溃。。。。

不是这个人有惰性，这个人，他可能是能力不够，做事情的过程中，一定是会遇到这样那样的一些困难、挑战以及问题的，自己没法解决，然后你又没有及时关注，最后直接导致这个人的工作delay。长此以往，项目崩溃。。。。

项目崩溃，本来预定的是6月5号上线，结果，6月12号，6月20号，7月1号。整整延期了1个月，一个10人的团队，每个人平均年薪24万。平均月薪2万。每个月公司的工资的成本就是20万。也就是说，项目胡乱管理，团队战斗力太差，项目每次延期一个月，给公司空耗20万的资金。

带两个同学，一块儿去做一个项目。性格上都有问题，计划的时候，颗粒度太粗了；拉不下面子去每天监控每个人的执行进度；有些人还有脾气，反正当时定的是5天干完一个事儿，那我就5天之内干完这个事儿不就得了。你干嘛每天来东厂太监一样来监视我，硬逼着我每天必须干完什么事情。歪理，项目，是一个变动性很高的事情，做的过程中，可能会有各种各样的一些变化，每天卡着进度是不合理的。

那个项目就失败了，原本预定是在8月底上线，结果一直拖拖拖拖到了10月底才上线，延期2个月，失败的项目管理的例子。

3.项目风险管理

4.项目变更管理

# 需求评审规范

### 1.需求评审规范

1、需求是否足够清晰

要判断这个需求，你看了以后，是否脑子里能完全展现出来整体的图，就是包括界面是怎么操作的，在界面上用户的操作流程是什么样子的？每一步操作，要显示什么表单、什么表格？查询条件的默认值？是否要分页？

原则，你必须要看了需求以后，脑子里直接出来一个产品的界面操作图，然后后台系统的一些流程，在你架构师的脑子里，基本都出来了。

2、对需求中不合理的地方提出改进建议

查询菜单，是默认就查询两级，或者是三级，但是我们考虑到了可能有的菜单是三级的，你要是就查询两级，就不对了。产品设计就错了。

思考说，按照这个需求去走，以后一些特殊的场景，会否导致需求和系统开发要全盘推翻，重新去做。需求流程是否合理。

3、对不需要做的需求提议砍掉

有些需求，在当前这个版本特殊的背景下，可能是不需要的，我们要去考虑说，是否建议放到下一个版本去做。我们有权利提议砍掉一些需求，集中力量干大事儿。

# 系统开发规范

## 系统开发流程

### 1.系统开发流程

（1）业务调研：产品经理搞明白需求是什么。

（2）需求分析：我们去分析产品经理给的需求文档，梳理出系统要干嘛。

（3）概要设计：作为架构师，我们自己去设计全局性的技术架构、系统运行流程、物理部署架构。

（4）概要设计评审：找其他部门的架构师来帮忙评审一下我们的架构方案。

（5）详细设计：指导团队里的各个同学，自己对自己负责的部分进行详细设计，数据库建模、接口设计、类设计、包设计、功能流程设计、单元测试设计、冒烟测试设计、日志设计。

（6）详细设计评审：我们作为架构师要仔细去看一下各个同学的详细设计，确保没问题。

（7）工程初始化：指派多个同学，完成所有的初始化的一些事情。

（8）版本控制：明确如何对代码进行版本控制，工作流是什么。

（9）编码开发：根据阿里的开发规范，写代码即可。

（10）单元测试：自己写所有的单元测试，测试每一个类。

（11）冒烟测试：自己对负责的系统跑起来，冒烟测一下核心功能。

（12）静态代码扫描：确保自己的代码符合规范。

（13）单元测试覆盖率报告：跑出来自己写的那些单元测试，覆盖了百分之多少的代码

（14）代码审查：由高级别的人去审查自己的代码

（15）集成测试：所有环节集成在一起，确保系统整体流程炮通

（16）系统测试：QA来严格测试每个功能

（17）验收测试：PM验收系统

（18）系统上线：按照严格的步骤去执行上线 （19）线上运维：按照标准化的流程去处理线上的bug

## 需求分析规范

### 1.需求分析规范

需求分析，是基于需求文档来的（我们之前产出的那个需求文档），需求分析做完以后，我们应该非常清楚，系统的具体的功能有哪些，每个功能的具体业务流程是什么，系统在运转过程中需要的核心数据是什么（领域类）。

1.1编写目的

表明这份需求分析文档的核心目的是什么，比如说是用来定义系统的核心功能的，指导后续的系统设计的。

1.2面向对象

该文档编写出来之后，是要给谁看的？其实主要是给RD看的，让工程师明白系统要做哪些东西。

2.1开发意图

描述清楚咱们这个系统开发出来是用来干嘛的，主要的作用是什么。

2.2功能结构图

2.3 功能简介

2.3.1XX子系统

XX子系统主要是用来干什么的。

2.3.1.1模块1

模块1主要是用来干什么的。

（1）功能1

功能1是用来干什么的。

3.用例图

3.1XX子系统

每个子系统是一张用例图，一张用例图中包含了很多个用例。

3.1.1 功能概述

说一下XX子系统的功能大概是干嘛的，这里可以说一下，这个子系统是干嘛的，里面包含了哪些模块。

3.1.2 用例图

3.1.3 用例描述

3.1.3.1 用例1描述

（1）简要说明

这个用例对应的功能是干嘛的。

比如说，新建订单用例主要是用户在购物车中，可以对要下单的商品进行选择，同时选择要使用的优惠，在订单计算出来金额之后，确定提交订单。

（2）事件流

在执行这个用例的时候，需要执行哪些操作和步骤。

步骤1：选择要订购的商品。

步骤2：对商品的库存进行校验。

步骤3：选择这个订单要使用的优惠是什么。

步骤4：计算出来订单的最终金额。

步骤5：点击确认提交订单。

步骤6：生成订单。

（3）事件流图（processon画泳道图）

将上面写好的事件流画成事件流图，一般用泳道图来表示。

4、领域类图

领域类图，一般就是从系统间的调用和流转，使用的核心数据类。

订单类，就是一个典型的领域类。

一般来说，领域类如何抽象，其实就是将需求文档中比较核心的那些数据抽象成领域类，比如订单，库存调拨单，出库单，入库单。

这边是可以将一个较为复杂的领域类图拆分为多个领域类，比如说订单主信息，订单项信息，订单优惠信息。

4.1 XX子系统

4.1.1 领域类1

## 系统设计规范

### 5.概要设计规范

1.1 编写目的

1.2 面向对象

1.3 参考文档

2、逻辑架构

采用技术栈架构，包含业务架构，以及系统整体技术架构。

2.1 逻辑架构图

没有固定的格式，将整体技术架构画清楚即可。

2.2 设计细节

对架构设计中各个环节进行文字说明。

3、运行架构

3.1 系统核心流程时序图

将系统整体的各个核心流程的时序图画出来，子系统之间的交互就很清楚了，要求粒度到每一个用例级别，每个子系统的用例都要在时序图上有所体现。

整体的一个思路是什么呢？将系统的所有核心流程，一个一个的在这里用时序图表现出来，这个图里就涉及到了各个子系统在核心流程中会干什么，会负责什么事情，如何将多个子系统串联起来实现整个电商的一个核心的业务流程。

生命线、激活、消息。

3.1.1 系统核心流程1时序图

3.2 XX子系统

3.2.1 XX模块

3.2.1.1 XX功能1时序图

对上面的核心流程时序图中的每个用例，都画出来具体的每个用例的时序图。

4、物理架构

4.1 软件架构（组件图）

子系统以及各个基础设施的交互。

4.2 硬件架构（配置图）

具体的各个环境的系统以及基础设施的物理部署。

4.2.1 开发环境硬件架构

4.2.2 集成测试环境的硬件架构

4.2.3 系统测试环境的硬件架构

4.2.4 验收测试环境的硬件架构

4.2.5 线上环境的硬件架构

### 6.概要设计评审规范

1、要评审的一些点

负责评审的同学，需要对架构设计方案，从以下的角度考虑：

（1）并发性：考量一下，现有的系统架构，能支撑多高的并发，如果说未来并发持续上升的话，这套架构会不会扛不住。

（2）伸缩性：考量一下，如果未来系统架构撑不住并发量了 ，现有的这套系统架构，是否是可伸缩的，就是能否在需要的时候，通过加机器，扩容，来增强它能抗住的并发量。

（3）可用性：现有的这套系统架构，是否可能会出现不可用的情况，比如说某个外部依赖挂掉了，或者是流量激增，等等，会不会有哪些情况导致系统跨掉了。

（4）扩展性：如果后续要对系统进行大量的迭代，快速的业务需求开发，大量的代码改动，现有的这套架构，能否支撑系统快速扩展。

（5）安全性：现有系统架构，存在了哪些安全性的漏洞，是否可能被攻击，导致系统挂掉，是否可能导致系统的数据丢失。

（6）性能：现有的系统架构，是否会在哪些地方出现性能的瓶颈，或者性能较差的一些情况。

（7）稳定性：现有系统是否考虑到了日志、监控、线上问题的快速排查和处理、系统功能运转的一个稳定性。

2、要重点评审哪个部分

概要设计文档里面，逻辑架构、运行架构、物理架构。

重点要考虑的，就是这个逻辑架构，因为这个逻辑架构就体现了所有的一切技术性的东西和设计。

要考虑一下，逻辑架构体现的技术架构中，是否有哪些缺陷和漏洞。

3、设计评审的记录

### 7.详细设计规范

1、数据架构设计

1.1 数据库ER模型图

PowerDesigner ER建模。

数据库的ER建模，ER，Entity Relationship，实体关系，一个表就是一个实体，设计表与表之间的一个关系，也就是实体与实体之间的一个关系。

包括每个实体包含哪些属性，表包含了哪些字段。

一般就是根据需求分析以及概要设计中的内容来考量，就是说负责的这个模块，具体需要哪些数据库表去承载，才能实现出来。

将所有需要的表，全部在一张ER模型图中体现出来

1.2 数据库逻辑设计

PowerDesigner将ER模型转为逻辑模型。

1.2 数据库物理设计

PowerDesigner将逻辑模型转为物理模型 。

2、接口设计

2.1 XX模块

2.1.1 XX接口

（1）接口类

（2）接口方法名称

（3）接口描述

（4）输入

（5）输出

3、开发架构设计

3.1 实现类图设计

根据之前的需求分析文档、概要设计文档、数据库模型、接口，去考虑，实现接口的功能，需要哪些类，类与类之间的关系是什么，每个类有哪些成员变量，每个类有哪些方法。

在这里说明一点，这里其实就是所谓的Java面向对象编程的核心所在，这里其实是很体现一个工程师的水平的。

UML的类图里，其实就三点。

（1）把每个类都画出来

（2）类与类之间的继承关系画出来，实线+空心箭头

（3）接口实线关系，虚线+空心箭头

（4）依赖关系，虚线+简单箭头

（5）关联关系，实线+简单箭头

（6）组合关系，实心菱形+实线+简单箭头

（7）聚合关系，空心菱形+实线+简单箭头

3.2 包设计

在UML中有包图的概念，我在这里先补讲，我比较少用 。

至少你要设计出来，你有哪些包，每个包下面有哪些类。

com.zhss.eshop.order.domain

com.zhss.eshop.order.controller

com.zhss.eshop.order.mapper

com.zhss.eshop.order.dao

com.zhss.eshop.order.service

4、运行流程设计（活动图）

4.1 XX模块

4.1.1 XX功能1

每一个功能，参考之前概要设计中的每个功能的用例图，类图、数据库表，画出来这个活动图。

用例图，基本上还是重点在体现较为高层的系统功能的运行流程。

活动图，就要画出来，每个类和每个表之间的交互关系，完整体现出来你的功能要实现的时候，各个类以及表之间的交互顺序和逻辑。

4.1.2 XX功能2

5、测试用例设计

5.1 单元测试用例设计

5.1.1 XX模块

5.1.1.1 测试用例1

对每个类设计对应的单元测试类，每个方法都要有单元测试的方法。

（1）数据准备

（2）输入

（3）输出

（3）资源清理

5.1.1.2 测试用例2

5.2 冒烟测试用例设计

5.2.1 XX模块

5.2.1.1 测试用例1

（1）数据准备

（2）输入

（3）输出

（3）资源清理

5.2.1.2 测试用例2

6、日志设计

6.1 XX模块

6.1.1 XX功能

（1）日志埋点1

（2）日志埋点2

### 8.详细设计评审规范

每个人都完成各自的负责的子系统的详细设计之后，每个人各自要召开自己的详细设计评审会。

这个详细设计的评审，就不是从其他部门请来一些架构师来评审，人家精力有限，不会给你过那么细节的东西，概要设计评审的时候，给你看看主要的架构的设计。

详细设计，就落实到具体的细节的层面，主要是靠架构师来对自己的团队内的各个成员的详细设计来进行评审。

1、数据库设计的评审

重点关注一下数据库设计的索引，索引要确保说未来系统中已有的和可能有的各种功能，都可以用到索引，不会出现全表扫描的情况。

索引设计要好好结合业务需求，去考虑如何建联合索引。

2、接口设计的评审

主要是要调用这个人的接口的调用方，要好好仔细看一下接口设计，确认一下接口设计能否满足自己的需求。

3、开发架构的评审

面向对象的类图的设计，好好考虑一下，面向对象做的怎么样，是否逻辑清晰，拆分合理，未来的可扩展性是否足够好。

设计模式，就体现在这里了，就类图设计里，看看有没有用合理的良好的设计模式，来进行面向对象的设计，保障代码有足够好的扩展性。

4、活动图的评审

仔细过一下，看看每个功能的活动图，里面逻辑是否准确。

5、测试用例的评审

这块需要好好看一下，是否对每个类的每个方法都设计了单元测试。

6、日志的评审

这块也要好好看一下，对系统各个可能出异常的地方，是否打印了异常日志以及案发现场的保护日志。

## 工程初始化规范

### 9.工程初始化

1.每个人本地的开发环境搭建

2.资源申请：机器、数据库、缓存、MQ，包含了各个环境的资源申请

3.数据库初始化

4.代码初始化和上传

实际上在做各种不同的项目的时候，根据你用到的技术不同，可能你需要进行的工程初始化的步骤都是不一样的。

整个软件工程的流程，是环环相扣的，需求分析 -> 概要设计 -> 详细设计 -> 工程初始化。

### 10.工程初始化规范

1、每个人本地搭建好开发环境

（1）JDK

（2）开发IDE：eclipse、IntelliJ IDEA

（3）maven：配置nexus私服的地址，settings.xml

（4）git

2、完成资源申请

对你的技术架构中，所有需要使用的技术相关的资源进行申请。

如果是在大公司里面：需要跟对应的dba、redis运维团队、RabbitMQ运维团队，申请你需要使用的数据库、redis集群、RabbitMQ资源。

还有你的java服务需要部署的机器资源，也需要跟SRE（运维团队）来申请。

而且要申请好所有环境的资源。

（1）开发环境（dev）：在这个环境中，部署需要使用的mysql、redis、rabbitmq，等等，然后各个开发人员在自己本地，是直接连接统一的一个开发环境中的数据库、缓存、mq，来进行开发和测试的。单元测试，不跟外部依赖的基础设施打交道的；但是在本地冒烟测试，是需要将自己负责的程序跑起来，跟开发环境中的基础设施交互，确保主流程没问题。

（2）集成测试环境（beta）：在这个环境中，其实就是所有人对一个版本都开发好之后，需要进行联调，系统集成。将所有人负责的东西全部集成到一起，如果是单块应用，将每个人的代码分支全部集成到一个统一的分支上去，将那个分支上集成好的代码，部署到集成测试环境的机器上去，同时连的是集成测试环境中的数据库、缓存、MQ。集成测试，部署好之后，由QA来执行，有时候RD自己来做，要将整个系统的所有部分集成在一起，主流程，主功能，跑通。

（3）系统测试环境（test）：在这个环境中，同样，是需要将集成好的代码，部署到系统测试环境中的机器上去，同时连的是系统测试环境中的数据库、缓存、MQ。主要就是测试工程师，QA介入，进行黑盒测试，他们会写各种测试用例，非常非常的细，这一步重点是测试系统的所有功能包括各个细节点，全部都正确。

（4）验收测试环境（staging）：在这个环境中，尽量保证跟线上环境一致的情况。比如说mysql，主从架构；开发环境、集成测试环境、系统测试环境里，可能就是单实例mysql；在验收测试环境中，就需要根线上尽量保持一致，必然线上规划的是mysql一主三从的架构，在staging环境，可以简化为一主一从。在这一步的重点意义是，模拟线上环境，甚至有时候会将部分线上环境的数据，或者是请求流量，导入到这个环境中来。这一步重点是需求方来做验收，比如说产品经理，准备好一堆测试用例，在这个环境去使用你的系统，看是否正确。

（5）线上环境（prod）：线上环境，所有的基础设施全部按照规划好的线上环境配置来走

可以看一下，这里各个环境的资源怎么申请，申请多少，怎么部署，是根据什么来的？

概要设计里面的物理架构：配置图，硬件层面去考虑，需要哪些机器，部署哪些基础设施，多少台机器，多少个集群，跨几个机房。

3、数据库初始化

基于详细设计中的数据库建模，PowerDesigner，里面设计好了各种物理表结构，导出来一份SQL文件。

直接基于那份SQL文件，在开发环境中的数据库里，建好需要的库，初始化好所有的表结构。

4、 工程搭建

一般会指定一个人，架构师，也可能是项目组中的其他人。

负责在自己本地的IDE中，建立好一个工程，对这个工程中完成系统需要的技术框架的整合（Spring Boot + Spring MVC + Spring + MyBatis）。

（1）maven的pom.xml中，引入所有的依赖。

（2）对所有需要使用的技术，完成对应的配置，注解 / xml。

（3）其他的工程结构，完成搭建：maven父子工程，maven pom.xml中配置跟nexus集成、用来打包的插件、用于单元测试的依赖、数据库连接池的依赖。

（4）本地写一个最基本的测试代码，将框架技术的整合全部跑通：接收http请求 -> 插入数据库，读写redis，读写rabbitmq，单元测试，日志的本地打印。

5、代码上传到仓库

负责搭建工程的那个哥儿们，将搭建好的工程代码，上传到GitLab的仓库中去 。

项目组中其他的同学，就需要从GitLab中拉取代码下来，到自己本地，代码导入IDE中。

将负责搭建工程的那个哥儿们写好的那套测试代码，在本地运行一下，确保说，所有技术的整合以及运行全部能跑通。

## 版本控制规范

### 11.版本控制规范

（1）Git工作流，为你的团队和你的项目选择一套合理的Git工作流：分支如何管理，如何合并，分支工作的流程。

（2）在Git工作流之外的一些规范，比如commit的提交规范，每天提交一次？还是按照什么粒度提交一次？commit的时候，写comment的备注的规范是什么？

GitFlow工作流，大家会发现，严格要求版本稳定，一个大版本，一个大版本的往前走。

比较适合系统从0到1的时候。

1、Git工作流

初步定的是基于GitFlow工作流来做。

（1）feature分支

进入一个版本的开发之后，每个人自己拉对应的feature分支。feature分支的拉取，按照一个子系统一个feature分支；一个模块一个feature分支；一个需求一个feature分支；一个功能一个feature分支。不是固定死的，是根据当时的人力的任务分配情况，来定，怎么划分这个feature分支。

比如说我们现在，假设电商v1.0版本要做15个子系统，1+4的小team，一个架构师带4个初中级工程师。平均每个人分配到的是3个子系统。每个子系统拉一个feature分支，在那个子系统上，就专门开发需要的代码就可以了。

就是在上一讲，说工程初始化的时候，负责工程搭建的同学，就将所有系统中需要的接口全部定义出来。

这样的话，每个人拉出来的featiure分支，自己仅仅写这个feature中需要的代码，但是如果你的feature中依赖了别人的子系统feature中的接口，没关系，一开始，所有的接口都定义好了。大家都面向接口开发就可以了。写单元测试的时候，对别人的接口实现，采取mock的方式来做。

每个人拉自己的feature分支，然后写自己的feature里的代码，对依赖别人的地方，面向接口编程。

feature的命名规范：feature/order-system-v1.0。

（2）develop分支

在上一讲，讲到代码初始化好之后，实际上代码是在master分支去初始化的。就直接从master分支拉一个develop分支出来，做为统一的代码集成的分支。

每个人的feature分支开发好之火，就每个人依次将自己的feature分支的代码，合并到develop分支，进行代码集成。所有人的代码，就在develop分支上，完成了集成，develop分支，就包含了系统这个版本需要的所有代码。

就可以基于develop分支的代码，去集成测试环境来部署，然后进行集成测试。

集成测试的过程中，肯定是会不断的发现一些bug的，如何来修复bug呢？在什么分支上来修复bug？

一般来说，在集成测试环境，如果发现了这个bug的话，一般来说，对应有bug的同学，需要在自己的本地来复现这个bug。

这里，推荐说直接基于develop分支的代码来复现和修复bug，因为feature分支的代码是不完整的，可能是没法复现bug的，所以是不能通过feature分支的代码来复现和修复bug的。

负责修复bug的同学，将develop分支的代码拉到自己本地，本地跑起来，基于开发环境的基础设施，应该在自己本地是可以跑起来的。复现bug，追查bug产生的原因，然后可以直接在develop分支上来修复这个bug。

push develop分支的修改到GitLab上，然后所有人就基于最新的develop分支继续进行测试。

直到develop分支测试，感觉都保持稳定了，已经没有什么bug了，系统整体可以跑通，此时集成测试就结束了。

（3）release分支

针对当前这个整体的版本，来从develop分支拉一个release分支出来，命名规范就是release/v1.0.0。

然后就可以基于release分支进行系统测试了，QA同学介入，对于release分支部署的环境，进行功能测试，确保所有的功能都是ok的。

如果此时发现有bug，同理，大家直接在release分支上去修复bug，包括在本地基于release分支代码复现bug，以及修复bug。

release分支如果测试到后面，稳定了，功能都ok了，测试结束了。

此时需要将release分支的代码合并到master分支上，同时将release分支的代码合并到develop分支上。

（4）master分支

在最一开始，工程初始化的时候，就是基于master分支去初始化的。

这边的话呢，每个版本的release分支都测试完之后，就可以将代码合并到master分支上来。此时master分支上的代码是经过了严格的测试的，单元测试、冒烟测试、集成测试、系统测试。

接下来，就是要进行验收测试了。

直接基于master分支的代码，部署到staging验收测试环境上去，在这个环境上，由PM来进行所有功能的验收。

一般来说，99%的情况，验收测试环节，就不应该有bug了，让需求方体验一把整体的流程，在上线之前，做最后一轮check。

如果这里发现了bug，那么在release分支上来复现这个bug，然后在release分支上来修改这个bug。

bug修复之后，QA会在release分支和系统测试环境中，来验证说bug修复了，然后还会再做一遍回归测试。

release分支分别合并到master分支和develop分支上去。

验收测试通过之后，对master分支来打tag，比如货v1.0.0，打完tag之后，基于这个tag的代码，来进行线上系统的部署。

（5）bugfix分支

线上发现了bug，而且判断这个bug的修复要超过1天的时间，那么需要从master分支拉一个bugfix分支下来，命名规范是bugfix/xx_bug。

在自己本地复现这个bug，基于bugfix分支上的代码，在自己本地来修复。

修复好bug之后，将bugfix分支的代码，合并一份到develop分支上去，然后让QA在集成测试环境，来初步验证一下说是ok的。

然后将bugfix的代码合并到master分支上去，将master分支代码在验收测试环境部署一下，让PM验证一下，bugfix是ok的。

给master分支打一个tag，再次将修复好bug的代码给上线。

（6）hotfix分支

线上发现了一个bug，很紧急，要在1天之内必须修复，哪怕加班到凌晨3也得修复，整体流程跟bugfix分支一样。

命名规范是hotfix/xx_bug。

（7）分支清理

在一个大的版本最终完成上线之后，需要将这个版本对应的一些分支清理掉，比如说feature分支、release分支，需要删除掉。

在修复好一个bug上线之后，需要将bugfix分支、hotfix分支，删除掉。

2、commit规范

在各个分支上开发的时候，git最基本的就是git commit，git push。

git commit，是可以随便瞎commit的吗？每次commit的规范是什么？

（1）commit的时机：在feature分支上，一般建议，是每天提交一个commit；在release分支上，每次修复好一个bug，提交一个commit；在develop分支上，每次修复好一个bug，提交一个commit；bugfix分支，修复好bug之后，提交一个commit。

（2）commit comment的规范

标题：简短的说明了，你这次commit是干了什么，一般就是几十个字，不超过一行。

本次提交的代码改动列表：

1.完成UserServiceImpl的编写，完成了用户增删改查的功能实现。

2.完成UserMapper的编写，完成了用户增删改查的数据库操作逻辑的实现。

3.

4.

## 编码开发规范

### 12.编码开发

一般来说，正经的公司，对编码规范这块，需要两个东西，第一个东西，是说约定好编码按照什么样的一整套的规范来；第二个东西，是说后面你需要有一个机制来确保每个人都是按照这个规范来走的。

阿里发布了自己的一个Java开发手册。就是比较标准和完善的一份Java开发手册，基本上都是比较核心的，和重要的一些规范。如果规范写得太多太细了，没有人能记得住的。编码规范，就是提取比较重要的一些规范，精简，让人可以记住，可以按照这个去做就ok了。

直接采用阿里巴巴的java开发规范手册就可以了。

还有一点比较好，就是他们出版了对应这个java开发手册的一个静态代码扫描的插件，跟eclipse，IntelliJ IDEA整合起来。

我们就是需要熟悉一下阿里的java规范手册，写代码按照这个来；写完代码之后，用静态代码扫描插件，扫描一下我们的代码，它会按照它预定义的规则，去检查代码，如果有不符合标准的地方，然后按照插件给出的建议来修改即可。

## 系统测试规范

### 13.系统测试

1.单元测试（白盒测试）

2.冒烟测试

3.静态代码扫描

4.代码审查

5.集成测试（联调测试，也可能是RD自己干，不是QA干）

6.系统测试（QA去干，黑盒测试）

7.验收测试（让业务需求方来试用一下，验收一下，一般来说，互联网行业里做验收测试的，一般是产品经理，PM）

首先先给大家说一下基本的测试的流程，当然这个测试流程不是最最完整的，而且不同的领域的项目，测试流程也不是完全一样的。

传统IT行业的java系统的测试，ERP、CRM系统 -> 互联网行业的app后端的高并发后台系统的测试 -> 大数据领域的海量数据计算的数据类java系统的测试。

测试的种类和步骤会不断丰富，越来越多。比如说，并发越来越高了以后，需要有吞吐量测试、性能测试；有了高可用架构以后，还要有可用性测试，故障演练；数据量很大，可能还会有数据准确性的测试。

最最经典和传统的测试模型

金字塔形状的测试模型

### 14.单元测试规范

1、单元测试

针对的是代码中的每个类，一个类认为是一个代码组件，对每个代码组件都编写一个单元测试类。这个单元测试类中会有多个方法，通常至少对要测试的类中的每个方法都编写一个对应的测试方法。

单元测试，面向的是代码组件的级别，它是最小最细粒度的测试单元。

通常而言，通过单元测试检查出来的bug是最多的，所以它是位于测试金字塔模型的最底端。

单元测试，需要每个RD对自己编写的代码自己去写单元测试，一般是使用JUnit框架，如果你使用了一些其他的框架，Spring，Spring MVC，都有对应的跟JUnit整合起来进行单元测试的一些框架，逻辑判断的Hamcrest框架，mock对象的Mockito框架。

初步的一些规范：

（1）单元测试类，必须以test来结尾，以要测试的类来打头。

（2）针对每个类，一般都要写一个单元测试类来进行测试。

（3）单元测试中的每个方法，针对的是被测试类中的每个方法，方法以test打头，跟上要测试的方法名称。

重要的原则：单元测试中，你测试一个类，就只能针对这一个类中的代码来进行测试。如果这个类依赖了其他的类，必须用测试替身将依赖的类和要测试的类隔离开来。为什么呢？记住，单元测试是什么，单元测试其实是最小的测试单位，一个单元测试类就负责测试一个代码组件（一个类），如果这个类依赖了其他的类。那么你就自己模拟一些测试替身，注入到要测试的类中去，将要测试的类和依赖的类隔离开来。

避免说，要测试的类和依赖的类耦合在一起测试，互相如果有bug会互相影响 。

重要原则：单元测试绝对不能依赖任何的外部基础设施，比如说mysql、redis、rabbitmq，绝对不能依赖这些东西来写单元测试。如果要依赖的话，直接注入测试替身，用模拟的行为来替代掉。

重要规范：单元测试覆盖率，要保证你写的单元测试覆盖了足够多的代码，保证覆盖的代码至少达到70%，对核心模块的代码要覆盖100%。

一个好的单元测试要符合的一个规范和规则。

- 什么是单元测试？
  - 直接裸奔不写单元测试的弊端
    - 如果裸奔不写单元测试的话，就直接意味着，这个RD根本就没有对自己编写的代码负责
    - 最基本的单元测试都没有，凭什么让人相信你的代码是经过测试的呢？
  - 写更多的单元测试对代码质量提高的稳定曲线
  - 写更多的单元测试对代码设计质量提高的稳定曲线
- 优秀的单元测试有哪些特质？
  - 可读性
  - 良好的测试代码结构
  - 精准的测试名称
  - 测试代码的可重复性
  - 自动化单元测试的3大工具
    - 测试框架：JUnit来测试，加上其他一些辅助性质的测试框架
    - 运行单元测试的自动化构建：基于maven的插件，mvn test，自动把所有的单元测试都自动化跑一遍
    - 测试替身：主要使用的是Mockito框架，模拟出来各种各样实现某个接口的类，每个方法的模拟的行为是什么
- 测试替身
  - 测试替身的几大作用
    - 隔离要测试的代码组件：将测试替身对象传入要测试的组件
    - 加快测试执行速度：替换复杂耗时的代码执行
      - 有的时候会有这样的一种情况，比如你要测试的是类A，类A依赖了类B，类B中的代码非常复杂，执行了大量的数据库读写操作
      - 导致类B的那个方法跑起来是很慢的
      - 就是用测试替身代替类B，将类B中的方法实现为非常简单的一些打印日志的模拟的实现就可以了，因为我们重点要测试的是类A，不是类B
      - 测试替身的一个效果，就是可以加速类A中的方法的执行速度，也就可以加快我们的单元测试运行的速度
    - 让代码行为变得足够稳定：将随机行为改为固定行为
      - 类A依赖了类B，类B中会随机生成一个随机数，根据随机数来执行一些行为
      - 这就会导致类A每次调用类B，执行的结果是随机的，不够稳定
      - 用测试替身替代掉类B，每次调用就是返回一个固定的值，就可以了，让代码行为变得足够稳定
      - 就能保证我们的单元测试每次都是稳定运行的
    - 模拟特殊的异常情况：主动抛出网络调用异常
      - 类A依赖了类B，现在需要测试的是，如果类B的方法抛出了异常，类A捕捉到异常之后，能否正常执行类A中的catch中的代码逻辑
      - 此时可以用测试替身替代掉类B，让类B中的方法就固定抛出一个异常
    - 访问私有数据：测试后获取依赖组件的内部私有数据来断言
      - 类A依赖了类B，现在测试是要看那一下，类A调用了类B之后，类B中的部分变量是否改变为了我们期望的一个值
      - 此时就可以用测试替身来替代掉这个类B，在里面增加捕获变量改变历史的一些数据
      - 最后测试完了以后，我们就可以看一下是否符合期望
  - 测试替身的几种类型
    - 测试桩：stub
      - 最简单的测试替身
      - 一般就是用一两行代码模拟行为
      - 比如日志记录组件，可以用测试桩来替代
    - 伪造对象：fake
      - 相对复杂一些的情况，需要使用伪造对象来模拟真实场景
      - 比如DAO组件可以用fake对象
      - 使用内存数据库来实现数据的增删改查
    - 测试间谍：spy
      - 要检查依赖组件的行为，是无法直接断言的，需要使用spy
      - 将依赖组件做成spy，对方法调用可以保存数据
      - 对测试组件执行完之后，对spy保存的数据进行断言
    - 模拟对象：mock
      - mock对象，指定某个参数传入时返回什么结果
      - 使用mock对象可以模拟任意复杂度的依赖代码组件
  - 测试替身的使用规则
    - 如何选择测试替身
      - 操作行为用mock对象
      - 查询行为用stub对象
      - 复杂的一套业务逻辑用fake对象
      - 无法断言返回结果用spy对象
    - 单元测试编写范式：准备、执行、断言
    - 测试框架：JUnit+Mockito+Hamcrest
      - 单元测试主要用JUnit
      - 用Mockito来模拟4种测试替身
      - 用Hamcrest来配合assertThat断言
- 单元测试的反面教材
  - 可读性较差
    - 基本断言：断言时用了算数运算符，让人看不懂
      - assertTrue(a > 100)
      - assertThat(a, greaterThan(100))，Hamcrest框架
    - 过度断言：对大量的代码逻辑的执行结果进行一次断言，出问题不好排查
      - 一次性对多个方法进行了测试和断言
      - 要将对多个方法的测试拆分到不同的测试方法中，尽量降低测试的粒度
    - 位断言：断言时使用了按位与等特殊操作符号，让人看不懂
      - 在写单元测试的时候，不要使用位运算符，比如说<<，>>
    - 人格分裂：将较为复杂的多个不同类别的逻辑放在一个测试类里
      - 在一个测试类中，对多个不同的类，或者一个类中多种不同的负责逻辑进行测试
      - 可以尝试将过于复杂的测试逻辑拆分到不同的测试类中去
    - 逻辑分割：测试代码依赖了外部文件中的内容，很难查看
      - 测试代码里面，使用了外部的一个文件，比如说a.txt，或者b.csv
      - 尽量用内嵌在代码中的文本去替代外部的文件
      - 保证说所有的内容都在单元测试中
    - 魔法数字：断言时用了magic number，让人看不懂
      - assertTrue(a > 100)，100，magic number
      - assertThat(productPrice, greaterThan(price(100)))
    - 冗长安装：setup方法中代码过于冗长，不拆分一下让人不好看懂
      - @Before的setup方法中，将过于复杂的逻辑拆分到不同的私有方法中去执行
    - 过分保护：一个测试方法中有多个断言，有过分保护之嫌
      - 太过于谨慎了，一个测试方法中，多个断言，对同一个结果，不同角度反复断言
  - 可维护性较差
    - 重复：数字、字符串和类似代码逻辑多次重复，需要抽取
      - 对于测试代码中一些重复性的数字、字符串，抽取出来，抽取成一个独立的变量，不要有太多重复的东西
    - 条件逻辑：不要在测试代码中加多个if else逻辑判断
    - 脆弱的测试：随机性的逻辑导致测试经常运行失败，不够稳定
    - 文件路径：使用绝对路径导致在别人那里测试运行失败
    - 沉睡的蜗牛：使用Thread.sleep来控制多线程，导致运行缓慢和随机性
    - 像素完美：对图像类测试代码，使用了过多像素数字
    - 参数化混乱：过多使用参数化测试技术，导致测试代码不易于调试
    - 方法见缺乏内聚：一个类中混杂太多的测试方法和测试类实例
  - 可信赖程度较差
    - 注释掉的测试：不要注释测试，而是直接删除掉
    - 歧义注释：有些注释有歧义，误导人理解，需要重写注释
    - 永不失败的测试：检查抛出异常的测试，却永远接收不到异常
    - 轻率承诺：测试代码被注释，没有写断言，都是无意义的测试代码
    - 降低期望：对代码执行的结果要求很低，轻易就通过测试
    - 平台偏见：不同平台的测试需要划分到不同的类中，对windows平台的测试用一个类，对unix平台的测试用一个类
    - 有条件的测试：如果依赖条件来进行测试，那么可能会有问题，不要出现if else
- 可测试的设计
  - 什么是可测试的设计？
    - 模块化设计
    - SOLID原则
    - 上下文中的模块化设计
    - 以测试驱动出模块化设计
  - 无法测试的问题
    - 无法实例化某个类
    - 无法调用某个方法
    - 无法观察到输出
    - 无法替换某个协作者
    - 无法覆盖某个方法
  - 可测试设计的指南
    - 避免复杂的私有方法
    - 避免final方法
    - 避免static方法
    - 谨慎使用new创建对象：如果你这里用了new来创建对象，会导致我们没法注入测试替身
    - 避免在构造函数中包含复杂逻辑
    - 避免使用单例模式
    - 使用组合优先于使用继承
    - 将外部组件封装在自己的组件中
    - 避免远程服务查找和调用 

你开发好你所有的功能代码之后，运行完所有的单元测试之后，跑出来一份单元测试覆盖率的报告，这份报告的话呢，需要保留好，因为在后面，会有一个审查的环节。

### 15.冒烟测试规范

冒烟测试，大概的意思是这样子的，名字是从哪儿来的呢？以前国外有程序员，传闻说是从微软那边程序员传出来的。

以前如果就是光写单元测试的话，其实可能还是会有不少的bug。

然后程序员就会很懒，他们会觉得说，我们就不用化很多的时间去测试代码了，直接甩给QA去测，他们测出来了，我们再修改就可以了。

后来QA很火冒三丈，BAT都有这样的情况，QA觉得你提测的时候，怎么bug这么多啊，很多都是初级的bug，你当时如果自己好好测一下不就得了，到我这里来就没那么多的bug了。更加重要的一点是什么呢？之前有人做过统计，每一个测试环节，如果你的一个bug越往后发现和修复，耗费的成本可能是上一个环节发现和修复的成本的10倍。比如在单元测试环节，就发现有一个bug，就修复了，这算是美金是10美金；如果到集成测试环节，再发现一个bug，可能要话费的是100美金的成本；如果到系统测试的环节，再发现一个bug，可能要花费的成本是1000美金的成本。

那么现在比较流行的是说，在提交给QA的集成测试之前，RD必须在自己本地，跑起来，基础设施全部连通开发环境中的mysql、redis、mq，自己负责的代码跑起来，对各个接口，自己测一测，如果觉得都能跑通，逻辑正确，那么测试通过。

这个，其实就是花不了多少时间，这个就不是说一个类一个类的测试了，可能你总共就20个接口，对应了200个类。对200个类，要写200个单元测试。对20个接口，一行代码不用写，系统跑起来，自己模拟一下http或者rpc的请求，构造一些参数，看一下返回结果，就可以了。

这可能就花费抽一根烟的时间，所以有人传闻，冒烟测试，可能就是从这儿来的。

冒烟测试，就是负责开发的RD，自己简单的去进行一下测试，确保自己写的代码大问题没有。

在进行详细设计的时候，就需要设计好自己要执行的冒烟测试的测试用例。

（1）测试名称

（2）测试接口

（3）输入

（4）输出

你执行了冒烟测试过后，要记录下来一份冒烟测试报告，这里面就写清楚，你执行了哪些冒烟测试用例，输入是什么，输出是什么，每个冒烟测试的结果是否通过。

### 3.静态代码扫描

静态代码扫描，主要是看一下代码写的是否足够规范，如果靠人肉去看代码写的是否足够规范的话，耗费时间太多，不太靠谱，可能会有遗漏。

针对我们的编码规范，用了阿里的java开发规范，用阿里配套的代码扫描的插件，去扫描一下代码，看一下，是否都是符合规范的，如果扫描结果提醒，有不符合规范的地方，需要你将对应的不规范的代码重构一下，直到代码全部符合规范。

然后最终通过扫描的扫描报告，需要留存一份，后面会有人来审查。

要求必须在自己的IDE（Eclipse或者是Intellij IDEA）安装阿里编码规范的插件，然后必须是用这个插件来扫描你的代码。扫描之后有3个级别的问题：

1、Blocker：这个是最严重的问题，要求是必须修复，不允许带着Blocker问题的代码上线，否则就是直接跟绩效挂钩

2、Critical：是比较严重的问题，要求是必须修复，不允许带着Critical问题的代码上线，跟绩效挂钩

3、Major：问题，可以不修复，也可以修复。主要是看项目的排期和进度，如果说进度不是特别紧张的话，建议全部修复。如果说项目进度很紧张的话，Major问题可以先放着，下次有时间了再修复。

### 16.静态代码扫描规范

静态代码扫描

静态代码扫描，主要是看一下代码写的是否足够规范，如果靠人肉去看代码写的是否足够规范的话，耗费时间太多，不太靠谱，可能会有遗漏。

针对我们的编码规范，用了阿里的java开发规范，用阿里配套的代码扫描的插件，去扫描一下代码，看一下，是否都是符合规范的，如果扫描结果提醒，有不符合规范的地方，需要你将对应的不规范的代码重构一下，直到代码全部符合规范。

然后最终通过扫描的扫描报告，需要留存一份，后面会有人来审查。

### 17.代码审查规范

code review，代码审查，代码走读。

到这里为止，你的team里的一个同学，就已经把他要干的活儿全部都干完了。

此时，他就应该push自己本地的代码到gitlab上去，然后在gitlab上对他自己的feature分支，提交一个Pull Request到develop分支上去。

Pull Request的reviewer就是你，架构师本人，也可以是团队内其他的高工，如果你作为一个架构师，带了十几个人，二十人的团队，你手下有三四个高工，每个高工带了一个小团队，那么其实一般就是让高工负责去审查他们的代码就可以了，你负责审查高工的代码。

Pull Request里面，是可以写备注的 ，这个备注的规范如下：

（1）标题：用一行文字，简短的概括说明，你本次开发好了哪些东西。

（2）列表。

1.完成了订单系统的开发

（1）包括XX模块

（2）包括XX模块

2.完成了调度系统的开发

（1）包括XX模块

（2）包括XX模块

单元测试报告：可以通过邮件去发送，然后在这里可以备注好，通过哪份邮件，已经发送过去了，对方可以查看。

冒烟测试报告：邮件。

静态代码扫描报告：邮件。

接收到这个Pull Request的同学，就需要对他的代码去进行审查了。

code review，要看哪些东西，众说纷纭，可以写的很详细，也可以写的很粗糙。

这一块，基本上要定一个特别细的规范，很难的，负责review的那个人，自己时间很紧张，可能一般都没有太多的时间去给你看代码。

所以你务必要确保说，在短时间内，这个负责审查代码的人，可以确保说，这个代码是ok的。

我根据经验梳理出来一些，看别人的代码，重点要看什么：

（1）看懂别人的代码：基本上都按照编码规范，命名都很清晰，面向对象的划分都很清晰，注释很清晰，逻辑交互很清晰。如果说你觉得能看懂这个人的代码，而且代码设计的很优雅，未来的可扩展性很高，那么就可以。但是如果你发现有些地方的命名，或者是代码注释，不够清晰，导致你不好理解，看不懂，而已给建议。这块是在把控代码的质量。第一点，就是让人能看懂。 => 代码质量。

（2）仔细审查一下业务逻辑是否准确，对照着详细设计文档来看，你作为一个小leader，你要负责确保说，你手下写出来的代码，是按照详细设计文档里的设计在写的，整个业务流程和业务逻辑都是准确的。看一下这个逻辑，是否有可能会在某些特殊情况下出现bug，也是根据你的经验和能力来的，你的经验和能力越强，这一步能看出来的问题就越多。 => bug。

（3）看一看代码编写的细节有没有什么问题：这个，就根据你的经验来判断，比如说，你发现某一段代码，在for循环内部出现了每次循环都创建一个对象的，备注一下，建议将循环内创建对象的逻辑抽到循环外面来执行。我可以给出来很多很多的建议和细则，大家很难去执行的，还有很多，根据你自己的技术能力和技术经验来了，你的技术越强，经验越丰富，往往在这个环节，你可以提出很多的问题。io读取文件，你会建议说，是否可以重构为nio的方式。 => 对代码设计和技术实现的质量。

（4）单元测试，初步浏览一遍，看看单元测试代码写的是否ok，如果出现一些不太规范不太好的地方，给一些建议，让单元测试代码重构一下。看一下单元测试覆盖率的报告，确保说，70%的覆盖率，核心包下的代码覆盖率是100%。

（5）冒烟测试，仔细看一遍，确保说，他设计的那些冒烟测试用例都执行了，这个就代表着说他做了这个事情。

（6）静态代码扫描的报告，这个就是确保说，都是符合编码规范的，代码是规范的。

有了规范，必须确保可以落地，可以执行，唯一能够依靠的就是check。

在code review这个环节，就可以去check之前的所有流程，单元测试覆盖率是否达标，冒烟测试是否全部通过，静态代码扫描是否全部通过。

1、他会去看每个人的每一行代码，3个目的

作为一个leader，或者是团队里其他的高工，你有责任和义务去仔细看其他人的代码，如果出问题，你作为leader或者高工有责任去帮低级别的人解决问题。

code review，就是一个完美的时机，你作为一个leader或者高工，去仔细看手下写好的代码，你这样才可以把控全局，控制所有的东西。别让自己掉队。万一你手下小弟刚写好代码，外面拿到个offer，薪资暴涨50%，人跑了。

code review，你或者其他高工看懂别人的代码，就代表你成为了那个人的一个backup。如果那个人跑了，你可以直接顶上去。

1）帮低级别的人解决问题

2）backup

3）掌控系统的全局，每一块代码大概是怎么写的，心里有数

2、你作为一个检查机制，检查在code review之前的规范，有没有执行

别人给你给你提交PR的时候，你必须得让他同步提交三样东西：

1）静态代码扫描的结果：blocker和critical级别的问题是否都解决了，major问题遗留了多少个

2）单元测试覆盖率的报告：你去检查他负责的那几个模块，单元测试的覆盖率是否达标

3）冒烟测试报告：他对他负责的模块的核心流程都进行了冒烟测试，确保他负责的模块的核心流程都可以跑通

你要作为一个leader，去检查他都做了这几件事情

3、以你的技术能力和经验，去发别人代码中的不合理之处，指导低级别的工程师去修缮和完善自己的代码。

以你的角度，和你当前的技术经验，技术的能力，对技术的掌握和把控，站在你的角度来审视别人的代码，如果你发现这哥儿们代码有些的烂的地方，你就给他提出code review的一些建议。

代码一旦修改，同步的单元测试和冒烟测试，自己全部对应的做一下调整

静态代码扫描、单元测试覆盖率报告，全部重新做一遍

Pull Request再次提交到高工的手中，你再看一下当时让他修改的那些代码，发现，很好

### 18.集成测试规范

集成测试

互联网行业里，集成测试，都是RD自己做的，不是QA介入的。联调测试，每个人的部分要集成到一起，联通外部的所有基础设施，让整套系统跑起来，对系统的核心流程，以及核心的功能，都去进行测试，验证。确保整套系统是可以跑通的。我们一般会称之为，小黑屋阶段。因为涉及到多个人的联调，集成，测试。所以一般在这个环节，我们一般都会提前订好几个的会议室，每天上班第一件事情，就是大家一起去小黑屋里去测试，有一个人负责去执行系统的所有核心流程，QA，PM。发现有问题，大家就根据日志去排查问题，现场排查，现场直接修复。

跟传统IT行业，不一定完全一样。

集成测试通过之后，就是要确保系统的所有核心主流程全部跑通。

集成测试的测试用例，是QA去设计的，QA在这里去执行集成测试的用例，我们RD主要负责配合排查bug和修复bug。

### 19.系统测试规范

系统测试

这一步不用说了，一定是QA去做的。

QA提前设计好对应的所有的系统测试的用例，这个用例一般都是很详细，很复杂的，涵盖了各种细节，各种异常和特殊的情况。

就是直接将整套系统部署到test环境，联通test环境整套基础设施，然后由QA去测试。

引入一个东西，叫做缺陷管理。

就不是走小黑屋的模式了，RD自己在那儿瞎测，大家都通过了集成测试了，都对自己的系统和代码比较有信心了，直接部署好在test环境，我们就坐等QA反馈bug。

QA，如果在比较原始的其情况下，基于word文档来记录缺陷bug，来反馈。

现在其实有一些很好的产品，项目全生命周期的管理，包括了bug缺陷的反馈。但是我们在第一个阶段，尽量用比较原始的方式来做，因为让你了解原始的方式，怎么把整套东西给跑通了。到了阶段二，我们就会去用一些专门项目管理软件，缺陷管理软件。

QA，发现一个bug，就会记录下来，这个bug的发生时间，bug标题，具体描述，截图。

一轮一轮的来测试。

第一轮测试之后，就统一一个word文档，发给各个RD，每个RD去排查和修复自己负责的那个bug。大家全部都修复好之后，再次提测。

QA再次进行第二轮测试，word文档。以此类推，三轮，四轮，三轮左右，就可以搞定了。QA觉得一个bug都没有了。

### 20.验收测试规范

验收测试

QA全部测试完之后，理想情况下，那么此时bug数为0，系统就完全达到可以上线的状态了。

但是此时还是需要将系统在验收环境，staging环境去部署一下，然后让PM来验收，PM会自己设计很多的验收测试用例，执行自己设计的那些验收测试用例。确保说系统的所有核心功能全部可以跑通。

此时系统就完全达到了可以上线的状态。

## 系统上线规范

### 21.系统上线规范

一、上线checklist

每个在本次要上线的版本中负责开发的同学，都需要提交自己的上线checklist，最终合并到同一份上线checklist文档中去。上线checklist文档，就是在里面要写清楚每个人负责的那个部分，那个子系统的整个软件工程流程过程中，沉淀下来的所有文档，都需要附加在这份checklist文档中，一般比如说可以用一个word文档，在这个word文档中，附加上你每个过程对应的一个截图和报告。

1、各系统的测试报告

1.1 XX子系统的测试报告

（1）单元测试报告：确认你的单元测试覆盖率是否达标。

（2）冒烟测试报告：确认你的冒烟测试全部通过。

（3）静态代码扫描报告：确认你的代码完全符合开发规范。

（4）代码审查结果：就是在Gitlab中，你提交的PR最终会被人通过和merge，负责审核你的代码的人，他需要在审核之后，给出你一份总评，就是说，审核了你哪些哪些地方，然后最终判定通过，给一个截图。确认你的代码是经过审查的。

1.2 XX子系统的测试报告

2、系统整体的测试报告

2.1 集成测试报告

2.2 系统测试报告

2.3 验收测试报告

这份文档，可以由架构师指派一个人去收集所有人沉淀下来的过程文档。一个大的需求版本上线，必须由这个系统的总架构师，亲自在上线前去审核这份文档，确保说，这个文档里反映出来的每个子系统都经过了良好和充足的测试，每个环节都做了，每个环节都按照标准、要求和规范去做了。

二、上线文档

架构师也可以指派一个人去做，有些公司，比如说一些较为传统的IT公司，一般对权限收的特别紧张，要求说只有经理才有级别去做什么代码合并，只有经理才有级别去操作线上系统，只有经理才有权限去执行上线。见过很多公司是这样子收缩权限的。

我的风格不是这样的。一般来说，我的理念，是说，尽量提升团队里每个人的能力。如果要提升每个人的能力，那么最好的办法，就是把他扔到线上的血与火的环境中去锤炼。有的人可能就工作个两三年那样子，甚至是一两年。但是如果他足够有潜力，你想要培养他的话，那就尽可能让他去做更多的事情。

尽量让年轻人做更多的事情。

（1）详细设计：让组员自己去做，锻炼他的系统设计能力，而不是只会写代码。

（2）工程初始化：让组员去做，锻炼他们从0开始迅速搭建出来一个系统的能力，而不是只会在现有的框架基础之上去填充代码。

（3）集成测试、系统测试、验收测试：尽量让各个组员自己去做，配合QA、PM、其他团队的RD，让他们去协调，去沟通，锻炼他们的跨团队的沟通协作能力。

（4）系统上线：让年轻的成员去进行线上操作，这样可以真正锻炼他们的能力，让他们有线上操作和运维的能力。

如果高工走了，可能就没人能接活儿，没人去做设计，没有人会从0开始搭建一个工程出来，没人能协作组织跨团队的测试协作，没人能执行系统上线，和线上运维的一些操作 。

可能就导致说，你作为一个架构师，很累，什么事情，都要事必躬亲。

1、初始化线上数据库

（1）从哪儿导出来一份SQL文件。

（2）在哪个线上数据库中执行这份SQL文件。

（3）执行过后，需要检查一下，需要的128张表是否全部完成初始化。

2、部署系统到线上机器

（1）将完整的代码，打成war包。

（2）到线上的哪台机器上去，将tomcat停止。

（3）然后用scp将war包上传到机器上去，然后放入tomcat的webapp目录下。

（4）然后重新启动tomcat服务器。

（5）观察系统启动日志，各个环节的初始化是否正常，比如说数据库连接池的初始化。

3、线上验证

（1）系统成功部署之后。

（2）对几个核心流程和功能，手动执行一些操作。

（3）确认所有功能正常运行。

（4）确认所有的日志都正常打印。

（5）确认所有的数据库中的数据记录都正常。

三、执行上线

执行上线，一般会有一个规范，就是在什么时间点，可以执行上线。

一般来说，是选择系统的低峰期 。

分开来说，不同的系统上线的情况，可以允许的时间是不一样的 。

（1）大版本，上线，v1.0，v1.2，一般是建议在晚上9点以后，就是在低峰期，甚至是建议在凌晨2点，凌晨5点。

（2）小版本，修复一个bug，做了一些改动，一般是建议在非高峰期的一些相对低峰的时间段，可以执行上线，上午的10点以前，下午2点~4点。

执行上线的规范

（1）需要超过2个以上的人在场。

（2）一般是负责执行上线的同学，按照之前审核过的上线文档来一步一步执行操作。

（3）级别较高的同学，高工，会去在旁边仔细看着他上线的每个步骤。

（4）如果一旦出现任何问题，需要进行回滚，比如说，用之前版本的代码，再次重新上线。

## 线上运维规范

### 22.线上运维规范

线上运维，最基本的一个事情，其实就是说线上系统，如果没有其他的什么技术挑战的话，主要就是出bug。如果出了bug，你怎么来解决，按照什么流程，谁来解决，解决之后，需要记录什么东西下来。

线上bug处理的SOP。

Standard Operation Procedure：标准的操作步骤。

1、线上故障反馈群

每个公司自己内部的IM，社交沟通的工具，钉钉，QQ，百度hi，咚咚。

但是很多小公司，也可能是微信群，QQ群。

得有一个专门的群是一个大群，这个群是专门给人反馈线上的bug的。

如果说，接收到了一个bug的反馈，用户提交的，产品经理发现，运营发现的，需要在线上bug反馈群中去抛出这个问题，同时打电话通知今天负责值班的人。

2、线上bug的分级标准

（1）S级：直接影响了系统的核心主流程，比如电商里，不能查看商品，不能使用购物车，不能下订单，不能支付了。要求1小时内解决。

（2）A级：没有阻塞系统的核心主流程，但是在核心流程里发生了一些影响用户体验的bug，查看商品的时候，css样式乱了，商品无法排序。4小时内解决。

（3）B级：阻塞系统的非核心流程，无法发表评论了，无法对别人的评论点赞了。1天内解决。

（4）C级：没有阻塞系统的非核心流程，评论列表没法分页。3天内解决。

3、线上bug反馈的模板

（1）bug名称

（2）bug发生的时间

（3）bug提交人

（4）bug的详细描述

（5）bug的相关截图

（6）bug的分级

（7）相关系统

（8）相关负责人

4、团队里的值班机制

团队里，有5个人，那么就需要按照一定的顺序排好，每周谁怎么值日，7天，可以这样子，有些级别高的人，可以承担更多的责任，可以去值班两天，有些年轻的同学，而已值班一天就可以了。

当天负责值班的同学，需要保持全天24小时，手机电话畅通，持续关注公司里的交流群。

5、定位bug原因

根据bug反馈报告，到线上系统打印的日志中去，看一些那个时间点，相关的日志，根据日志的情况，定位出是什么bug。

日志很重要的，如果日志打印的不好，那么根本没法排查线上的bug。

定位到bug的原因之后，立即在线上事故反馈群里，反馈一下，这个bug，它的问题找到了，原因是什么。

6、解决bug

值班人，将bug转移给对应的bug负责人。

bug负责人此时需要从master分支拉一个bugfix分支出来，在自己本地跑起来整个系统，复现出来这个bug。

在本地修复这个bug和确认修复。

将bug合并到develop分支上去，由QA介入，在集成测试环境，确认说这个bug已经修复了。

将bug合并到master分支上去，在staging环境发布一下，由QA再次回归测试和验收，确保bug修复。

将master分支打一个tag，发布修复了bug的代码到线上去上线。给出上线checklist（bug反馈报告，原因，如何解决，bug修复测试的报告），给出一份上线文档（本次上线的步骤），执行具体的上线。

7、将bug的完整过程记录到一个bug文档中去

bug1

（1）bug的反馈报告

（2）bug的定位原因

（3）bug的解决思路

（4）bug的上线文档

（5）bug的反思：为什么会出现这个bug？少了测试用例，在测试的时候，没有伪造一些异常的请求和数据去测试？或者少了一些校验和验证的系统设计？

（6）bug的后续改进步骤：在设计测试用例的时候，需要构造更多的异常的请求和数据；在系统设计的时候，需要考虑更多的校验逻辑。

8、将bug文档同步给团队里的leader和其他同学

每个人都要仔细看这个bug的具体的步骤和情况，去学习bug，共同进步。

### 23.开发流程

梳理完整流程。

（1）业务调研：产品经理搞明白需求是什么

（2）需求分析：我们去分析产品经理给的需求文档，梳理出系统要干嘛

（3）概要设计：作为架构师，我们自己去设计全局性的技术架构、系统运行流程、物理部署架构

（4）概要设计评审：找其他部门的架构师来帮忙评审一下我们的架构方案

（5）详细设计：指导团队里的各个同学，自己对自己负责的部分进行详细设计，数据库建模、接口设计、类设计、包设计、功能流程设计、单元测试设计、冒烟测试设计、日志设计

（6）详细设计评审：我们作为架构师要仔细去看一下各个同学的详细设计，确保没问题

（7）工程初始化：指派多个同学，完成所有的初始化的一些事情

（8）版本控制：明确如何对代码进行版本控制，工作流是什么

（9）编码开发：根据阿里的开发规范，写代码即可

（10）单元测试：自己写所有的单元测试，测试每一个类

（11）冒烟测试：自己对负责的系统跑起来，冒烟测一下核心功能

（12）静态代码扫描：确保自己的代码符合规范

（13）代码审查：由高级别的人去审查自己的代码

（14）集成测试：所有环节集成在一起，确保系统整体流程炮通

（15）系统测试：QA来严格测试每个功能

（16）验收测试：PM验收系统

（17）系统上线：按照严格的步骤去执行上线

（18）线上运维：按照标准化的流程去处理线上的bug

# 项目管理规范

## 项目计划规范

### 24.项目管理计划

项目管理计划：就是在完成所有的技术设计之后，我们已经知道要怎么做这个系统了。但是现在的问题在于说，按照什么样的节奏、步骤和进度去完成所有的开发、测试以及上线的工作呢？

在以前比较原始比较low的时代，没有项目管理的概念的时候，项目管理的概念在国外一直比较成熟，传入国内，开始也主要是一些传统IT行业会干这个事情，比如华为。但是在互联网中，一般都是几个人的小团队，小作坊式的单打独斗，去开发项目。没有很好的项目管理的计划。

在概要设计+详细设计都搞定之后，会有一个步骤，叫做排期。

每个人给出自己的排期，所有人的排期合并在一起，组成项目的一个完整的排期。就是每个人对自己负责的那个部分，给出来每个环节/功能要做完，需要花费多少时间，需要从几号到几号去做。然后的话呢，项目的总负责人，大R，就会按照这份排期去跟进和管理项目组的开发，直到最后确保项目的上线。

但是这种原始的方式有几个问题：

（1）排期，比较粗糙，粒度都很大。就是说，排期是静态的，很多时候，这个排期没有组成一个动态的情况。开发任务之间可能是有相互的依赖关系。但是每个人自己在排期的时候可能没有考虑到。小A说我做的一个X1模块，排期是从5月23号到5月28号；小B说我做的一个X2模块，排期是从5月24号到5月26号；结果。。。其实小A的X1模块，最后要全部完成，可能是要依赖于小B的X2模块。科学合理的规划，其实会出现排期混乱的一个情况。

（2）其实每天每个人在干嘛，干了多少事情，有没有延期，有没有出现什么问题，是不是工作任务太轻松了，leader是不知道的，完全不透明。项目的执行进度完全不透明。到每周的周会总结的时候，可能就有的人很轻松，说完成了，2天时间就完成了5天的工作；有的人可能就delay了，说我才完成了60%。一定是有一些同学是有一定经验的，相当部分的同学，都是带过团队，技术经理以上的级别。年轻有为型的，带了小team。

（3）执行到一半儿的时候，因为第一步中的项目排期定的非常的不合理，不科学。这就可能会导致说，小A开发X1模块，开发到一半儿了，突然发现说，小B，需要你的X2模块，你搞定了没有。小B说没搞定啊，我这要5月26号才能搞定呢。。。。小A说，惨了，我只能delay了，X1模块就到了5月30号才搞完。各种加班，各种救火。

（4）项目可能是有一些风险的，一开始你的项目计划里定的好好的。就是说，到6月2号的时候，dba会负责给我搭建好一整套的mysql主从架构的数据库，我就可以基于这套数据库去进行验收测试。结果。。。dba到了那个时候，dba技术太烂，导致搭建出来的mysql数据库有问题，你需要的是mysql 5.6的版本，dba瞎搞，给你搭建了mysql 5.7的版本。delay，你说怎么办呢？dba的责任，不能怪我。。。你是架构师，你是全局主导整个项目的一个总负责人，所有的责任都在你身上。项目做的好了，最大的功劳就是你的。项目做砸了，delay，所有的责任都是你的。老板才不管你这么多，总监，副总，你能力不行呗。

（5）做到一半儿，突然PM产品经理，修改需求，需求变更，我在项目过程中最讨厌的，拥抱需求变更，拥抱变化，敏捷开发的模式，极限编程。忽略了一个问题，为什么要有这些变化呢？就我的经验而言，我就得如果一个PM很靠谱的话，是不应该出现这种情况的。如果出现胡乱的需求变化，主要责任人是PM，太不靠谱了。没有考虑的很周到，拍脑袋，也是很模糊的一个状态。有些需求变更可能是合理的，比如说公司的战略方向，市场变化相关的。拖出去打。RD和PM之间是有仇的，RD用刀子捅了PM。

混沌时代，项目计划粗糙、项目的执行不透明、风险没人管、变更胡乱进行，都是各种问题，一把辛酸泪，踩过太多的坑了。

项目计划粗糙，制定那么粗糙的项目计划了，如何制定一份科学、合理、精细的一份项目计划。

制定下来一套初步的立刻可以落地执行和实施的项目管理的规范，按照这套规范去执行整个项目的管理。

肯定有同学会专门在传统IT行业里，会专门做这个项目管理，肯定会考取这个证书，专业的证书，学过完整的理论。

但是理论 -> 现实一定是需要融汇贯通的，取舍和变化的，整套复杂的理论硬是全部要在项目去实现。

从0到1的时候，初步建立起来一个非常实用的项目管理的规范，就以我的经验而言，互联网行业里，项目跟传统行业是不太一样的，哪怕只是掌握好了我们这个课程里讲解的这些项目管理的实用性的东西，其实对于大多数同学而言，带一个10人以内的小团队，做一些中小型的项目，都没问题了。

到了后面，我们的这个项目和团队会变得越来越大，这套规范逐渐的就会变得不是很适用，规范，细化，应用项目管理整套理论中更多的一些东西。

制定的规范，只是一套用于参考的规范，到不同的公司，不同的项目，不同的团队，一定要根据你的具体情况去改编和调整你的整套规范，适应你的具体情况。如果你直接照搬我的规范，可能是有问题的。你学会了孙子兵法，出去打仗，我就要完全100%按照孙子兵法说的这样，上战伐谋，我就不开张，先想办法去跟人家谈判。但是其实这个时候可能更好的方法式，连夜奔袭，直接突击敌营，击溃敌军。

主要是给大家一个比较通用的一个规范和思路，让大家明白说，整体的流程是什么样子的？我们按照一种规范和实现方式，全流程做一遍这个项目。

### 25.项目计划规范

1、活动清单

活动清单，一般是每个人对自己负责的那个部分，需要自己在这个表格里填充对应的排期，因为只有自己负责的这个部分，自己是最熟悉的，大概是知道自己要做多长时间的。最终会汇总到一个完整的活动清单中去。

活动清单汇总完成之后，需要由架构师仔细审查每个人定的活动清单的人/日排期。最主要的是，根据架构师的丰富项目经验，要判断一下，每个人的每个工作，有没有多排期（职场里有很多老油条，是不好好干活的，比如说只要1天可以做完，2天，自己就可以多一天的时间出来自己玩儿，清闲一些），就需要架构师去判断，必要的时候需要对排期做调整，尽量保证排期是比较紧凑以及合理的。我个人的建议，架构师站在丰富的经验上，比如说我，如果我来带一个项目，在前期完全我来主导设计，然后评审每个人的详细设计之后，做了很多年的开发的人，对每个事情，每个工作任务，以那个人的能力和智商，大概要花费多少时间，其实大家心里都有数的。比如说我，基本我对排期的工作量的判断，99%。

只可意会不可言传，没什么特别大的技巧，就是你如果工作了至少5~8年，以8年以上为最佳状态。那你对各种事情需要多少时间，门儿清。

有些同学，很积极主动的同学，可能希望自己是尽量少的时间里做更多的事情，他们跟上一种同学，相反。一件事情可能要2天，结果他们硬是给自己排了1天。需要大量的加班，排期很不健康的，很可能会导致项目会delay。架构师看到这种情况之后，要及时识别出来，有些同学排期太过于紧张，让他们增加一些排期。

我个人建议，28法则。工作的排期，留出来20%的buffer，用80%的精力给做了。这种情况是最合适的。

比如说一个工作大概是需要4天，那么你可以给排个5天。留20%的buffer。如果说正好是4天干完，多了一天出来，可以让手下的同学轻松一点，可以自己看看书，学习一下技术。如果说5天之内，出现了一些意外，导致4天内没有干完，20%的buffer顶上去，可以留有余地，不至于delay。根据我之前的一些实践，20%的buffer合理的。我常见到有些老油条，2倍，3倍，4倍，5倍的时间，去做一件事情。

（1）架构师定好类似这样的一个表格。

（2）通知组内每个同学，根据自己的详细设计的文档，在表格中填充自己的排期。

（3）然后架构师组织一个排期评审会议，这个会议上，每个排期一条一条的过。

（4）架构师重点关注，老油条和过度积极的同学，20%的buffer。

2、网络图

画出来三级任务之间的执行流程和串联关系。

每个节点包含任务名称、负责人、所需人/日 。

3、进度计划（甘特图）

制定一个指导项目完整的进度计划的一张图，甘特图。

每个任务如何穿行，如何并行，将每个任务就不是以几人/日来表示，具体到某一个任务是从几号到几号。

使用甘特图绘制出来完整的进度计划 。

4、资源配置表

在甘特图的基础之上，绘制出来每个任务的人员配置 。

### 26.项目执行监控

项目中可能有很多个人，很多种角色，可能项目组里有4个人，5个人，10个人，20人，30人，50人。100人的大团队协同作战。

如果你只是定好了项目的管理计划，而没有做任何的项目执行的进度把控，那么其实那个计划，正常来说，就会流于形式和表面。设想一个场景，假设你把项目进度计划做的很棒，很好了，这份项目计划直接发下去。然后接下来你就不管了，你可以想象一下，项目会干成什么样子？两个问题，一定是人都是有惰性的，这个是人性，不是说一个人是好人，还是坏人，就是只要没有监督和管理，人一定是会或多或少有惰性的。哪怕是一个靠谱的人，在没有监管的情况下，惰性一旦发生，就可能会导致什么呢？

今天这哥儿们突然想说，哎呀今天的工作稍微缓一缓把，我最近失恋了，心情不佳，实在是不想干活儿。。。或者是，哎呀，最近这两天的工作，稍微慢一点吧，先稍作一点儿，平时3点就偷偷溜走了，让同事给代打个卡（瞎说的，在大型的互联网公司里，其实比较松散的，不同的人工位都在不同的地方），溜走了，去跟我的大学同学正好来北京出差，我跟他一起玩玩儿。

我们这里这一讲，要说的就是项目执行的监控和把控。

如果不进行严格、科学以及良好的项目执行的监控，可能就会发生各种各样想不到的情况跟，到每周看一下进度的时候，各种delay，各种延期，各种没做完，找了一大堆的借口出来，死猪不怕开水烫的样子。项目就濒临崩溃。。。。

不是这个人有惰性，这个人，他可能是能力不够，做事情的过程中，一定是会遇到这样那样的一些困难、挑战以及问题的，自己没法解决，然后你又没有及时关注，最后直接导致这个人的工作delay。长此以往，项目崩溃。。。。

项目崩溃，本来预定的是6月5号上线，结果，6月12号，6月20号，7月1号。整整延期了1个月，一个10人的团队，每个人平均年薪24万。平均月薪2万。每个月公司的工资的成本就是20万。也就是说，项目胡乱管理，团队战斗力太差，项目每次延期一个月，给公司空耗20万的资金。

我之前说的那个100个人团队，公司直接损失200万的资金。还要加上公司还要给你支付各种五险一金，300万。

我先说一个前提，我个人认为，项目总负责人是直接决定了一个项目的成败的。项目leader每天啥都不干，就是问问进展，帮着协调和解决，开会。结果活儿都是下面的人干的，这个leader干什么呀，瞎搞。没出什么力。如果一个项目没有一个很好的项目leader，全权负责和把控这个项目的方方面面，那么这个项目很可能就会失控，因为哪怕这个leader只是起到每天去监控一下你的项目执行进度的作用，但是这个监控的行为是非常重要的。

千军易得，一将难求。

实际你带项目的过程中，一定会遇到这样那样的各种乱七八糟的问题，需要你灵活机变的去解决这些问题。我在这里有一个观点，你说考了一些项目管理的证书，大学生都没工作过，就去考一堆的证书，比如Oracle OCP、OCM，Cisco CCIE，CCNP，数据库专家，数据库大师，网络专家，网络工程师的，一些认证。

反之，如果有人没有考这样的一些证书，但是他把那些证书背后需要学习的教材，自己买来看了一下，然后有多年的相关经验的积累，带了很多的项目，实际踩了很多的坑，那么这个人也许没有证书，但是这个人在这方面的能力和经验的积累，一定是更强的，实践是最宝贵的，实践出真知，有实践经验之后，就代表着这个人基本上可以把这个工作给干好。

带两个同学，一块儿去做一个项目。性格上都有问题，计划的时候，颗粒度太粗了；拉不下面子去每天监控每个人的执行进度；有些人还有脾气，反正当时定的是5天干完一个事儿，那我就5天之内干完这个事儿不就得了。你干嘛每天来东厂太监一样来监视我，硬逼着我每天必须干完什么事情。歪理，项目，是一个变动性很高的事情，做的过程中，可能会有各种各样的一些变化，每天卡着进度是不合理的。

那个项目就失败了，原本预定是在8月底上线，结果一直拖拖拖拖到了10月底才上线，延期2个月，失败的项目管理的例子。

## 项目执行规范

### 27.项目执行规范

1、执行计划

项目管理的一大重要实践准则：从多年项目的血与火的锤炼中，总结出来的真理和真谛。项目的执行计划，绝对是要在执行的时候，定到非常非常详细的一个颗粒度。务必细化到每个人每天要干什么，每天要干的事情，要写的非常的详细。接下来，做项目执行监控的时候，是完全按照每天的一个粒度，去检查每个人这一天干活儿干的怎么样，事儿干完了没有，有没有什么问题。

为下一周执行详细的执行计划，务必非常仔细，细化到每一天。

每个人做的第一件事情，要求团队中的每个同学，都必须按照自己在项目管理计划中的排期，将每个任务拆解，拆解到非常详细，细粒度，细化到每天要做1234哪些事情，形成自己的一份下周每天要工作的执行计划。

2、类百度的站立会制度

B里面，有非常好的一个传统，每天早上10分钟站立会制度。

每天早上一上班，第一件事情，就是开站立会，不要找会议室，很麻烦。直接定一个公司里的某个角落。项目组相关的人全部聚齐在这个地方。每个人1分钟以内，整体控制在20分钟以内，尽量在10分钟以内。

通过这个东西，一个架构师，或者说一个项目的leader和负责人，可以通过face to face，面对面的方式，去把控说，按照那个细粒度的每个人的执行计划，每个人每天的活儿有没有干完，就是有了这样的一个到天粒度的项目进度的监控机制，就可以确保说，人的懒癌就没法犯了。你要是懒癌犯了，昨天跑了，任务没干完，第二天站立会制度直接就被戳穿了，频繁几次的话，你就可以等着被开除了。价值观，在瞎干。

（1）每个人说自己昨天完成了什么工作，今天计划完成什么工作，目前是否发现了什么问题，打算如何解决。

（2）项目负责人将每个人的进度更新到执行计划中去，对完成的任务标志一个状态，状态包括了【已完成】【进度60%】【进度50%，delay】【取消】。

（3）项目负责人将每个人反馈的问题更新到问题汇总中去，包括了问题是什么？为题发生的原因是什么？如何解决问题？执行计划是否需要调整？

根据经验来看，一般如果你push每个同学将项目的进度定的粒度很细，到每天的一个粒度，每天按照站立会的制度去check昨天的进展，出现问题立即解决，给出补救的措施，一般来说，补救措施，都是加班，或者采取某些方案+加班，晚上加班，周末加班。

99%的情况下，每天的站立会都很快，一般都是完成完成完成。

在这样的一个制度下，每个人每天早上都在一个集体中去说自己活儿干的怎么样，人要脸树要皮，每个人都是有一定的自尊心，要面子的，懒癌，犯懒，为了自己最基本的在团队里继续待下去的一个尊严，其实每个人都会尽力将每天的每个事情做完。

3、个人周报

每周五的下午，每个人准备好自己的个人周报，组织周会 。

4、每个人的下周执行计划

5、项目周报

## 风险管理规范

### 28.风险管理规范

风险管理

讲过，项目管理的过程中，一定是会遇到一些风险的。那么有些风险是比较小的，或者没有提前预料。如果没有提前预料到的一些风险，发生了，其实就是在我们每天的站立会里，就会问每个人，执行每项工作，是否遇到了一些问题，那么那些问题就是发生的一些风险。但是对于这种风险的话，一般会通过问题的处理方案和补救措施来解决，那么这样的话呢，我们之前就已经讲解过了这样的一种情况。

但是如果每次都是光靠风险发生了，问题都发生了，然后事后我们第二天才知道，才开始想办法去如何解决，采取什么样的对策，那可能有的时候就晚了。因为你光是考虑出来具体的对策，可能就需要耗费一些时间，而且为了解决这个风险或者是问题，你可能还需要耗费更多的时间去做一些事情。风险但是如果我们事前就可以识别出来项目进展的过程中，可能会发生什么样的问题和风险，然后提前就识别出来了，然后提前就准备好了预案，那么等到风险真正发生的时候，我们就可以立即拿出来这套预案来执行和解决问题。

给大家举一些例子，就是在提交每周的一个项目周报的时候，都需要在这个项目周报中，写清楚这个项目未来可能会有什么样的风险，然后我们准备好的风险预案是什么，风险是否发生了，如果发生之后，采取了什么方案来解决，风险解决的结果是什么。都需要在每周的项目周报中要写清楚的。风险管理，是项目管理中非常重要的一个环节。其实风险管理，也是比较复杂的，在很多公司里，尤其是一些传统的IT公司，会积累下来一份常见风险的模板，对每个新启动的项目，你做项目管理的时候，可以对照着风险的模板，去看一下说，我们这个项目中，是否有可能会发生这个模板里列出来的一些风险。

这个东西，我觉得还是不同的公司是不一样的，传统IT公司，互联网公司，遇到的一些风险都是不一样的。

还是只能我们定义好一套处理风险的流程和规范，大家在真正做项目的时候，首先第一件事情，建立起来这个风险管理的意识，就是说， 你要有这个意识，我们需要去做风险管理。然后最怕的是说，你根本就没有这个风险管理的意识，在项目启动的时候，压根儿脑子就没去考虑过项目执行的过程中，可能会发生哪些风险。如果你压根儿就没去考虑，那是肯定不行的。你一定要去考虑说，我要有这个风险管理的意识。每次做项目的时候，就按照我们这一套流程和规范去走，尝试去识别出来有什么风险，尝试去制定一些风险的预案。

最主要这块，还是说在你多年做项目的过程中，真正按照这个流程去积累经验，可能你的每个项目都会遇到一些问题，那些问题，实际上就是我说的你没有预料到的一些风险。如果你之前预料到了，那么就不是问题了，其实就是之前准备好的风险发生了，采用你的预案。如果你没有准备好会遇到这些问题，那么实际上遇到这些问题的时候，你就可以积累一下经验，可能会出现的风险是什么？

所以这块，也是属于只可意会不可言传，不同的项目，差异实在是太大了。传统IT行业，电信项目，业务，一做就是很多年。那么在这种情况下，你的技术，过程，都是类似的，你说还可以去使用之前积累下来的一些风险模板，去尝试规避。在我的经验而言，互联网行业 里做项目，不同的公司，不同的团队，不同的情况，不同的项目，其实风险的识别出来，提前能够预料到一些风险，主要靠架构师的经验，就是建立起来了一种对风险的第六感。识别出来这样那样的一些问题，这个都是多年积累而来的一个经验。

小A同学遇到了一个问题，就是说在冒烟测试的时候，或者是集成测试的时候，突然发现说测试环境的redis集群挂掉了，需要运维人员去进行运维，比如说采用更高的机器配置来给你搭建redis集群。测试环境，突然发现测试环境的mysql挂了，测试用的mysql是一台服务器，上面建了不同的数据库，不同的系统和项目都在走，并行的在跑，然后就会发现说，有一个项目在集成测试环境里，或者是在系统测试环境里，在做压力测试。压力测试导致测试环境的mysql突然性能变得巨差，甚至直接就挂掉了。

我后面，尽量会在做这个电商项目v1.0的时候，完全按照纯真实的项目过程，去给大家演示，我的第六感和判断，我们的这个项目在执行的过程中，可能会遇到一些什么样的风险，带着大家尽量在模拟真实的环境中去体验风险如何管理。

风险识别、风险分析（发生概率、影响范围）、风险预案、风险监控。

## 变更管理规范

### 29.变更管理规范

需求变更

0、案例式的讲解

比如说我们项目干到一半儿了，突然有一天，PM过来找你，这个项目的负责人，他说，有一个XX功能，能不能改一下实现方式，或者修改一下这个功能的运作流程，或者是对这个功能加强一下，比如说有一个查询的功能，商品查询。本来预定的商品查询的条件是4个，商品名称，商品编号，品牌，类别。整个咱们的这个系统和代码，都是按照这个预定义的需求去做的，包括这个功能的代码实现，包括这个功能内部的一些运转流程，包括之前设计好的设计模式，都是针对这个需求来的。

结果这个PM跑过来找你说，诶，我发现这个需求好像不太对啊，好像这个功能需要改一改，再做一些加强，商品查询的功能，不能只是按照4个条件来查询，需要支持8个条件，比如商品状态、商品创建人、商品库存、商品好评率，他可能脑洞大开，又要让你加好多的查询条件。

然后这个时候，你一听，如果要改动这个功能的话，可能要增加很多的工作量。那么此时一般来说，RD，思维，一定不是站在产品设计的角度去走的，我们一般都是站在技术实现的角度去考虑的。跟PM是完全不一样的，PM会觉得说增加4个查询条件对运营人员的工作效率可以起到大幅度的提升。但是对于你来说，如果要增加4个查询条件，可能导致多了几天的工期，甚至导致整个项目可能会delay。此时一般你会拒绝他，你会说，不好意思，我不想修改。

但是此时，PM通常会这么说，不就是加几个查询条件吗，很简单的。有什么难的。甚至更有甚者，他提出的需求变更是加4个查询条件以及2个排序条件，支持按照什么什么规则去排序。然后他说很简单的，你就随便改一下，找一个人，花一个小时可能就搞定了。

但是，你作为架构师，你考虑一下，是这么简单吗？首先，加的那4个查询条件，商品状态、商品创建人、商品库存、商品好评率。商品状态、商品创建人，还好说，因为你想一下，这两个字段可能是涵盖在商品的主信息表里，那么直接修改查询商品的条件就可以了。但是问题在于后面两个查询条件，商品库存、商品好评率，这个就不简单了，因为可能是需要将商品跟库存表去关联，然后查询，商品好评率，可能也是一样的额，需要将商品数据跟评论表去关联，然后去查询。而且这里有一些问题，如果仅仅只是修改SQL也就算了，但是这里可能是挺复杂的，如果要做这些关联，你要去评估，索引有没有设计，SQL如果这么做的话，SQL的性能会不会大幅度下降。

甚至，可能评论是放在别的数据库中，微服务里，你还不好直接去查询，可能还要请求别的服务的接口，从别的服务里获取这个数据到自己服务里来拼接，那么此时可能还要涉及到你要跟其他team的人去交流，可能还要让其他team的同学配合着加一个接口。

评估，加4个查询条件：调研和评估（索引的情况，性能的情况，其他服务提供的接口情况）、设计实现方案（详细设计文档）、开发、单元测试、冒烟测试、静态代码扫描、集成测试、系统测试 -> 耗费多少人力，首先负责开发的RD要耗费几天的时间 -> 此时代码修改了，要重新进行集成测试，耗费1个QA+4个RD，5个人重新再小黑屋里回归一遍 -> 耗费QA的时间，将这个功能重新进行功能测试 -> 不是说你就修改了部分代码，就重新测试部分代码就可以了，你只要修改了代码，那么原则上来说，我们又不知道你只是修改了部分代码，我们也不好确认说，你修改的这点代码有没有影响别的代码 -> 各个测试环节，全部进行全量的回归测试。

评估完了这个成本之后，你再来告诉PM，你还要不要随便这样子修改需求了？

案例式的方式，带着大家去走了一遍，修改需求的时候，会出现什么样的一个坑爹的情况。

1、需求变更的常见原因

（1）不靠谱的原因

PM不靠谱，99%的需求变更的情况，就是PM不靠谱，就是PM在进行产品设计的时候，思考这个产品需求的时候，没有考虑清楚，没有细化所有的需求，没有考虑到各种各样的情况。导致在系统开发到一半的时候，PM来搞这个事后马后炮。一开始的时候，是按照4个条件来查询，8个条件，10个条件，支持所有列双击界面上的列头，都可以按照那个列来排序。PM自己上手，1个小时就可以搞定这个事情。

大家按照PM没有考虑清楚的需求文档就开始做了，结果开发到一半儿，PM反悔了。

（2）靠谱的原因

常见于市场竞争态势的变化。

比如我们以前开发一个产品，市面上是有几个竞争对手的，BAT现在也开始在做很多产品，对外也都是竞争的。我们有一个大版本，是持续两个月的。结果在做到一半的时候，市场竞争态势出现了变化，就是竞争对手率先推出了新的功能，抢占了一些用户和市场。此时我们的高管就着急了，副总裁级别的人，副总就直接下命令说，必须在这个版本中加入某某某功能，要跟我们的竞对要持平。

我们作为技术人员的价值在哪儿？就是我们开发出来的东西，他一定是要为公司产生直接的经济效益的。节省成本，增加市场占有率，增加用户流量。

对于这种靠谱的原因，那么作为我们RD来说，义不容辞的，有价值观。我印象里有一句话，我之前就是做项目的时候，碰到过几次类似这样的情况，有同事就特别棒，他说的是，上刀山下油锅，都必须把这个东西给做出来。

如果一个RD胡乱按照自己的思维去做事情，完全不考虑公司的利益，那你作为一个RD就没有存在的价值了，可以被公司开除。

靠谱原因仅仅占比1%。

2、对待需求变更的思路

（1）对不靠谱的需求变更

第一点。

要加强需求评审的意识，就是说作为RD，你在评审产品经理编写的产品设计文档，产品需求文档的时候，你一定一定要仔细看每个环节，仔细的去思考这个产品的每个需求的细节，力求脑子里基本上就知道为了做这个需求，大概技术设计该怎么做。如果在评审需求文档的时候，你感觉可能会有坑，赶紧提出来，给PM提前提意见，让他提前调研和思考清楚，有些功能要不要做。

比如说商品查询的功能，作为一个RD，你要有一定的产品意识，当你工作了很多年之后，做了很多的项目之后，建立起来了比较丰富的工作经验，对待产品的设计，你虽然没设计过，但是你做过很多产品，你培养起来了自己的一种第六感。站在这个第六感的角度，你可以去考虑一下，每个产品需求功能，是否靠谱。比如对于商品查询的功能，你就可以站在产品设计的角度，去考量以下，诶，这个商品查询就4个条件，是不是太少了？这个时候这句话，可能就是你的第六感告诉你的。然后你就要反馈给产品经理，让它重新在考虑一下，说这个商品查询，你再想想，要不要加入更多的查询条件。

也许通过你的很牛的第六感的提议，可以让产品经理提前把一些坑给填了，不至于后面给你挖坑。

倒逼产品经理去完善需求文档，你的脑子里，在看完需求文档之后，脑子里基本要建立起来一个流程、概念和意识，就是大体上你都知道系统层面，需要怎么做系统开发，来实现这样的一些需求和功能。那么如果你在脑子里思考技术和系统实现的时候，感觉有些问题，感觉有些需求模模糊糊的，不清不楚的，那么此时就要在需求评审的时候，提出建议，让PM反过来去完善需求文档，细化，重新思考。

我们之前写好了一份需求文档，但是那份需求文档是一定有不够完善的地方的。那么接下来我们做系统的时候，就站在架构师的较多，从需求评审开始，一点一点去评审整个流程，在脑海中去思考这个系统层面怎么去做这个东西。如果感觉有不靠谱的地方，可以记录下来需求评审意见。我们自己模拟自己是产品经理，去完善这个需求文档。

这个大家不要觉得这个事情很虚，这个都是架构师非常重要的软素质。

第二点。

如果是在开发过程中，不靠谱PM提出来不靠谱的需求变更，判断出来是99%的情况，直接打回去，作为一个架构师，你要据理力争，否则如果你不断的妥协的话，你就会导致你手下的弟兄，像一群猴儿一样被PM耍的团团转。如果你接受PM提出的不靠谱的需求变更，你手下的弟兄就会各种反复加班，去修改代码，去满足那些乱七八糟的要求。你是在坑你的弟兄。

直接给他打回去，如果他一定要做，让他找产品总监，直接对接你上面的技术总监，让两个总监去PK。

如果打回去之后，因为产品总监过于强势，强行逼迫你的技术总监答应，要改动这个东西，就走后续的需求变更的流程，技术总监审批，delay 。

（2）对靠谱的需求变更

无条件接受了，但是要说清楚，肯定要走一个需求变更的流程，需要有高层领导，技术总监级别的人，要审批。

一旦有需求变更，基本上就意味着，肯定要延期，工期增加了，正常延期，找你的技术总监去审批。

3、需求变更的流程

3.1 PM发起需求变更的申请

一份需求变更的申请模板。

（1）商品系统-商品管理模块-商品查询功能

（2）原有的需求是

按照4个条件来查询商品，4个条件包括了：商品名称，商品编号，品牌，类别。

（3）现在需要将需求改动为

在4个查询条件基础之上，增加4个查询条件，分别是：商品状态、商品创建人、商品库存、商品好评率。

同时，在增加4个查询条件的基础之上，需要支持商品列表中的所有字段，都可以支持前端双击列头的时候，会自动进行排序。

（4）需求改动的原因

需要支持这样的功能，来辅助商品相关的运营人员去更好的管理商品，在需要的时候可以尽快查出想要查看的商品数据，而且支持商品列表按字段来排序。

3.2 需求变更的评估

找具体负责这个需求的同学来评估一下，要为了这个需求做哪些事情，耗费多少人日，从几号到几号，导致项目delay几天。

（1）商品系统-商品管理模块-商品查询功能

（2）将这个功能改动为

在4个查询条件基础之上，增加4个查询条件，分别是：商品状态、商品创建人、商品库存、商品好评率。

同时，在增加4个查询条件的基础之上，需要支持商品列表中的所有字段，都可以支持前端双击列头的时候，会自动进行排序。

（3）需要改动的一个步骤是

调研和评估（索引的情况，性能的情况，其他服务提供的接口情况）：1人/日

设计实现方案（详细设计文档）：1人/日

重新开发：1人/日

单元测试：1人/日

冒烟测试：1人/日

静态代码扫描：1人/日

集成测试：2人/日

系统测试：2人/日

（4）改动持续的时间

从6月5号持续到6月15号 。

（5）耗费的成本

耗费总人/日是10人/日。

（6）对项目进度的影响

导致项目整体delay达到10天。

3.3 对需求变更进行审批

架构师负责将这个需求变更的申请和评估报告，提交给技术总监。

项目delay是一个大事，轻则影响绩效，重则影响公司业务发展你要被开除，p2p领域，数一数二的龙头，XX贷。XX贷出来的一个同学，就是做一个项目，delay了一个月。领导直接二话不说，开除。北邮的硕士，XX贷公司背景也很好，但是背上了项目delay被开除的结果，到很多公司面试都碰壁。离职证明上会写明，由于该员工项目delay，所以公司决定与其解除劳动合同。

技术总监负责对这个delay的时间进行考评，考量过后，确认通过审批。

4、具体去实施这个需求变更

项目管理计划的4张图都要修改，很多任务都要delay，额外加入了一些任务。

当前正在进行的本周或者是下周的执行计划里，要修改，加入这个额外的任务。

接下来，照着修改过后的项目管理计划，和每周的执行计划，去执行就可以了，就开始干这个额外增加的新需求。

# 技术调研规范

## 技术调研规范

### 30.技术调研规范

1、什么时候做技术调研？

一般来说是在做完了需求评审之后，我们已经评审完了需求，知道了要做一个什么样的系统，大概也知道了这个系统的复杂度，功能有多少，对性能的要求是什么样子的，数据量会有多大，并发量会有多大。接着我们就会做需求分析，在需求分析之后，我们从技术角度去定义清楚了这个系统要做成什么样子，包括功能长什么样子，系统运转的流程是什么样子，有哪些特殊的需求（并发性、可用性、数据量、安全性）。

接着就是要做技术了，但是这里有个问题，可能在做技术设计之前，我们会发现说，作为架构师，你可能想要用一些新的技术，来做这个项目。比如说用Spring Boot来作为整个系统的脚手架框架， 让系统的框架整合和启动效率更加高一些；我们还希望使用一些设计模式，来更好的设计我们的系统中的各个代码组件，保证我们的系统的代码的可扩展性是非常高的；因为团队越来越大，需求越来越复杂，多团队并行开发需求，特别频繁，这个时候可能需要微服务的架构来解决这个问题，可能又要去学习Spring Cloud、DevOps等知识来做微服务的架构。

所以严格意义上来说，在需求评审过后、需求分析完成后、技术设计开始前，需要进行一些技术调研，为后续的系统设计，储备需要的技术。

2、如何去做这个技术调研？

一般来说，我的风格，一般做一个新的项目，我们都会尽可能去增加一些最新的技术，最流行的一些东西。互联网行业，好就好在这里，互联网行业是一个比较开放，快速变化，会承担很多的技术挑战的一个行业，传统IT行业是不太一样的。互联网行业，你一半要做的是说，开发一个系统出来，支撑你的这个互联网公司的整个业务的发展，此时你要承载的就是更多的用户，更大的访问量，高并发，高性能，高可用，安全性，快速迭代，你要负责去解决这些技术挑战。

而行业里，不断的每年都涌现出一些新的技术出来，都是为了解决各种各样的问题而产生的，此时对于互联网行业来说，一般就是快速的去吸收这些全新的技术和理念，思想，架构，基于这些最新的东西，来重构自己的架构设计，让自己的架构更好，可以解决更多的技术挑战和问题，更好的服务公司的业务发展。

传统的IT行业，我开发出来一个IT产品，IT系统，去服务于我的客户，为我的客户提供软件系统的功能，去更好的让我的客户的业务实现发展。IT系统，承担的用户都是一个公司内的一些员工。一般技术挑战很少，更加重要的是说，我每次接到一个单子，要做一个系统，如何能够以更低的成本，直接复用之前的代码，稍微改一改，就可以服务于新的客户，快速交付，用更少的人力去交付产品，获取利润。

如果要不断的使用新技术，就意味着传统的IT行业要不断的投入大量的人力物力去研究技术，不断的去重构自己之前已经做好的系统。这个对于传统IT行业来说，是没有意义的。如果10年前开发好的一套系统，10年后还能继续给新的用户来使用。成本很低，但是可以不断获取利润。我是传统IT企业的老板，我也不会干这事儿。对于传统IT企业来说，如果要用新技术，重新做这个系统，一定是有原因的。

之前大数据火了，其实很多传统的数据项目，用oracle搞定，但是人家客户不认，我要做大数据，流行，跟风啊，数据量很少，还得去部署那种几台机器的小集群，与运行hadoop，hbase，spark，一整套技术。oracle集群可能就搞定了。

互联网行业的公司，一般技术更好，用的技术更新，承担的技术挑战更大，出来的人技术能力更强，工资更高。互联网行业工作5年的人，薪资就在30~35k之间了。

传统IT行业的公司，一般技术较为陈旧，技术更新很慢，系统没什么技术挑战，出来的人技术能力较为平庸，工资较为平平。20~25k，少了10k，这都是有可能的。

每次做新的项目，必定会有技术调研的环节，因为在互联网行业中，拥抱新技术，快速使用新技术，尽快的去实践新技术，保证自己的系统架构是最好的。

spark课程，2015年出过spark课程，2013年~2014年某个时间点，spark 0.2.x版本，刚刚出来，很原始的时候，我当时还在BAT某公司里，我应该就是最早去实践和使用spark的人之一，在国内。spark的技术大量的实践，踩过大量的坑，积累很多的经验。所以在2015年推出了spark课程。

组织团队内的各个同学，每个人负责一个技术，去调研一下这个技术。

3、技术调研的流程和规范

3.1 技术有哪些功能

看官网，要求我的同学看官网，不行的话就买一些中文的书，或者技术博客。

写一个demo快速入门一下，对那个技术看一下初步的介绍，这个技术是干什么的。

仔细看一下这个技术官网相关的官方文档，买一本书看看，里面的重点以及核心的技术都实践一下。

3.2 技术的热门和流行程度

（1）开源技术的GitHub的更新频率：如果保持较好的更新频率，那是ok的；但是如果这个技术很少更新，那就不要考虑了。

（2）这个技术在国内的运用怎么样：是否足够热门，在国内有哪些公司在使用这个技术。

（3）这个技术在国内的中文资料是否足够多：如果中文资料足够多，就说明这个技术较为热门，有更多的资料可以参考。

3.3 技术跟公司的整体技术环境是否适合整合

比如说你如果用Spring Cloud，假如说你在阿里，那就肯定不合适了，其他一些大公司。因为那些大公司都是自己研发的微服务的整体架构，都是用自己的东西的。如果你冷不丁搞一个跟公司开发好的基础设施架构重复的东西，那肯定是不合适的。

3.4 看一下这个技术的其他的方方面面

（1）易用性：是否足够简单上手使用。

（2）稳定性：是否足够稳定可以使用，bug较少。

（3）功能性：功能是否足够完善和强大。

（4）与其他技术的整合性：能否良好的跟其他相关的技术进行整合。

（5）性能：类似Spring Boot框架，就没什么好说的了；redis，memcached，mongodb，elasticsearch。适当自己在测试环境下，做一些简单的性能测试。

（6）并发能力（吞吐量）：每秒可以承载多少请求，做一些简单的压力测试。

（7）可用性：这个技术是否提供了高可用部署的机制，比如redis就可以基于redis sentinal哨兵机制实现高可用架构，做一些简单的故障演练。

（8）伸缩性：这个技术如果需要扩容的话，是否可以扩容。

（9）扩展性：是否可以对这个技术进行一定程度上的扩展，比如说Spring Boot，就可以支持我们自己写spring-boot-starter-x的项目，支持我们自己将Spring Boot跟其他技术进行整合。

（10）安全性：这个技术是否足够安全，没有过多的安全漏洞，struts2框架，安全漏洞频频爆出。

3.5 技术跟同类技术的横向对比调研

Spring Cloud -> Dubbo -> DubboX。

Thymeleaf -> freemarker -> velocity。

Redis -> Memcached。

Elasticsearch -> Solor。

对比哪些方面呢？就是上面说的那些方面，产出一份横向对比的表格。

3.6 选择这个技术的理由

调研完了，了解清楚了这个技术了，也跟其他技术对比了优势和劣势了。

4、编写技术的培训手册

一般是用ppt的形式来变现的，主要是在决定选择使用一个新技术之后，需要将这个技术编写成使用手册，引入团队中，对团队进行培训。

（1）介绍清楚这个技术的基本原理。

（2）介绍清楚这个技术的核心功能。

（3）介绍清楚这个技术的一些调研情况。

（4）给出这个技术使用的demo，不是特别简单的demo，而是将这个技术引入我们的公司环境中，如何跟公司现有的技术栈整合，如何在公司的项目里去使用这个技术。

5、对团队里的成员进行培训

每个人都要学习清楚这个技术是怎么回事儿，在项目中来使用的时候，每个人都能得心应手

6、就可以将这个新技术用到我们的项目的技术设计中去了

7、课程里，就会对每个技术的学习，都模拟成是，你现在要为你的公司引入这门技术，然后你学习就是在做调研。完全模拟公司里真实的技术调研和引入的环境和流程以及场景。Spring Boot和设计模式。

## 概要设计

### 1.概要设计文档

编写概要设计文档，是为了指导后续的详细设计

1.逻辑架构

1.1 逻辑架构图

1.2 设计细节

1.2.1 Web服务器

采用tomcat作为web服务器，不引入apache或者是nginx这种服务器，因为第一个版本，预计的用户数量也就是100个内测用户，并发量基本低于1/s。系统主要是为了跑通咱们的系统逻辑，进行内测。所以说为了开发和部署的方便以及效率起见，直接采用tomcat作为web服务器。

1.2.2 业务系统

直接将16个中心（权限中心、商品中心、采购中心、WMS中心、会员中心、商品查询、购物车、支付中心、订单中心、物流中心、评论中心、促销中心、客服中心、财务中心、调度中心、库存中心）全部放在一个单块应用中。

不做任何的系统拆分，全部采取B/S架构，接口对外提供服务。因为刚开始我们开发人员很少，不需要做太多的服务拆分，全部耦合在一个服务中，开发所有的代码，效率反而是最高的。

1.2.3.脚手架框架

采用目前业界最新最热门最流行的spring boot技术，作为脚手架框架，利用spring boot与其他的框架技术快速的整合。同时spring boot的可扩展性非常好，未来如果要用到缓存、mq等其他的技术，都可以快速的跟spring boot脚手架进行整合。

而且，团队已经初步对spring boot完成了技术调研，spring boot 20%的核心功能都已经掌握的很扎实了。

1.2.4.MVC框架

采取业界最流行的spring web mvc框架即可

1.2.5.IOC/AOP框架

采取业界最流行的spring core框架即可

1.2.6.ORM框架

采取业界最流行的mybatis3框架，不采用纯粹的ORM框架，hibernate，是因为类似hinernate那样的框架太重了，黑盒，自动生成的那个SQL性能较差。所以不建议采用hibernate。反而是mybatis框架基本可以自己手写sql语句，灵活，通用，很方便。

1.2.7.数据库

采用MySQL作为数据库，因为oracle数据库到了后期使用要付费，费用高昂，而且扩展性不是很好。目前互联网行业最通用的都是采用mysql数据库，哪怕是后面数据量大了，要分库分表，也有很多成熟的方案可以用。

1.2.8.基础设施

机器，网络，基础设施，采用阿里云，因为目前行业里国内，基本上就是这个阿里云的产品最好，稳定性，技术支持能力最好。我们作为一个初创型团队，不应该直接自己花很多的钱去采购和运维管理自己的服务器，那样的话成本太高了，而且很麻烦。

1.2.9.日志框架

采用spring boot默认支持的logback作为日志框架即可

1.2.10.系统监控

第一个版本主要是内测，不需要复杂的系统监控，只需要使用spring boot actuator提供的简单的健康检查监控即可。

3.运行架构

3.1.系统核心流程

3.1.1.采购流程时序图

3.1.2.购物流程时序图

3.1.3.退货流程时序图

3.2.功能时序图

4.物理架构

4.1.软件架构

4.2.硬件架构

4.2.1.开发环境

4.2.2.集成测试环境

4.2.3.系统测试环境

4.2.4.验收测试环境

4.2.5.线上环境

## 概要设计评审

### 2.设计文档技术评审

1、并发层面的问题

如果未来并发量持续增长，tomcat服务器可以部署集群+前面的负载均衡设备。

但是mysql是单库单表，会有并发的瓶颈，一般来说，mysql单服务器承载的并发不能超过2k。如果mysql单库的写并发到1.5k的时候，建议就要分库了；如果mysql单库的读并发到1.5k的时候，建议就要挂主从架构，读写分离，挂多个从库。

所以目前架构设计中的mysql单库单表可能未来会是一个风险点。但是现在系统刚起步，可以先这么做，但是以后要去考量这个事情。

2、伸缩性

tomcat是没有问题的，只要加机器就可以了。

但是你的业务系统，是否具备伸缩性，要仔细去考量一下。就是说，如果你的设计里面，你的业务系统必须用单个服务实例承接所有的请求才能正常工作，一旦你业务系统部署多个实例，请求落到不同的服务实例上，会导致请求处理出错，那么就意味着你的业务系统只能部署单个实例。

如果是这样子的话，那你的业务系统就不具备可伸缩的能力，因为他是没有办法去扩容的。

但是这里主要是提醒一下，在后面做详细设计的时候，务必要考量到这一点。

举个例子吧，假设，某个订单，被你的某个服务实例在内存中维护了一个什么状态。此时就导致，如果这个订单相关的请求落到其他的服务实例上去，会导致你的整个程序出错。那么此时，你的系统就是不可伸缩的。你只能要求所有的请求都要落到一个服务实例上，才能完成正确的操作，那你不能扩容了。

mysql，单库单表，是典型的不可伸缩。你即使加更多的mysql服务器，也是搞不定的。所以以后要让mysql可伸缩，必须结合业务去设计对应的分库分表的mysql架构。

3、可用性

（1）tomcat+业务系统的部署，都是单机部署的，那么意味着，只要这个机器，或者是这个机器上的tomcat，或者是这个tomcat里部署的业务系统，挂掉了，那么整个系统就挂掉了，可用性很差

（2）mysql，只要一个mysql宕机了，那么数据库就挂了，一旦数据库挂了，那么整个系统就挂掉了，可用性很差

所以在现在初期，先不用考虑，但是以后架构必须得去考量这个可用性的问题

4、 扩展性

扩展性很差，因为你如果要大团队协作，多人开发，会发现说，这里的模块耦合太严重了。都耦合在了一个单块应用中，到了后期，几十个人修改一个工程，大量的代码冲突，不同的项目不同的版本之间的测试、开发的排期大量的冲突，互相之间占用测试环境，你等我，我等你。然后的话，上线，也是的。

假设，我们现在有3个项目并行在做，分别是3个小team在做，一起修改一个单块应用。然后其中一个项目的上线时间定在了07.01，那么这就意味着什么呢？项目二的上线时间就不能定在07.01，如果项目二和项目一同一天上线，就意味着大家要耦合在一起做测试啊什么的，是不可能的。这样的话，就导致项目二只能定在07.02，然后同理，项目三只能定在07.03.

这个还只是3个项目，如果是30个项目呢？上百人开发。

比如你临时修复了一个bug，要上线，这个时候怎么办？可能有其他团队正要上线呢，你还得等他们先上线，然后你再上线呢？

暂时不用解决，1+4的一个小team，单块应用。10个人以上，那就不太合适了。

5、 安全性

目前没有考虑任何的安全性的措施，裸奔。内测，仅仅面向部分少量的用户，用一些测试数据来内测，所以还好。

6、 高性能

性能肯定的是有问题的，大量的全部基于数据库来操作，没有任何的缓存，或者是MQ介入，那么性能肯定是会差很多的

7、 稳定性

系统会不会频繁的出一些bug和未知的一些问题，排查问题的效率和解决问题的效率怎么样？日志，通过日志可以排查和解决问题。

但是监控这一块，做的比较low，只能通过spring boot提供的接口，人肉时不时上去看看，调用一下接口看一眼。没有那种自动化的监控系统，可以看到问题，然后直接发短信、邮箱通知RD。

## 详细设计

### 3.权限中心详细设计文档

1、数据架构设计

1.1 数据库ER模型

1.2 数据库逻辑模型

1.3 数据库物理模型

2、接口设计

2.1 权限管理

2.1.1 根权限列表查询

（1）接口所属的类

（2）接口定义

GET /api/v1.0/auth/priority/roots/

（3）接口描述

查询所有的根权限

（4）输入

（5）输出

2.1.2 子权限列表查询

（1）接口所属的类

（2）接口定义

GET /api/v1.0/auth/priority/children/{id}

（3）接口描述

查询某个权限的子权限

（4）输入

权限id

（5）输出

2.1.3 添加权限

（1）接口所属的类

（2）接口定义

POST /api/v1.0/auth/priority/

（3）接口描述

添加权限

（4）输入

（5）输出

2.1.4 查询权限

（1）接口所属的类

（2）接口定义

GET /api/v1.0/auth/priority/{id}

（3）接口描述

查询某个权限

（4）输入

（5）输出

2.1.5 更新权限

（1）接口所属的类

（2）接口定义

PUT /api/v1.0/auth/priority/{id}

（3）接口描述

更新权限

（4）输入

（5）输出

2.1.6 删除权限

（1）接口所属的类

（2）接口定义

DELETE /api/v1.0/auth/priority/{id}

（3）接口描述

删除权限

（4）输入

（5）输出

2.2 角色管理

2.2.1 查询角色列表

（1）接口所属的类

（2）接口定义

GET /api/v1.0/auth/role/

（3）接口描述

查询角色列表

（4）输入

（5）输出

2.2.2 添加角色

（1）接口所属的类

（2）接口定义

POST /api/v1.0/auth/role/

（3）接口描述

添加角色

（4）输入

（5）输出

2.2.3 查询角色

（1）接口所属的类

（2）接口定义

GET /api/v1.0/auth/role/{id}

（3）接口描述

添加角色

（4）输入

（5）输出

2.2.4 更新角色

（1）接口所属的类

（2）接口定义

PUT /api/v1.0/auth/role/{id}

（3）接口描述

更新角色

（4）输入

（5）输出

2.2.5 删除角色

（1）接口所属的类

（2）接口定义

DELETE /api/v1.0/auth/role/{id}

（3）接口描述

删除角色

（4）输入

（5）输出

2.2.6 启用/停用角色

（1）接口所属的类

（2）接口定义

PUT /api/v1.0/auth/role/enabled/{id}

（3）接口描述

更新角色的启用状态

（4）输入

（5）输出

2.3 账号管理

2.3.1 查询账号列表

（1）接口所属的类

（2）接口定义

GET /api/v1.0/auth/account/

（3）接口描述

查询账号列表

（4）输入

（5）输出

2.3.2 添加账号

（1）接口所属的类

（2）接口定义

POST /api/v1.0/auth/account/

（3）接口描述

添加账号

（4）输入

（5）输出

2.3.3 查询账号

（1）接口所属的类

（2）接口定义

GET /api/v1.0/auth/account/{id}

（3）接口描述

查询账号

（4）输入

（5）输出

2.3.4 更新账号

（1）接口所属的类

（2）接口定义

PUT /api/v1.0/auth/account/{id}

（3）接口描述

更新账号

（4）输入

（5）输出

2.3.5 删除账号

（1）接口所属的类

（2）接口定义

DELETE /api/v1.0/auth/account/{id}

（3）接口描述

删除账号

（4）输入

（5）输出

2.3.6 启用/停用账号

（1）接口所属的类

（2）接口定义

PUT /api/v1.0/auth/account/enabled/{id}

（3）接口描述

更新账号的启用状态

（4）输入

（5）输出

2.3.7 修改密码

（1）接口所属的类

（2）接口定义

PUT /api/v1.0/auth/account/password/{id}

（3）接口描述

更新账号的密码

（4）输入

（5）输出

2.4 权限控制

2.4.1 查询账号有权限的菜单树

上来先查询账号有权限的根菜单权限，显示在页面左侧的菜单栏里，如果用户点击某个菜单，异步加载那个菜单下面的子菜单即可

（1）接口所属的类

（2）接口定义

GET /api/v1.0/auth/priority/tree/authorized/?accountId=1

（3）接口描述

查询某个账号被授权的菜单树

（4）输入

（5）输出

2.4.2 查询账号对某个权限是否授权

在页面上，显示了某个按钮的时候，对那个按钮是否显示需要使用特殊的标签，在标签里给一个按钮对应的权限的编号，然后后台会去查询账号对这个编号的权限，是否有授权

（1）接口所属的类

（2）接口定义

GET /api/v1.0/auth/priority/authorized/{id}?accountId=1

（3）接口描述

查询某个账号对某个权限是否授权

（4）输入

（5）输出

2.4.3 请求URL权限控制

这一块接口，不是对外提供的web http接口，不是给其前端调用的，是给我们后面要写一个全局的过滤器，对所有的请求都要过滤，然后在过滤器中调用这里的接口，查看当前登录的这个用户是否有权限执行某个请求

（1）接口类

PriorityService

（2）接口定义

Boolean checkPriorityAuthorized(Long accountId, String url)

（3）接口描述

查询某个账号对某个权限是否授权

（4）输入

（5）输出

3、开发架构设计

3.1 实现类图设计

根据之前的需求分析文档、概要设计文档、数据库模型、接口，去考虑，实现接口的功能，需要哪些类，类与类之间的关系是什么，每个类有哪些成员变量，每个类有哪些方法

在这里说明一点，这里其实就是所谓的Java面向对象编程的核心所在，这里其实是很体现一个工程师的水平的

UML的类图里，其实就三点

（1）把每个类都画出来

（2）类与类之间的继承关系画出来，实线+空心箭头

（3）接口实线关系，虚线+空心箭头

（4）依赖关系，虚线+简单箭头

（5）关联关系，实线+简单箭头

（6）组合关系，实心菱形+实线+简单箭头

（7）聚合关系，空心菱形+实线+简单箭头

3.2 包设计

在UML中有包图的概念，我在这里先补讲，我比较少用

至少你要设计出来，你有哪些包，每个包下面有哪些类

com.zhss.eshop.order.domain

com.zhss.eshop.order.controller

com.zhss.eshop.order.mapper

com.zhss.eshop.order.dao

com.zhss.eshop.order.service

4.1 权限管理

4.1.1 根权限列表查询

直接查询出来所有的根权限即可，就是没有parentId就是根权限。

4.1.2 子权限列表查询

根据parentId去查询某个权限的子权限即可

4.1.3 添加权限

将权限信息保存到数据库即可

4.1.4 查询权限

根据权限ID来查询即可

4.1.5 更新权限

根据权限ID来跟新即可

4.1.6 删除权限

这块必须要进行递归删除，也就是说，你要删除一个权限的话：

第一，你必须先删除最底层的子权限，然后一级一级往上删除，删除到当前的权限

第二，你除了删除权限之外，你还得care一下角色、账号跟权限之间的关联关系，我们要做一个check，也就是说，如果这个权限还跟有一些角色和账号跟之进行关联，就不能直接删除

第三，此处采用设计模式，组合模式+访问者模式，采用组合模式，在这里将权限组装成一颗树，或者是不用提前组装，就是不断的去递归动态组装出来一颗树也可以。然后对这颗树注入一个删除的visistor访问者，这样，以后我们还可以动态注入别的visitor来实现对这颗权限树的不同的操作。

第四，在对这棵树递归删除的过程中，如果发现某个权限还被别人给引用，此时要返回一个特殊的状态码，这个状态码要标明某一级权限还被某个角色或者是账号在引用，就不能直接这样删除，需要回滚整个事务。

我们在这里因为要采取设计模式，所以需要为了这块东西，单独设计一套类出来

这个场景，应该是完美的可以让我们后面去实践组合模式和访问者模式的一个场景，就是我们需要开发两个visitor，第一个visitor需要遍历所有子权限，判断是否有某个权限还被账号或者角色在关联着；第二个visitor，是如果全包所有的子权限都没有被别人在关联，那么就递归删除

4.2 角色管理

4.2.1 查询角色列表

根据筛选条件+分页查询角色即可

4.2.2 添加角色

（1）先添加角色

（2）添加角色和权限之间的关系

4.2.3 查询角色

（1）根据ID查询角色

（2）查询角色被授予的权限ID列表

4.2.4 更新角色

（1）更新角色

（2）将角色与权限的关联关系都删除

（3）重新插入角色与权限的关联关系

4.2.5 删除角色

（1）是否有账号关联了这个角色，如果有是不允许删除角色的

（1）删除角色跟权限的关联关系

（2）删除角色本身

4.2.6 启用/停用角色

（1）是否有账号关联了这个角色，如果有是不允许停用角色的

（2）更新角色的启用状态即可

4.3 账号管理

4.3.1 查询账号列表

根据筛选条件分页查询账号列表即可

4.3.2 添加账号

（1）添加账号

（2）添加账号和角色的关联关系

（3）添加账号和权限的关联关系

4.3.3 查询账号

（1）查询账号

（2）查询账号关联的角色id

（3）查询账号关联的权限id

4.3.4 更新账号

（1）更新账号

（2）删除账号与角色的关联关系，再插入新的账号与角色的关联关系

（3）删除账号与权限的关联关系，再插入新的账号与权限的关联关系

4.3.5 删除账号

（1）删除账号与角色的关联关系

（2）删除账号与权限的关联关系

（3）删除账号本身

4.3.6 启用/停用账号

直接更新账号的状态即可

4.3.7 修改密码

直接更新账号的密码即可

4.4 权限控制

4.4.1 查询账号有权限的菜单树

（1）查询这个账号有权限的根菜单

（2）使用visitor去递归每个根菜单，对每个根菜单都去查询这个账号有权限的子菜单，填充为根菜单的子菜单

（3）以此类推，就可通过visitor得到一颗账号有权限的菜单树

4.4.2 查询账号对某个权限是否授权

在页面上，对每个按钮，都有一个标签，对这个按钮对应的权限的编号，去查询这个用户对这个编号的权限，有没有授权。

（1）查询这个编号对应的权限

（2）查询这个账号对这个权限是否有授权，然后一条SQL，关联账号表、角色表、权限表，去查询

4.4.3 请求URL权限控制

这一块接口，不是对外提供的web http接口，不是给其前端调用的，是给我们后面要写一个全局的过滤器，对所有的请求都要过滤，然后在过滤器中调用这里的接口，查看当前登录的这个用户是否有权限执行某个请求

（3）查询这个URL对应的权限

（4）查询这个账号对这个权限是否有授权，然后一条SQL，关联账号表、角色表、权限表，去查询

5、测试用例设计

5.1 单元测试用例设计

要求，就是对每个controller、service、dao组件的每个方法，都进行单元测试

5.2 冒烟测试用例设计

要求，是系统在本地运行起来，直接依赖了数据库之后，对controller层所有的接口访问都可以正常工作

6、日志设计

要求的是每一层，每一个类都捕获自己的异常，然后对异常要求必须打印详细的日志

## 测试

### 1.测试

1.在集成测试环境的机器上，其实是应该让这个系统去连接集成测试环境的mysql数据库的，所以这个配置呢就跟在开发环境连接的那个数据是不一样的。

所以这个问题需要用maven profile支持多环境的配置文件的适配.

部署，就是打一个jar包，在各个环境下启动，就ok了。而且初期，雏形版，其实就是给CEO和投资人看看的。就团队内部几个人，有几个账号，各个RD，各个前端，各个产品，运用，去试用一下。其实几乎可以认为就没什么用户。根本也没什么所谓的并发量和这个压力。

尽快结束项目阶段一，就是在我的本地windows机器，模仿成是各个环境的机器就可以了。然后各个环境的数据库，我就用本地mysql里的不同的库名就可以了。

spring boot也可以支持多profile。我个人不用spring boot profile，慎用。如果你以后系统变得很复杂了，我自己之前设计过一个系统，他就是要自己搞一个针对自己系统的复杂的xml文件，此时你用spring boot profile是不太合适的。

很多大公司里，是用公司统一的部署框架去部署的，要求的是你的系统针对不同的环境可以提供不同的指定的文件，META-INF/boot.properties。

2.其实我们正经的在公司里的集成测试，我们应该此时就是使用develop分支的代码，使用beta profile（连接的都是集成测试环境的一些基础设施，mysql），去打一个包。然后将这个jar包，用scp给上传到集成测试服务器上去，然后java -jar就可以在集成测试环境启动我们的系统。然后QA，就可以对集成测试环境的系统进行测试。

一般来说，在企业中，mysql这块，基础设施这块，都是分成两个环境。测试环境，生产环境。测试环境比如说会搞一个mysql服务器，但是里面会建不同环境的数据库，eshop-dev，eshop-beta，eshop-test。用master分支的代码，在验收测试服务器上部署，然后连接的直接就是eshop-prod库，使用的是生产环境的mysql服务器；master分支代码，在生产机器上部署，直接连接eshop-prod库。

集成测试，我不说太细的，这块其实是QA（测试工程师的领域），不是我们的领域，是配合。开发、单元测试、冒烟测试，工程、部署。构造测试用例，如何细细的去测试这个东西，是测试工程师的活儿。

集成测试，测试用例不会太多，一般来说就是构建一些能让系统核心主流程跑通即可。

系统测试，正儿八经，往死里测，一般好的测试工程师，丰富的测试经验，丰富的测试用例构造的经验，构造出来大量的测试用例，下订单

各种测试用例，A商品绑定了促销活动1，B商品绑定了促销活动2 -> 订单，看看怎么样；A商品绑定了促销活动2，B商品绑定了促销活动1 -> 订单。实验出来几乎所有的线上用户可能进行的操作，全部给你覆盖到。一般来说 ，都要3~5轮测试。起码3轮。测到最后，所有的测试用例跑过去，没什么bug。

验收测试之前，也会有其他的环节，压力测试（模拟比如瞬间10万人，100万并发过来，看系统的响应速度和能不能抗住）；性能测试（精细的去测试你的每个主流程，每个操作，响应时间一般在多久）；可用性测试（比如说，给你模拟，redis突然宕机了，再继续下单，看看你的降级措施有没有奏效）

验收测试，不是QA的事儿了，一般是产品经理，负责一个头儿，一个尾巴。开发之前，产品经理告诉你，你得做成什么样子；中间产品经理会时不时的跑过来关心你们，看你们搞的怎么样了，甚至可能有些公司，工程师的项目管理太挫了，PM会冲上来顶住，召集一群RD做项目管理；尾巴的时候，就是到验收测试的环节，PM上来，在验收测试环境，会给PM开通一个测试账号，模拟自己就是个小白用户，各种下单，确定她说，很满意。验收通过。

就是咱们，部署上线，上生产环境

3.比如有5个人+一个QA一起集成测试，会指定一个人专门部署系统，拉取最新分支，打包，scp上传到集成测试服务器上去，启动

但是只要有QA发现了bug，5个人一起排查，发现是谁的bug，谁就将develop分支拉取到自己的本地，首先是在本地基于QA反馈的操作，复现出来那个bug。然后修复bug，然后修复好之后，验证bug是修复好了。将代码提交到develop分支上去。5个人谁都可以修改develop分支的代码。

通知那个专门部署的人，重新拉取代码，打包，部署

QA重新执行测试用例，验证bug已经修复了

QA也是走几轮的，第一轮，QA先把预备好的所有测试用例执行一遍，发现一堆bug，反馈给你们5个人，每个人认领相关的bug。然后吭哧吭哧修复一段bug。

然后第二轮开始之前，专门有个人部署一下

QA再开始测第二轮，就是再把所有的测试用例执行一遍

循环往复，直到集成测试通过，一个bug都没有了

4.已经完成了集成测试了

develop分支，集成了所有人的代码，beta profile（连接的是eshop-beta库），你在公司里应该用beta profile打一个jar包，部署到集成测试环境的机器上去

QA开始搞这个集成测试，所有人都基于develop分支去进行bug的fix

目前的状态，就是主流程全部都跑通了

测试用例是比较少的，主要是确保主流程跑通，对各种各样的异常情况，是不测试的

系统测试，release分支，在码云上，通过develop分支拉一个release分支出来（release/v1.0.0），刚拉出来的时候肯定是跟develop分支一模一样的。搞一个test profile（连接的是eshop-test库）。基于release分支的代码和test profie打一个jar包，部署到系统测试环境的机器上去。

QA开始搞系统测试，功能测试，QA会用预先准备好的大量的测试用例，来进行测试。就比如下订单这个环节。就是一个测试用例，相当于就是一个订单里一个商品，那个商品就绑定了一个直接折扣的促销活动，优惠券就是用了一个现金券。

QA会下N多个订单，有一个订单购买了两个商品，一个商品使用了赠品促销活动，一个商品使用了满减促销活动，然后使用了满减优惠券；另外一个订单，一个商品使用了满赠促销活动，另外一个商品没有使用促销活动，同时没有使用优惠券。QA的责任，就是去模拟出线上几乎所有可能发生的用户会执行的操作，都给地毯式的铺一边。

参差不齐，一般的QA，在这个环节，如果自己经验不丰富，对QA的知识不够全面，可能会导致测试的时候，漏掉了很多的测试用例。

我们不会自己去做，但是我们会模拟一下，先搞一个release/v1.0.0分支出来，就是搞一个test profile，然后再搞一个eshop-test库，模拟一下。

git fetch origin

git checkout -b 本地分支 origin/远程分支

然后就是所有人都基于release/v1.0.0分支进行调试，QA在这一轮起码是3轮，甚至可能是5轮。上千个bug都有可能，RD写的代码太烂了。一两百个bug。

每个人修复好了自己的bug，都直接在release分支上修改代码，然后直接提交代码

修复好了第一轮的bug之后，再次打包部署，让QA再次测试第二轮

依次循环往复，直到系统测试环节所有测试用例执行完，没有bug了，那么这个环节就是结束

5.基于release/v1.0.0分支，和test profile，eshop-test库，完成了系统测试，整个系统现在基本已经没有什么bug了

此时需要将release/v1.0.0分支，合并到master分支上去，然后直接基于master分支的代码，加上prod profile，连上eshop-prod库，但是这个打好的jar包，是部署在验收测试环境的服务器上的

v1.0.0版本的master分支的代码，加上prod profile，连上eshop-prod库，但是是部署在线上服务器上在跑着，线上服务器上跑着，基于域名直接对线上的用户请求提供访问。

但是如果我们开发好了比如下一个版本，v1.1.0版本的代码，release/v1.1.0合并到了master分支，要做验收测试，此时master分支已经混合了v1.1.0版本的代码，当然此时不能直接部署在线上服务器的

但是完全可以将v1.1.0版本的master代码，基于prod profile连上生产库，部署在验收测试环境的服务器上，此时产品经理可以使用一个测试账号，通过验收测试环境的服务器，来使用我们的系统，使用测试账号来下订单什么的，验收他期望的系统德全流程。

前端做的v1.1.0版本的前端代码，此时也会同时部署在他们的前端的验收测试环境的服务器上，连接的是我们的后端的验收测试环境的服务器，staging机器。所以产品经理就可以从前端的staging机器部署的url进入系统来访问，此时呢用的数据是线上库，但是代码是混合了最新的v1.1.0版本的。

上面的是一种验收测试的流程，还有一种流程，如果你的新版本的代码，没法直接使用线上库，该怎么办呢？肯定还是用master分支，但是会开一个staging profile，连接的是eshop-staging库。做一遍验收，这个环境就是专门给产品经理来验收的。

一般来说我比较提倡的是第二种模式，我个人认为，环境要划分清楚，要分开，不能搞的太混合太模糊了。master分支代码，staging profile，eshop-staging库来验收测试。

# 系统上线

### 1.系统上传checklist

1、RD自测报告

1.1 小C的自测报告

（1）静态代码扫描报告

（2）单元测试覆盖率报告

（3）冒烟测试报告

（4）code review结果

2、系统测试报告

2.1 集成测试报告

（1）第一轮集成测试报告

（2）第二轮集成测试报告

（3）第三轮集成测试报告

2.2 系统测试报告

（1）第一轮系统测试报告

（2）第二轮系统测试报告

（3）第三轮系统测试报告

2.3 验收测试报告

（1）验收测试报告

这份文档，需要由项目的架构师/leader，来在上线之前，收拢好，编写好，里面应该包含所有的报告，发给技术总监。技术总监是不负责一线的带项目，一线带项目的一般都是所谓的架构师，或者是技术经理。

### 2.系统上线步骤

1、数据库初始化

（1）小C和小D负责建库建表，建立对应的prod profile

（2）老A和老B负责检查所有的SQL语句是否使用了对应的表的索引

（3）老K负责最后确认

2、部署系统到线上机器

（1）先对master分支打一个tag，标注我们的这个v1.0.0的版本

（2）基于master分支的代码和prod profile将完整的代码，打成jar包

（3）然后用scp将jar包上传到zhss-eshop-prod机器上去

（4）使用java -jar命令启动线上系统

3、线上验证

（1）观察系统是否将日志打印到了我们指定的日志文件中去

（2）观察系统是否打印出了我们指定的系统初始化的日志

（3）PM负责在线上系统，使用测试账号，将核心主流程执行一遍，确认无误，上线成功

git tag -d <tagname> git push origin :refs/tags/<tagname>

