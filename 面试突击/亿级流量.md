# 亿级流量

## 数据存储

### 1.亿级流量系统架构之如何支撑百亿级数据的存储与计算

数据产品最核心的业务流程：

每天从用户使用的大量业务系统中实时的采集过来各种业务数据 接着存储在自己的数据中心里 然后实时的运算大量的几百行~上千行的SQL来生成各种数据报表 最后就可以提供这些数据报表给用户来分析。

从0到1的过程中上线的最low版本

数据平台只要想个办法把业务系统的数据采集过来，接着放在MySQL的各种表里，直接咔嚓一下运行100多个几百行的大SQL，然后SQL运行结果再写到另外一些MySQL的表里作为报表数据，接着用户直接点击报表页面查询MySQL里的报表数据，就可以了！

海量数据存储和计算的技术挑战

第一个技术挑战，数据量越来越大，SQL跑的越来越慢，MySQL服务器压力越来越大。

离线计算与实时计算的拆分

将昨天以及昨天以前的数据都放在大数据存储中，进行离线存储和离线计算，然后只有今天的数据是实时的采集的。第一次架构重构的核心要义，就是将离线计算与实时计算进行拆分。

## 高并发

### 1.如何设计一个高并发系统？

可以分为以下 6 点：

- 系统拆分
- 缓存
- MQ
- 分库分表
- 读写分离
- ElasticSearch

系统拆分

将一个系统拆分为多个子系统，用 dubbo 来搞。然后每个系统连一个数据库，这样本来就一个库，现在多个数据库，不也可以扛高并发么。

缓存

缓存，必须得用缓存。大部分的高并发场景，都是读多写少，那你完全可以在数据库和缓存里都写一份，然后读的时候大量走缓存不就得了。毕竟人家 redis 轻轻松松单机几万的并发。所以你可以考虑考虑你的项目里，那些承载主要请求的读场景，怎么用缓存来抗高并发。

MQ

MQ，必须得用 MQ。可能你还是会出现高并发写的场景，比如说一个业务操作里要频繁搞数据库几十次，增删改增删改，疯了。那高并发绝对搞挂你的系统，你要是用 redis 来承载写那肯定不行，人家是缓存，数据随时就被 LRU 了，数据格式还无比简单，没有事务支持。所以该用 mysql 还得用 mysql 啊。那你咋办？用 MQ 吧，大量的写请求灌入 MQ 里，排队慢慢玩儿，后边系统消费后慢慢写，控制在 mysql 承载范围之内。所以你得考虑考虑你的项目里，那些承载复杂写业务逻辑的场景里，如何用 MQ 来异步写，提升并发性。MQ 单机抗几万并发也是 ok 的，这个之前还特意说过。

分库分表

分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个表，每个表的数据量保持少一点，提高 sql 跑的性能。

读写分离

读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。读流量太多的时候，还可以加更多的从库。

ElasticSearch

Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。

### 2.在项目中，如何应对高并发流量

**应对大流量的一些常见手段是什么？**

**缓存**：说白了，就是让数据尽早进入缓存，离程序近一点，不要大量频繁的访问DB。

**降级**：如果不是核心链路，那么就把这个服务降级掉。打个比喻，现在的APP都讲究千人千面，拿到数据后，做个性化排序展示，如果在大流量下，这个排序就可以降级掉！

**限流**：大家都知道，北京地铁早高峰，地铁站都会做一件事情，就是限流了！想法很直接，就是想在一定时间内把请求限制在一定范围内，保证系统不被冲垮，同时尽可能提升系统的吞吐量。

**有些时候，缓存和降级是解决不了问题的，比如，电商的双十一，用户的购买，下单等行为，是涉及到大量写操作，而且是核心链路，无法降级的，这个时候，限流就比较重要了。**

限流的常用方式

计数器

**计数器是一种比较简单的限流算法，用途比较广泛，在接口层面，很多地方使用这种方式限流。在一段时间内，进行计数，与阀值进行比较，到了时间临界点，将计数器清0。**

这里需要注意的是，存在一个时间临界点的问题。举个栗子，在12:01:00到12:01:58这段时间内没有用户请求，然后在12:01:59这一瞬时发出100个请求，OK，然后在12:02:00这一瞬时又发出了100个请求。这里你应该能感受到，在这个临界点可能会承受恶意用户的大量请求，甚至超出系统预期的承受。

滑动窗口

**滑动窗口的意思是说把固定时间片，进行划分，并且随着时间的流逝，进行移动，这样就巧妙的避开了计数器的临界点问题。也就是说这些固定数量的可以移动的格子，将会进行计数判断阀值，因此格子的数量影响着滑动窗口算法的精度。**

漏桶

虽然滑动窗口有效避免了时间临界点的问题，但是依然有时间片的概念，而漏桶算法在这方面比滑动窗口而言，更加先进。

**有一个固定的桶，进水的速率是不确定的，但是出水的速率是恒定的，当水满的时候是会溢出的。**

**令牌桶**

注意到，漏桶的出水速度是恒定的，那么意味着如果瞬时大流量的话，将有大部分请求被丢弃掉（也就是所谓的溢出）。为了解决这个问题，令牌桶进行了算法改进。

**生成令牌的速度是恒定的，而请求去拿令牌是没有速度限制的。这意味，面对瞬时大流量，该算法可以在短时间内请求拿到大量令牌，而且拿令牌的过程并不是消耗很大的事情。（有一点生产令牌，消费令牌的意味）**

**不论是对于令牌桶拿不到令牌被拒绝，还是漏桶的水满了溢出，都是为了保证大部分流量的正常使用，而牺牲掉了少部分流量，这是合理的，如果因为极少部分流量需要保证的话，那么就可能导致系统达到极限而挂掉，得不偿失。**

限流神器：Guava RateLimiter

Guava不仅仅在集合、缓存、异步回调等方面功能强大，而且还给我们封装好了限流的API！

Guava RateLimiter基于令牌桶算法，我们只需要告诉RateLimiter系统限制的QPS是多少，那么RateLimiter将以这个速度往桶里面放入令牌，然后请求的时候，通过tryAcquire()方法向RateLimiter获取许可（令牌）。

分布式场景下的限流

**上面所说的限流的一些方式，都是针对单机而言的，其实大部分的场景，单机的限流已经足够了。分布式下限流的手段常常需要多种技术相结合，比如Nginx+Lua，Redis+Lua等去做。本文主要讨论的是单机的限流，这里就不在详细介绍分布式场景下的限流了。**

**一句话，让系统的流量，先到队列中排队、限流，不要让流量直接打到系统上。**

## MySQL

### 1.用Java 怎么实现有每天有1 亿条记录的DB 储存？MySQL 上亿记录数据量的数据库如何设计？

1.这么大数据量首先建议 使用大数据的DB，可以用spring batch 来做类似这样的处理。定量向DB 存储数据。如果需要定时，可以考虑 quartz。

Mysql 数据库设计: 1.读写分离； 2.纵向横向拆分库、表。 MySQL 的基本功能中包括replication（复制）功能。所谓replication，就是确定master以及与之同步的slave 服务器，再加上slave 将master 中写入的内容polling 过来更新自身内容的功能。这样slave 就是master 的replica（复制品）。这样就可以准备多台内容相同的服务器。

通过master 和salve 的replication，准备好多台服务器之后，让应用程序服务器通过负载均衡器去处理查询slave。这样就能将查询分散到多台服务器上。

应用程序实现上应该只把select 等读取之类的查询发送给负载均衡器，而更新应当直接发送给master。要是在slave 上执行更新操作，slave 和master 的内容就无法同步。MySQL 会检测到master 和slave 之间内容差异，并停止replication，这回导致系统故障。Slave 可以采用LVS（linux 系统自带的负载均衡器）实现查询的负载均衡。使用MySQL 的replication 是利用的冗余化，实现冗余化需要实现的最小服务器数量是4 台，三台slave 和一台master，slave 为什么是需要三台呢，比如一台slave 死机了，现在需要修复再次上线，那么意味着你必须停止一台slave 来复制MySQL 的数据，如果只有两台slave，一台坏了，你就必须停止服务，如果有三台，坏了一台，你复制数据时停止一台，还有一台可以运维。

对于数据的处理是能放入到内存中就尽量放入到内存中如果不能放入到内存中，可以利用MySQL 的Partitioning。Partitioning 就是表分割也就是讲A 表和B 表放在不同的服务器上。简单来说，Partitioning 就是充分利用局部性进行分割，提高缓存利用效率，从而实现Partitioning的效果。其中最重要的一点就是以Partitioning 为前提设计的系统将表分割开，用RDBMS 的方式的话，对于一对多的关系经常使用JOIN 查询将两张表连接起来。但是如果将表分割开了之后，也就是两张表不在同一个数据库，不在同一个服务器上怎样使用JOIN 操作，这里需要注意的是如果是用where in 操作不是省了一些麻烦了嘛。



## 缓存

### 1.缓存架构

（1）如何让redis集群支撑几十万QPS高并发+99.99%高可用+TB级海量数据+企业级数据备份与恢复？：redis企业级集群架构

（2）如何支撑高性能以及高并发到极致？同时给缓存架构最后的安全保护层？：(nginx+lua)+redis+ehcache的三级缓存架构

（3）高并发场景下，如何解决数据库与缓存双写的时候数据不一致的情况？：企业级的完美的数据库+缓存双写一致性解决方案

（4）如何解决大value缓存的全量更新效率低下问题？：缓存维度化拆分解决方案

（5）如何将缓存命中率提升到极致？：双层nginx部署架构，以及lua脚本实现的一致性hash流量分发策略

（6）如何解决高并发场景下，缓存重建时的分布式并发重建的冲突问题？：基于zookeeper分布式锁的缓存并发重建解决方案

（7）如何解决高并发场景下，缓存冷启动MySQL瞬间被打死的问题？：基于storm实时统计热数据的分布式快速缓存预热解决方案

（8）如何解决热点缓存导致单机器负载瞬间超高？：基于storm的实时热点发现，以及毫秒级的实时热点缓存负载均衡降级

（9）如何解决分布式系统中的服务高可用问题？避免多层服务依赖因为少量故障导致系统崩溃？：基于hystrix的高可用缓存服务，资源隔离+限流+降级+熔断+超时控制

（10）如何应用分布式系统中的高可用服务的高阶技术？：基于hystrix的容错+多级降级+手动降级+生产环境参数优化经验+可视化运维与监控

（11）如何解决恐怖的缓存雪崩问题？避免给公司带来巨大的经济损失？：独家的事前+事中+事后三层次完美解决方案

（12）如何解决高并发场景下的缓存穿透问题？避免给MySQL带来过大的压力？：缓存穿透解决方案

（13）如何解决高并发场景下的缓存失效问题？避免给redis集群带来过大的压力？：缓存失效解决方案

## 分布式限流

### 1.什么是限流？

在高并发系统中，限流通常指的是：对高并发访问或者请求进行限速或者对一个时间内的请求进行限速来保护我们的系统，一旦达到系统的限速规则（比如系统限制的请求速度），则可以采用下面的方式来处理这些请求。 拒绝服务（友好提示或者跳转到错误页面）。 排队或等待（比如秒杀系统）。 服务降级（返回默认的兜底数据）。 其实，就是对请求进行限速，比如10r/s，即每秒只允许10个请求，这样就限制了请求的速度。从某种意义上说，限流，其实就是在一定频率上进行量的限制。 限流一般用来控制系统服务请求的速率，比如：天猫双十一的限流，京东618的限流，12306的抢票等。

## 高可用

### 1.cdn（异地多活）

异地多活：异地多活指分布在异地的多个站点同时对外提供服务的业务场景。异地多活是高可用架构设计的一种，与传统的灾备设计的最主要区别在于“多活”，即所有站点都是同时在对外提供服务的。