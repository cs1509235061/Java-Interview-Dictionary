# Git

### 1.版本控制系统

有这么一套系统，然后呢，我们是这样，就是说每次修改代码之后，就将这次修改后的这个版本提交到那个版本控制系统中去。然后由这个版本控制系统来给我们管理我们代码中每个代码文件的所有的版本。

当我们需要进行版本控制的时候，比如回退一个版本，此时直接向那个版本控制系统下达一个命令，说，我现在需要切换回上一个版本的代码，你给我在1s之内完成这个事儿。然后版本控制系统同，就会自动找到上一次提交的版本的代码，然后恢复到你的电脑上来。

### 2.配置git

git有一个命令，git config，专门用来对你的git环境进行各种配置。git有三个地方放环境配置：

（1）/etc/gitconfig，对当前机器上所有的用户和git项目都生效，使用git config --system，即可对这个配置文件进行操作，也不是很重要，因为我们一般很少去配置这个文件，因为git的配置一般都是对某个用户和项目的范围去生效的。

（2）~/.gitconfig，当前用户主目录的.gitconfig文件，对当前用户有效，使用git config --global，即可对这个配置文件进行操作，windows的话，是在这里：/c/Documents and Settings/All Users/Application Data/Git。

（3）项目的.git目录下的config文件，仅仅对当前git管理的这个项目有效，直接git config操作的就是这个文件。

因为我们其实一般都不会直接修改git的配置文件来进行配置，一般都是执行git config命令，来修改我们的各个不同的范围的配置，比如全局的配置，或者是项目特殊的配置。

### 3.帮助文档

如果对某个git命令不太熟悉，可以用git的帮助文档。

git add --help

### 4.对一个已有的项目初始化git版本库

我们一般都是先创建一个项目，这个项目处于一个目录下，此时如果要让git来管理这个项目，就可以在这个项目的根目录下面执行以下命令：

git init

执行了git init命令之后，意思就是说，要让git托管这个项目的代码，后续这个项目中的所有代码的变动，都可以作为一个版本提交到git中，git会管理这个项目的每个版本的代码，同时后续我们就可以基于git对这个项目进行各种各样的版本控制的功能 。

git init命令执行之后，做的第一件事情，此时就会创建一个.git隐藏目录，这里包含了git的所有的文件，就是每个版本的代码都会存储在.git目录中。之前我们不是说，如果要对HelloWorld.java文件进行版本控制的话，实际上是要保留这个文件的多个版本的代码的，如果自己手工做，那么就是保存多个代码文件。

.git目录中，实际上就是存储了你的每个代码文件的每个版本，每个版本就是一个独立的文件。历史版本都被存储在了.git目录中。

但是此时git还没有开始对你的项目进行版本控制。如果要对你的项目代码进行版本控制，需要执行以下命令：

git add --all .

git commit -m 'initial project version'

把上面两个事情给做了之后，实际上就是代表的是，将项目代码当前的版本，提交到git中去，保存到.git目录中去，开始让git管理当前项目的所有代码文件的后续的版本变更。

有的时候，我们不是对项目里所有的代码或者是文件都要追踪其版本变更的，尤其是对一些自动生成的一些东西，比如说maven生成的target目录下的东西，跟我们的代码是没关系的。

我们是不希望通过git来管理target下面的东西的。

我们可以自己手动创建一个.gitignore文件，在里面每行一个，放入不需要被git托管的目录或者文件。

### 5.git本地仓库结构

git项目有3个主要的部分组成：工作区（working directory / working tree），暂存区（staging area），版本库（git directory / repository）。

git directory / repository：git版本库，其实就是git用于存储自己的元数据，以及文档数据库的地方，默认就是在项目的.git隐藏目录中。

working directory / working tree：工作区，保存的是一个项目当前的一个版本对应的所有文件，这些文件是从git版本库中的压缩后的数据库中提取出来，然后放到我们的磁盘上去。

staging area：暂存区，就是一个文件，包含在git版本库中，主要是保存了下一次要提交到的那些文件信息。在git中，对暂存区有另外一个名称，叫做index，也就是索引。

上面三个区域的协作关系大致如下：

（1）首先会在工作区修改某个版本的文件。

（2）将某些修改后的文件放入git暂存区中，准备下一次提交到git版本库中去。

（3）执行一个提交操作，将暂存区中的文件保作为一个快照保存到git版本库中去。

如果一个文件，已经有一个版本被保存到了版本库，那么就是committed状态；如果这个文件被修改了，同时被加入了暂存区，那么就是staged状态；如果这个文件修改了，还没有加入暂存区，那么就是modified状态。

工作区，working directory。

所谓的工作区，指的就是当前你的git管理的项目，在本地的那个目录，也就是你能直接看到，编辑的那个目录，这就是工作区。

### 6.git的重要机制

快照机制

Git用的不是这种维护每次提交的差异，而是用的快照。每次提交文件，都是保存一份这个文件当前这个状态的一个完整快照，同时对这次提交维护一个指针，指向这个文件快照。

本地化操作

大多数的git版本控制操作，只要在本地执行即可，所有的版本文件都在本地，因此操作是非常快速的。相比较于那些依赖网络的集中式版本控制系统来说，他们的大多数操作要依赖网络，速度是很慢的。

比如说通过git查看提交历史，比较历史文件的差异，都可以在本地完成，不需要通过服务器做任何事情。

完整性保证

git在存储任何文件之前，都会对其执行一个校验和，然后用校验和指向那个文件。这是git内核保证的，这样我们是不可以手工修改git版本库中的任何文件的，因为修改了文件之后，会导致计算出来的校验和与之前保存的校验和不匹配，文件会破损。

git用的是SHA-1 hash算法来计算校验和，这是一个40位的字符串，基于文件的内容计算出来的，看起来大概是这样的：

24b9da6552252987aa493b52f8696cd6d3b00373

如果手动破坏.git中存储的文件的内容，git会不承认，因为内容变化之后，会导致内容计算出来的SHA-1 40位的hash值变化，跟之前存储的hash值不同，就认为文件破损。

仅仅添加数据

git通常来说，仅仅会在自己的数据库中添加数据，因此提交文件到git之后，很少会丢失，而且如果我们定期提交文件到远程服务器，就更少丢失。

### 7.文件的状态

代码文件分成两种，一种是tracked，一种是untracked。tracked文件就是已经提交到git版本库中的文件，后面可以处于modified或者staged状态；untracked文件，就是从来没有提交到git版本库的代码文件（也从来没有放入暂存区）。

（1）新文件刚创建：untracked，此时仅仅停留在工作区中。

（2）git add 新文件：new file，此时已经被追踪了，放入了暂存区中。

（3）git commit 新文件：committed，已经被追踪了，放入了git仓库中。

（4）修改那个文件：modified，changes not staged to be committed，没有加入暂存区，被修改的内容仅仅停留在工作区中。

（5）git add 修改文件：modified，changes to be committed，修改的文件版本被已经加入暂存区。

（6）git commit 修改文件：committed，修改后的新版本提交到了git仓库中。

一般自己创建的版本库，刚开始文件都是untracked，然后git add和git commit命令执行之后，就被提交了第一个版本到git版本库，此时就全部都是tracked了。如果是从远程版本库克隆下来的，那么刚开始就是tracked。

接着对tracked的文件修改之后，就是modified；然后对modified文件再执行git add命令之后，就是staged，进入了暂存区；接着执行git commit命令之后，就将暂存区中的文件都提交到了版本库中，此时就是unmodified，and tracked。

### 8.基于git log查看提交历史

在我们提交了很多次之后，可以查看提交历史，使用git log命令即可，可以看到每次commit的信息，包括了commit的SHA-1、作者、日期、提交说明。

包含了一个commit的SHA-1 hash值，40位的字符；作者，从之前安装好git之后做的设置来的；date；提交备注，inital commit，git commit -m ''。

### 9.版本控制

git reset --hard HEAD^，就是将仓库、暂存区、工作区，全部恢复到上一个commit（add two files）对应的状态。

git reset --hard HEAD~5，退回到HEAD之前的倒数第5个commit的状态。

git reset --hard d324644，指定一个commit的hash值，回退到很老的版本。

git reset这个命令，可以任意穿梭到历史的任何一个版本上去。

### 10.分支

分支的介绍

所谓的分支功能，就是可以同时拉出来多个代码副本，然后在不同的代码副本上，可以进行对应功能的开发。完成开发之后，可以将多个分支合并在一起，形成最终的代码。

分支，其实就是指针。

在git中，每一个项目，不管你有多少个分支，不管你在哪个分支上开发。

最终都会形成一个完整的提交历史，树形结构。

每个分支，其实就只是一个指针而已，分支就指向了提交历史中的某个commit object。

每个commit object就代表了这个项目的所有代码在那次提交的时候一个完整的快照版本，包含了之前没有变更的代码文件，也包括了这次提交的最新的修改/新增/删除的代码文件。

每个commit object就代表了项目的一个版本。

所以你的分支实际上就是指向了历史上某个时刻的一个版本的代码，就是一个commit object。

commit object与分支的原理

Git并不是存储一系列的文件差异，而是存储一系列的文件快照的。实际上每次我们执行一次commit，git都会存储一个commit object，这个commit object中会包含一个指针，指向这次提交文件的快照。这个commit object同时也包含作者的姓名和邮箱，提交说明，以及对上一次commit object的指针。

将一个文件版本放入暂存区的时候，就会计算一个校验和，然后提交的时候会将文件内容以blob的方式放入版本库中，同时在暂存区放入这个文件版本的校验和。接着git会创建一个commit object，其中会包含元数据，以及一个指针指向版本库中的文件快照。

也就是说，每次执行一次提交，都会在版本库中包含这么几个东西：一个blob，每个文件都会有一个blob来存储这个文件的本次提交的快照；一个tree，这个tree会包含对本次提交的所有文件的blob的指针；一个commt object，指向了tree的指针，作者，等信息。

接着如果再次执行一个提交，那么下一个提交同样会包含那些东西：每个文件一个blob，一个tree指向所有blob，一个commit object指向那个tree，同时这个commit object会有一个指针，指向上一个commit object。

最后多次提交，就会得到一颗完整的commit树。

分支是啥？分支就是一个轻量级的指针，默认的分支是master，那么每次提交，master分支的指针默认就是指向最新的那个commit object的。每次提交一次，master指针就会挪动，继续指向最新的commit object。

同时如果你当前工作在某个分支上，比如工作在master分支上，那么git还维护了一个特殊的指针，HEAD，这个指针指向master分支指针。如果你创建了其他的分支，那么其他的分支也会指向某个commit object，而且此时如果工作在那个分支上，那么HEAD指针会指向那个分支。

创建一个分支

git branch testing，可以创建一个新的分支，此时这个分支的指针会指向当前你所在的分支所指向的commit object上。

如何查看各个分支指向哪个commit object呢？使用git log --oneline --decorate命令即可，会给你显示出来。

切换分支

git checkout testing，此时就可以切换到testing分支，此时HEAD指针会指向testing分支指针。

此时如果在testing分支上提交代码，那么会commit树会长出来一个新的commit object，而testing分支指正会指向最新的commit object，HEAD继续指向testing分支指针，而master指针还是指向之前的那个commit object。

git checkout master，会切换回master分支，此时HEAD指针会指向master指针，同时将master指针指向的那个commit object，对应的tree和其中的blob，也就是对应的文件快照恢复到工作区中来。

再次在master分支上提交一个修改，此时从这个commit object会再长出来一个新的commit object，看起来就是跟testing分支当前指向的commit object形成了两个分叉。

此时如果要查看commit树，可以用命令：git log --oneline --decorate --graph --all，这个命令很有用，可以打印出整颗commit树，同时告诉你各个分支当前指向哪个commit object。

在Git中，分支升级上就是一个很简单的文件，其中包含了一个40位的SHA-1校验和，就是分支指向的那个commit object的SHA-1。所以创建分支的代价是很低的，不过就是创建这么一个文件罢了。而一些集中式版本控制系统，对于分支可能需要拷贝一个完整的文件副本，导致速度很慢，磁盘空间占用很大。

远程分支

git push -u origin 分支名称

这个的意思，就是将本地分支推送到远程仓库里，形成一个同名的远程分支，同时-u这个选项就是将本地分支和远程分支关联起来。

如果其他人要将某个远程仓库的分支拉取下来，应该执行一个命令，叫做git fetch origin，就会抓取下来远程仓库新增了哪些分支。

接下来可以执行一个命令，git checkout -b 本地分支 origin/远程分支，用这个命令，origin/远程分支，就代表了远程仓库里的那个分支，然后这个命令一执行，就是在本地创建一个远程分支对应的本地分支，互相关联起来。

以后呢，每次如果别人更新了那个分支的代码，push到了远程仓库，你可以执行git pull命令，将这个分支在远程仓库的代码拉取下来，跟本地分支的代码进行合并。

远程版本库的分支，在本地都有追踪分支，remote-tracking 分支。

使用git branch -u origin/serverfix，可以让当前本地分支track某个指定的远程分支。

使用git branch -vv，可以查看每个本地分支track的远程分支。

删除远程分支，比如一个远程分支，已经结束了工作了，可以删除一个远程分支，使用git push origin --delete serverfix即可。同时可以使用git branch -d serverfix删除本地分支。

### 11.分支管理命令

git branch命令，直接执行，就会显示出当前所有分支列表，以及你在哪个分支上工作。

git branch -v命令，可以显示出每个分支当前指向的commit object。

git branch --merged，可以看到哪些分支被merge进了当前分支；git branch --no-merged，可以看到哪些分支还没有被merge进当前分支。

如果git branch -d命令删除一个分支，可能会提示你那个分支还没merge到当前分支来，不让你删除该分支，此时可以使用git branch -D命令，强制删除一个分支。

### 12.优化集中式工作流

在那种普通的集中式工作流开发流程下，会有一个问题，就是每次如果某个人push了代码到master，然后另外一个哥儿们也要push会失败。

此时那个哥儿们就要git pull拉取和合并master分支的代码。

坑爹的事情来了，每次都这样合并的话，会导致你最后发现看到这个项目，它的提交历史就是各种分叉，各种合并，提交历史感觉很难看。

要优化集中式工作流的提交历史成为一条线，看起来非常的清晰和清爽，此时就要使用rebase命令。

git pull --rebase

rebase：变基，就是改变commit之前依赖的基础commit。

通过git pull --rebase，执行变基式的合并，改变commit历史，看起来提交历史就是一条直线，张三先提交，李四再提交，李四再提交，张三再提交。

### 13.git reflog

git log和git reflog的区别是啥？？？？

git log，是你当前的分支指向的commit之前的所有commit会显示出来，你的分支指向的那个commit之后的commit是不会显示的。

git reflog，是会显示最近几个月，完整的一个commit历史的。

所以说，在当前分支上，如果要回退到过去的某个历史版本的话，那么此时应该是用git log就可以。

但是如果要回到未来的某个版本，是用git reflog。

git会自动记录和追踪过去几个月内，你的HEAD指针和分支指针移动过的每个commit

用git reflog命令就能查看完整的一份commit记录，而使用git log就只能查看当前分支指向的那个commit之前的commit记录。

reflog是每个研发人员自己本地的电脑上的记录，跟git log显示出来的提交历史不同，不会同步到远程仓库上去的。

### 14..git目录

平时我们如果执行git init之后，就会生成一个.git目录，其中就是git存放所有数据的地方。如果我们拷贝这个.git目录，那么就相当于备份了一个完整的git项目的数据。

在.git目录中，有如下一些内容：

config

description

HEAD

hooks/

info/

objects/

refs/

description文件仅仅是由Git WebUI程序去使用的，我们一般不用去管这个文件。

config文件包含了这个git项目的所有配置项。

info目录中包含了我们在.gitignore文件中定义的不需要git追踪的那些被排除掉的文件。

hooks目录中包含了我们的client-side或者是server-side的钩子脚本。

其实上面那些都不是最重要的，最重要的是这几个东西：HEAD文件，indexes文件，objects目录，以及refs目录。

objects目录存储了git中所有的数据，refs目录中存储了所有的指针（包括了branch，tag，remote，等等，指向了objects目录中的数据），HEAD指向了当前我们所处的分支指针，indexes文件存储了暂存区中的内容。

### 15.git的文件存储机制（轻量级索引机制）

你往git里存储一个文件，git一定会根据文件的内容计算一个40位的hash值出来，作为那个文件的名称，也是指针，40位hash值就可以来引用这个文件。存储的时候，40位hash的头2位，会作为目录名称放在objects里面，然后那个存储的文件会放在那个目录中，文件名是40位hash值的后38位。

将40位hash值的头2位作为目录，其实你可以认为是一种轻量级的索引机制

这样的话，有一个好处，就是每次你要根据一个hash值定位一个数据的时候，直接根据头2位先定位到一个目录，然后再在这个目录下去查找，linus写git的时候，就是用了一种非常轻量级的文件索引机制

### 16.**说一下Git创建分支的步骤？**

- `Git branch test` 创建test的branch
- `Git checkout dev` 切换到dev分支
- `Git pull` 远程分支拉到本地
- `Git checkout -b main` 创建并切换到main分支
- `Git push origin main` 推到远程分支

### 17.**说一下Git合并的两种方法以及区别？**

Git代码合并有两种：`Git Merge`和 `Git ReBase`

**Git Merge**： 这种合并方式是将两个分支的历史合并到一起，现在的分支不会被更改，它会比对双方不同的文件缓存下来，生成一个commit，去push。

**Git ReBase**： 这种合并方法通常被称为“衍合”。他是提交修改历史，比对双方的commit，然后找出不同的去缓存，然后去push，修改commit历史。

### 18.**什么是 git stash？**

用于临时保存和恢复修改，可跨分支。

使用场景：写着代码，别人告诉我bug修好了，我就要去更新一下代码，如果更新冲突，应该把当前代码保存起来，此时可以使用git stash命令。

命令的本质帮我们做了两件事：

①把所有改动做了一个快照，然后保存起来，并还原原来的文件。

②在需要的时候，可以把之前的修改恢复。

### 19.**git config 的作用？**

配置或读取相应的环境变量。

这些环境变量，主要保存了 Git 在各个环节的具体工作方式和行为。 位置：

- 用户主目录的.gitconfig
- 工作目录的.git下面的.gitconfig
- /etc/.gitconfig

### 20.Git四种通信协议

简单来说Git的四种通信协议分别为：Local、SSH、HTTP、Git

Local(本地协议)

基于本地文件系统或共享（NFS）文件系统进行访问, 优点 ：简单，直接使用了现有的文件权限和网络访问权限，小团队小项目建立一个这样的版本管理系统是非常轻松的一件事。 缺点： 这种协议缺陷就是本身共享文件系统的局限，只能在局域网，而且速度也慢。 适应场景： 小团队，小项目临时搭建版本服务。

SSH 协议

Git支持支持利用ssh 协议进行通信，这是绝大部分linux、uninx系统都支持的，所以利用该协议架设GIT版本服务是非常方便的。 优点： 首先SSH 架设相对简单、其次通过 SSH 访问是安全的、另外SSH 协议很高效，在传输前也会尽量压缩数据。 缺点： 权限体系不灵活，必须提供操作系统的帐户密码，哪怕是只需要读取版本。 适应场景： 小团队、小项目、临时项目

HTTP协议

Git http 协议实现是依懒 WEB容器(apache、nginx)及cgi 组件进行通信交互，并利用WEB容器本身权限体系进行授权验证。在 Git 1.6.6 前只支持http Dumb协议，该协议只能下载不能提交，通常会配合ssh 协议一起使用，ssh 分配提交帐号，http dumb提供只读帐号。1.6.6 之后git 提供了git-httpbackend的 CGI 用于实现接收远程推送等功能。 优点： 解决了local 与ssh 权限验证单一的问题、可基于http url 提供匿名服务，从而可以放到公网上去。而local 与ssh 是很难做到这一点,必如实现一个类似github 这样的网站。 缺点： 架设复杂一些需要部署 WEB服务器，和https 证书之类的配置 场景： 大型团队、需要对权限精准控制、需要把服务部署到公网上去

Git协议

Git 协议是包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权。 优点： 目前，Git 协议是 Git 使用的网络传输协议里最快的。 如果你的项目有很大的访问量，或者你的项目很庞大并且不需要为写进行用户授权，架设 Git 守护进程来提供服务是不错的选择。 它使用与 SSH相同的数据传输机制，但是省去了加密和授权的开销。 缺点： Git 协议缺点是缺乏授权机制。 而且9418是一个非标准端口，一般防火墙不会开放。

