# 性能优化

### 1.做过性能优化的工作吗？你会从哪些方面入手做性能优化呢？

性能优化有哪些方面？

我们可以从数据聚合优化、资源冲突优化、算法优化、JVM优化、复用优化、计算优化和快速实现等方面来进行回答。

数据聚合优化

数据聚合优化主要针对的是对于数据的整合和传输的优化。比如：我们从数据库中查询出的数据，经过程序的聚合处理后再返回给客户端，而不用客户端调用多次接口来分别获取数据。 再比如：我们在项目中使用的Nginx，一般都会开启GZIP压缩，使传输的数据更加紧凑，同时，使传输的数据量更小。 细心的小伙伴会发现，我们对于数据聚合的优化，主要是使传输的数据量更小。所以，我们在使用SQL语句查询数据库中的数据时，尽量查询那些需要的字段，对于不需要的字段就直接忽略不查询了，避免在SQL语句中出现select *

资源冲突优化

在我们平时的工作中，尤其是在高并发的场景下，经常会出现锁冲突的问题，锁冲突是资源冲突的一个典型场景。 关于锁我们可以联想到数据库的行锁、表锁、Java中的synchronized和Lock等。如果对应到操作系统级别，则会有CPU命令级别的锁，JVM指令级别的锁，操作系统的内部锁等。 这里，小伙伴们需要注意一点：只有在并发的场景下，才会出现资源冲突的问题。也就是说：在同一时刻，只能有一个请求获取到请求资源，解决冲突的方式就是加锁。

算法优化

在一个大型的互联网项目中，往往涉及到分布式和微服务等技术，其中，也会使用到大量的数据结构和算法，对于算法的优化能够显著的提高系统的性能。一个好的实现，相比于一个拙劣的实现来说，在系统性能的提升上存在着巨大的差异。 比如，作为 List 的实现，LinkedList 和 ArrayList 在随机访问的性能上，差了好几个数量级；又比如，CopyOnWriteList 采用写时复制的方式，可以显著降低读多写少场景下的锁冲突。而什么时候使用同步，什么时候是线程安全的，也对我们的编码能力有较高的要求。

JVM优化

JVM调优，不用说，这是每个Java工程师必须要掌握的标准技能。所有的Java程序最终都是运行在JVM中的，对JVM进行优化也能够提升Java程序的性能。但是，需要注意的是：如果在优化JVM时，参数设置不当，可能会造成内存溢出等严重的问题。 目前被广泛使用的垃圾回收器是 G1，通过很少的参数配置，内存即可高效回收。CMS 垃圾回收器已经在 Java 14 中被移除，由于它的 GC 时间不可控，有条件应该尽量避免使用。

复用优化

复用优化，这个看名字就知道，说白了就是可以重复利用。估计很多小伙伴都有这样的经验，在写代码的时候，可以将很多重复的代码抽象出来，做成公共的方法。这样，就不用每次都去写重复的逻辑代码了。这是代码层面的复用。 如果是数据层面的话，我们可以使用缓冲和缓存来复用数据。 这里，小伙伴们需要注意一个知识点：缓冲主要针对的是写操作，缓存主要针对的是读操作。 另一个复用优化的典型场景就是池化技术，比如：数据库连接池、线程池等。

计算优化

对于计算优化来说，我们可以从以下几个小的方面来阐述。 **并行计算** 不难理解，就是多个计算同时进行。这里，又可以将并行计算分为：多机并行计算、多进程并行计算和多线程并行计算。 **多机并行计算**： 将一个大的计算任务，拆分成N个小的计算任务，分发到不同的机器进行处理。典型的场景就是Hadoop的MapReduce极端。 **多进程计算**： 比如，Nginx采用的NIO模型，采用的是进程调度的策略，由Master进程调度Worker进程，Worker进行来处理具体的请求。 **多线程计算**：对于多线程计算来说，也是我们平时接触最多的一种计算方式，我们可以使用多线程技术，将复杂的逻辑计算拆分成一个个小的计算任务，分发到不同的线程中去执行。 **同步变异步** 同步和异步的区别就是：同步需要等待返回结果，异步不需要等待返回结果。如果我们在业务程序中，不需要等待返回结果数据，则我们可以将同步调用优化为异步调用，从而提升我们系统的性能。 **懒加载** 最典型的场景就是Spring中的懒加载，只有第一次获取bean的时候，才会创建bean实例。

快速实现

对于快速实现来说，不仅包含我们需要利用相关的程序框架迅速开发出我们想要的业务，也需要我们在进行技术选型时，尽量使用一些性能优良的组件。比如，在进行网络开发时，尽量选择Netty，结合轻量级的数据传输，就不要使用WebService等技术了。 很多公司喜欢使用适配器模式，在一些现有的开源组件之上，再抽象一层自己的组件，这样就能够做到切换底层组件的时候，对上层应用无感。

### 2.性能优化有哪些衡量指标？需要注意什么？

衡量指标

对于性能优化来说，衡量的指标有很多，大体上可以分为：性能指标、响应时间、并发量、秒开率和正确性等。

性能指标

性能指标又可以包含：吞吐量和响应速度。我们平时所说的QPS、TPS和HPS等，就可以归结为吞吐量。有很多小伙伴可能对于QPS、TPS和HPS等不太了解，我们先来说下这几个字母的含义。

- QPS代表的是每秒的查询数量。
- TPS代表的是每秒事务的数量。
- HPS代表的是每秒的HTTP请求数量。

这些都是与吞吐量相关的衡量指标。

平时我们在做优化工作的时候，首先要明确需要优化的事项。比如：我们做的优化工作是要提高系统的吞吐量？还是要提升系统的响应速度呢？举一个具体点的例子：比如我们的程序中存在一些数据库或者缓存的批量操作，虽然在数据的读取上，响应速度下降了，但是我们优化的目标就是吞吐量，只要我们优化后系统的整体吞吐量明显上升了，那这也是提升了程序的性能。 所以说，优化性能不只是提升系统的响应速度。 这里，优化性能也并不是一味的优化吞吐量和优化响应速度，而是在吞吐量和响应速度之间找到一个平衡点，使用有限的服务器资源来更好的提升用户体验。

响应时间

对于响应时间来说，有两个非常重要的衡量指标。那就是：平均响应时间和百分位数。 （1）平均响应时间 通常，平均响应时间体现的是服务接口的平均处理能力。计算方式就是把所有的请求所耗费的时间加起来，然后除以请求的次数。举个简单的例子：比如：我们向一个网站发送了5次请求，每次请求所耗费的时间分别为：1ms，2ms，1ms，3ms，2ms，那么，平均响应时间就是（1+2+1+3+2）/ 5 =1.8ms，所以，平均响应时间就是1.8ms。 平均响应时间这个指标存在一个问题：如果在短时间内请求变得很慢，但很快过去了，此时使用平均响应时间就无法很好的体现出性能的波动问题。 （2）百分位数 百分位数就是我们在优化的时候，圈定一个时间范围，把每次请求的耗时加入一个列表中，然后按照从小到大的顺序将这些时间进行排序。这样，我们取出特定百分位的耗时，这个数字就是 TP 值。 TP值表示的含义就是：超过 N% 的请求都在 X 时间内返回。比如 TP90 = 50ms，意思是超过 90th 的请求，都在 50ms 内返回。 百分位数这个指标也是很重要的，它反映的是应用接口的整体响应情况。 我们一般会将百分位数分为 TP50、TP90、TP95、TP99、TP99.9 等多个段，对高百分位的值要求越高，对系统响应能力的稳定性要求越高。

并发量

并发量指的是系统能够同时处理的请求数量，反映的是系统的负载能力。 我们在对高并发系统进行优化的时候，往往也会在并发量上进行调优，调优方式也是多种多样的，目的就是提高系统同时处理请求的能力。 总体来说，并发量这个指标理解起来还是比较简单的，我就不做过多的描述了。

秒开率

秒开率主要针对的是前端网页或者移动端APP来说的，如果一个前端网页或者APP能够在1秒内很平滑的打开，尤其是首页的加载。此时，用户就会感到前端网页或者APP使用起来很顺畅，如果超过3秒甚至更长的时间，用户就有可能会直接退出前端网页或者APP不再使用。 所以，在高并发场景下优化程序，不只要对后端程序进行优化，对于前端和APP也是要进行优化的。

正确性

正确性说的是无论我们以何种方式，何种手段对应用进行优化，优化后的交互数据结果必须是正确的。 不能出现优化前性能比较低，数据正确，而优化后性能比较高，反而数据不正确的现象。

优化需要注意的问题

- 除非必要,一开始不要优化(尤其是开发阶段)
- 有些优化准则已经过时,需要考虑当下的软硬件环境(不要墨守成规)
- 不要过分强调某些系统级指标,如cache 命中率,而应该聚焦性能瓶颈点
- 不盲从，测试、找到系统的性能瓶颈，再确定优化手段
- 注意权衡优化的成本和收益（有些优化可能需要现有架构做出调整、增加开发/运维成本）
- 优化的目标是用户体验、降低硬件成本（降低集群规模、不依赖单机高性能）
- 测试环境的优化手段未必对生产环境有效（优化需要针对真实情况）

### 3.Java性能优化的50个细节

1、尽量在合适的场合使⽤单例 使⽤单例可以减轻加载的负担，缩短加载的时间，提⾼加载的效率，但并不是所有地⽅都适⽤于单例，简单来说，单例主要适⽤ 于以下三个⽅⾯： 第⼀，控制资源的使⽤，通过线程同步来控制资源的并发访问； 第⼆，控制实例的产⽣，以达到节约资源的⽬的； 第三，控制数据共享，在不建⽴直接关联的条件下，让多个不相关的进程或线程之间实现通信。 2、尽量避免随意使⽤静态变量 当某个对象被定义为static变量所引⽤，那么GC通常是不会回收这个对象所占有的内存

3、尽量避免过多过常地创建Java对象 尽量避免在经常调⽤的⽅法，循环中new对象，由于系统不仅要花费时间来创建对象，⽽且还要花时间对这些对象进⾏垃圾回收 和处理，在我们可以控制的范围内，最⼤限度地重⽤对象，最好能⽤基本的数据类型或数组来替代对象。 4、尽量使⽤final修饰符 带有final修饰符的类是不可派⽣的。在JAVA核⼼API中，有许多应⽤final的例⼦，例如java、lang、String，为String类指定 final防⽌了使⽤者覆盖length()⽅法。另外，如果⼀个类是final的，则该类所有⽅法都是final的。java编译器会寻找机会内联 （inline）所有的final⽅法（这和具体的编译器实现有关），此举能够使性能平均提⾼50%。

如：让访问实例内变量的getter/setter⽅法变成”final： 简单的getter/setter⽅法应该被置成final，这会告诉编译器，这个⽅法不会被重载，所以，可以变成”inlined”,

5、尽量使⽤局部变量 调⽤⽅法时传递的参数以及在调⽤中创建的临时变量都保存在栈（Stack）中，速度较快；其他变量，如静态变量、实例变量 等，都在堆（Heap）中创建，速度较慢。 6、尽量处理好包装类型和基本类型两者的使⽤场所 虽然包装类型和基本类型在使⽤过程中是可以相互转换，但它们两者所产⽣的内存区域是完全不同的，基本类型数据产⽣和处理 都在栈中处理，包装类型是对象，是在堆中产⽣实例。在集合类对象，有对象⽅⾯需要的处理适⽤包装类型，其他的处理提倡使 ⽤基本类型。 7、慎⽤synchronized，尽量减⼩synchronize的⽅法 都知道，实现同步是要很⼤的系统开销作为代价的，甚⾄可能造成死锁，所以尽量避免⽆谓的同步控制。synchronize⽅法被调 ⽤时，直接会把当前对象锁了，在⽅法执⾏完之前其他线程⽆法调⽤当前对象的其他⽅法。所以，synchronize的⽅法尽量减 ⼩，并且应尽量使⽤⽅法同步代替代码块同步。 9、尽量不要使⽤finalize⽅法 实际上，将资源清理放在finalize⽅法中完成是⾮常不好的选择，由于GC的⼯作量很⼤，尤其是回收Young代内存时，⼤都会引 起应⽤程序暂停，所以再选择使⽤finalize⽅法进⾏资源清理，会导致GC负担更⼤，程序运⾏效率更差。 10、尽量使⽤基本数据类型代替对象

11、多线程在未发⽣线程安全前提下应尽量使⽤HashMap、ArrayList HashTable、Vector等使⽤了同步机制，降低了性能。 12、尽量合理的创建HashMap 当你要创建⼀个⽐较⼤的hashMap时，充分利⽤这个构造函数

```html
public hashMap(int initialCapacity, float loadFactory)
```

避免HashMap多次进⾏了hash重构,扩容是⼀件很耗费性能的事，在默认中initialCapacity只有16，⽽loadFactor是 0.75，需要 多⼤的容量，你最好能准确的估计你所需要的最佳⼤⼩，同样的Hashtable，Vectors也是⼀样的道理。 13、尽量减少对变量的重复计算

并且在循环中应该避免使⽤复杂的表达式，在循环中，循环条件会被反复计算，如果不使⽤复杂表达式，⽽使循环条件值不变的 话，程序将会运⾏的更快。

14、尽量避免不必要的创建

15、尽量在finally块中释放资源 程序中使⽤到的资源应当被释放，以避免资源泄漏，这最好在finally块中去做。不管程序执⾏的结果如何，finally块总是会执⾏ 的，以确保资源的正确关闭。 16、尽量使⽤移位来代替'a/b'的操作 "/"是⼀个代价很⾼的操作，使⽤移位的操作将会更快和更有效

但注意的是使⽤移位应添加注释，因为移位操作不直观，⽐较难理解。 17、尽量使⽤移位来代替'a*b'的操作 同样的，对于'*'操作，使⽤移位的操作将会更快和更有效

18、尽量确定StringBuffer的容量 StringBuffer 的构造器会创建⼀个默认⼤⼩（通常是16）的字符数组。在使⽤中，如果超出这个⼤⼩，就会重新分配内存，创建 ⼀个更⼤的数组，并将原先的数组复制过来，再丢弃旧的数组。在⼤多数情况下，你可以在创建 StringBuffer的时候指定⼤⼩， 这样就避免了在容量不够的时候⾃动增⻓，以提⾼性能。

19、尽量早释放⽆⽤对象的引⽤ ⼤部分时，⽅法局部引⽤变量所引⽤的对象会随着⽅法结束⽽变成垃圾，因此，⼤部分时候程序⽆需将局部，引⽤变量显式设为 null。

20、尽量避免使⽤⼆维数组 ⼆维数据占⽤的内存空间⽐⼀维数组多得多，⼤概10倍以上。 21、尽量避免使⽤split 除⾮是必须的，否则应该避免使⽤split，split由于⽀持正则表达式，所以效率⽐较低，如果是频繁的⼏⼗，⼏百万的调⽤将会耗 费⼤量资源，如果确实需要频繁的调⽤split，可以考虑使⽤apache的StringUtils.split(string,char)，频繁split的可以缓存结 果。 22、ArrayList & LinkedList ⼀个是线性表，⼀个是链表，⼀句话，随机查询尽量使⽤ArrayList，ArrayList优于LinkedList，LinkedList还要移动指针，添加 删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2者得数 据结构，对症下药。 23、尽量使⽤System.arraycopy ()代替通过来循环复制数组 System.arraycopy() 要⽐通过循环来复制数组快的多。 24、尽量缓存经常使⽤的对象 尽可能将经常使⽤的对象进⾏缓存，可以使⽤数组，或HashMap的容器来进⾏缓存，但这种⽅式可能导致系统占⽤过多的缓存， 性能下降，推荐可以使⽤⼀些第三⽅的开源⼯具，如EhCache，Oscache进⾏缓存，他们基本都实现了FIFO/FLU等缓存算法。 25、尽量避免⾮常⼤的内存分配 有时候问题不是由当时的堆状态造成的，⽽是因为分配失败造成的。分配的内存块都必须是连续的，⽽随着堆越来越满，找到较 ⼤的连续块越来越困难。 26、慎⽤异常 当创建⼀个异常时，需要收集⼀个栈跟踪(stack track)，这个栈跟踪⽤于描述异常是在何处创建的。构建这些栈跟踪时需要为运 ⾏时栈做⼀份快照，正是这⼀部分开销很⼤。当需要创建⼀个 Exception 时，JVM 不得不说：先别动，我想就您现在的样⼦存⼀ 份快照，所以暂时停⽌⼊栈和出栈操作。栈跟踪不只包含运⾏时栈中的⼀两个元素，⽽是包含这个栈中的每⼀个元素。 如果您创建⼀个 Exception ，就得付出代价，好在捕获异常开销不⼤，因此可以使⽤ try-catch 将核⼼内容包起来。从技术上 讲，你甚⾄可以随意地抛出异常，⽽不⽤花费很⼤的代价。招致性能损失的并不是 throw 操作⸺尽管在没有预先创建异常的情 况下就抛出异常是有点不寻常。真正要花代价的是创建异常，幸运的是，好的编程习惯已教会我们，不应该不管三七⼆⼗⼀就抛 出异常。异常是为异常的情况⽽设计的，使⽤时也应该牢记这⼀原则。 27、尽量重⽤对象 特别是String对象的使⽤中，出现字符串连接情况时应使⽤StringBuffer代替，由于系统不仅要花时间⽣成对象，以后可能还需 要花时间对这些对象进⾏垃圾回收和处理。因此⽣成过多的对象将会给程序的性能带来很⼤的影响。 28、不要重复初始化变量 默认情况下，调⽤类的构造函数时，java会把变量初始化成确定的值，所有的对象被设置成null，整数变量设置成0，float和 double变量设置成0.0，逻辑值设置成false。当⼀个类从另⼀个类派⽣时，这⼀点尤其应该注意，因为⽤new关键字创建⼀个对 象时，构造函数链中的所有构造函数都会被⾃动调⽤。 这⾥有个注意，给成员变量设置初始值但需要调⽤其他⽅法的时候，最好放在⼀个⽅法。⽐如initXXX()中，因为直接调⽤某⽅法 赋值可能会因为类尚未初始化⽽抛空指针异常，如：public int state = this.getState()。 29、在java+Oracle的应⽤系统开发中，java中内嵌的SQL语⾔应尽量使⽤⼤写形式，以减少Oracle解析器的解析负担。 30、在java编程过程中，进⾏数据库连接，I/O流操作，在使⽤完毕后，及时关闭以释放资源。因为对这些⼤对象的操作会造成 系统⼤的开销。 31、保证过期的对象的及时回收具有重要意义 过分的创建对象会消耗系统的⼤量内存，严重时，会导致内存泄漏，因此，保证过期的对象的及时回收具有重要意义。JVM的GC 并⾮⼗分智能，因此建议在对象使⽤完毕后，⼿动设置成null。 32、在使⽤同步机制时，应尽量使⽤⽅法同步代替代码块同步。 33、不要在循环中使⽤Try/Catch语句，应把Try/Catch放在循环最外层 Error是获取系统错误的类，或者说是虚拟机错误的类。不是所有的错误Exception都能获取到的，虚拟机报错Exception就获取 不到，必须⽤Error获取。 34、通过StringBuffer的构造函数来设定它的初始化容量，可以明显提升性能 StringBuffer的默认容量为16，当StringBuffer的容量达到最⼤容量时，它会将⾃⾝容量增加到当前的2倍+2，也就是2*n+2。⽆ 论何时，只要StringBuffer到达它的最⼤容量，它就不得不创建⼀个新的对象数组，然后复制旧的对象数组，这会浪费很多时 间。所以给StringBuffer设置⼀个合理的初始化容量值，是很有必要的！ 35、合理使⽤java.util.Vector Vector与StringBuffer类似，每次扩展容量时，所有现有元素都要赋值到新的存储空间中。Vector的默认存储能⼒为10个元素， 扩容加倍。 vector.add(index,obj) 这个⽅法可以将元素obj插⼊到index位置，但index以及之后的元素依次都要向下移动⼀个位置（将其索 引加 1）。 除⾮必要，否则对性能不利。同样规则适⽤于remove(int index)⽅法，移除此向量中指定位置的元素。将所有后续元 素左移（将其索引减 1）。返回此向量中移除的元素。所以删除vector最后⼀个元素要⽐删除第1个元素开销低很多。删除所有元 素最好⽤removeAllElements()⽅法。 如果要删除vector⾥的⼀个元素可以使⽤ vector.remove(obj)；⽽不必⾃⼰检索元素位置，再删除，如： int index = indexOf（obj）; vector.remove(index)。 38、不⽤new关键字创建对象的实例 ⽤new关键词创建类的实例时，构造函数链中的所有构造函数都会被⾃动调⽤。但如果⼀个对象实现了Cloneable接⼝，我们可 以调⽤它的clone()⽅法。clone()⽅法不会调⽤任何类构造函数。

39、不要将数组声明为：public static final 40、HaspMap的遍历

利⽤散列值取出相应的Entry做⽐较得到结果，取得entry的值之后直接取key和value。 41、array(数组)和ArrayList的使⽤ array 数组效率最⾼，但容量固定，⽆法动态改变，ArrayList容量可以动态增⻓，但牺牲了效率。 42、单线程应尽量使⽤ HashMap, ArrayList 除⾮必要，否则不推荐使⽤HashTable,Vector，它们使⽤了同步机制，⽽降低了性能。 43、StringBuffer,StringBuilder的区别在于 java.lang.StringBuffer 线程安全的可变字符序列。⼀个类似于String的字符串缓冲区，但不能修改。StringBuilder与该类相 ⽐，通常应该优先使⽤StringBuilder类，因为它⽀持所有相同的操作，但由于它不执⾏同步，所以速度更快。 为了获得更好的性能，在构造StringBuffer或StringBuilder时应尽量指定她的容量。当然如果不超过16个字符时就不⽤了。 相 同情况下，使⽤StringBuilder⽐使⽤StringBuffer仅能获得10%~15%的性能提升，但却要冒多线程不安全的⻛险。综合考虑还 是建议使⽤StringBuffer。 44、尽量使⽤基本数据类型代替对象。 45、使⽤具体类⽐使⽤接⼝效率⾼，但结构弹性降低了，但现代IDE都可以解决这个问题。 46、考虑使⽤静态⽅法 如果你没有必要去访问对象的外部，那么就使你的⽅法成为静态⽅法。它会被更快地调⽤，因为它不需要⼀个虚拟函数导向表。 这同时也是⼀个很好的实践，因为它告诉你如何区分⽅法的性质，调⽤这个⽅法不会改变对象的状态。 47、应尽可能避免使⽤内在的GET,SET⽅法。 48、避免枚举，浮点数的使⽤。 以下举⼏个实⽤优化的例⼦： 49、避免在循环条件中使⽤复杂表达式 在不做编译优化的情况下，在循环中，循环条件会被反复计算，如果不使⽤复杂表达式，⽽使循环条件值不变的话，程序将会运 ⾏的更快。

50、为'Vectors' 和 'Hashtables'定义初始大小 JVM为Vector扩充大小的时候需要重新创建一个更大的数组，将原先数组中的内容复制过来，最后，原先的数组再被回收。可 见Vector容量的扩大是一个颇费时间的事。 通常，默认的10个元素大小是不够的。你最好能准确的估计你所需要的最佳大小。

51、在finally块中关闭Stream 程序中使⽤到的资源应当被释放，以避免资源泄漏。这最好在finally块中去做。不管程序执⾏的结果如何，finally块总是会执⾏ 的，以确保资源的正确关闭。 52、使⽤'System.arraycopy ()'代替通过来循环复制数组





